"use strict";
/*
 * --------------------------------------------------------------------------------
 * <copyright company="Aspose" file="objectSerializer.ts">
 *   Copyright (c) 2024 Aspose.Words for Cloud
 * </copyright>
 * <summary>
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 * </summary>
 * --------------------------------------------------------------------------------
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectSerializer = void 0;
const model_1 = require("../model/model");
const primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any",
];
/**
 * Serialisation helper.
 */
class ObjectSerializer {
    /**
     * Serilize object to json string.
     */
    static serialize(data, type) {
        if (data === undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            const transformedData = [];
            for (const index in data) {
                if (data.hasOwnProperty(index)) {
                    const date = data[index];
                    transformedData.push(ObjectSerializer.serialize(date, subType));
                }
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toISOString();
        }
        else {
            if (model_1.enumsMap[type]) {
                return data;
            }
            if (model_1.typeMap[data.constructor.name]) {
                type = data.constructor.name;
            }
            else {
                throw new Error('Invalid model type ' + type);
            }
            // get the map for the correct type.
            const attributeTypes = model_1.typeMap[type].getAttributeTypeMap();
            const instance = {};
            for (const index in attributeTypes) {
                if (attributeTypes.hasOwnProperty(index)) {
                    const attributeType = attributeTypes[index];
                    instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
                }
            }
            return instance;
        }
    }
    /**
     * Deserialize object from json string
     */
    static deserialize(data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data === undefined || data === null) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            const transformedData = [];
            for (const index in data) {
                if (data.hasOwnProperty(index)) {
                    const date = data[index];
                    transformedData.push(ObjectSerializer.deserialize(date, subType));
                }
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (model_1.enumsMap[type]) { // is Enum
                return data;
            }
            if (!model_1.typeMap[type]) { // dont know the type
                return data;
            }
            const instance = new model_1.typeMap[type]();
            const attributeTypes = model_1.typeMap[type].getAttributeTypeMap();
            for (const index in attributeTypes) {
                if (attributeTypes.hasOwnProperty(index)) {
                    const attributeType = attributeTypes[index];
                    if (data.hasOwnProperty(attributeType.baseName)) {
                        instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
                    }
                    else if (data.hasOwnProperty(attributeType.name)) {
                        instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.name], attributeType.type);
                    }
                }
            }
            return instance;
        }
    }
    static findCorrectType(data, expectedType) {
        if (data === undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (model_1.enumsMap[expectedType]) {
                return expectedType;
            }
            if (data['$type']) {
                var inhType = data['$type'];
                inhType = inhType.substring(0, inhType.length - 3);
                if (model_1.typeMap[inhType]) {
                    return inhType;
                }
                else {
                    throw new Error('Failed to find type ' + inhType);
                }
            }
            if (!model_1.typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            const discriminatorProperty = model_1.typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
}
exports.ObjectSerializer = ObjectSerializer;
