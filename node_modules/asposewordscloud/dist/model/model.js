"use strict";
/*
 * --------------------------------------------------------------------------------
 * <copyright company="Aspose" file="model.ts">
 *   Copyright (c) 2024 Aspose.Words for Cloud
 * </copyright>
 * <summary>
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 * </summary>
 * --------------------------------------------------------------------------------
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeleteDocumentPropertyOnlineRequest = exports.DeleteDocumentPropertyRequest = exports.DeleteCustomXmlPartsOnlineRequest = exports.DeleteCustomXmlPartsRequest = exports.DeleteCustomXmlPartOnlineRequest = exports.DeleteCustomXmlPartRequest = exports.DeleteCommentsOnlineRequest = exports.DeleteCommentsRequest = exports.DeleteCommentOnlineRequest = exports.DeleteCommentRequest = exports.DeleteBordersOnlineRequest = exports.DeleteBordersRequest = exports.DeleteBorderOnlineRequest = exports.DeleteBorderRequest = exports.DeleteBookmarksOnlineRequest = exports.DeleteBookmarksRequest = exports.DeleteBookmarkOnlineRequest = exports.DeleteBookmarkRequest = exports.DeleteAllParagraphTabStopsOnlineRequest = exports.DeleteAllParagraphTabStopsRequest = exports.CreateOrUpdateDocumentPropertyOnlineRequest = exports.CreateOrUpdateDocumentPropertyRequest = exports.CreateFolderRequest = exports.CreateDocumentRequest = exports.CopyStylesFromTemplateRequest = exports.CopyStyleOnlineRequest = exports.CopyStyleRequest = exports.CopyFolderRequest = exports.CopyFileRequest = exports.ConvertDocumentRequest = exports.CompressDocumentOnlineRequest = exports.CompressDocumentRequest = exports.CompareDocumentOnlineRequest = exports.CompareDocumentRequest = exports.ClassifyDocumentOnlineRequest = exports.ClassifyDocumentRequest = exports.ClassifyRequest = exports.BuildReportOnlineRequest = exports.BuildReportRequest = exports.ApplyStyleToDocumentElementOnlineRequest = exports.ApplyStyleToDocumentElementRequest = exports.AppendDocumentOnlineRequest = exports.AppendDocumentRequest = exports.AcceptAllRevisionsOnlineRequest = exports.AcceptAllRevisionsRequest = exports.typeMap = exports.enumsMap = exports.createUid = exports.WordsIncomingMessage = exports.AttributeInfo = void 0;
exports.GetBookmarkByNameOnlineRequest = exports.GetBookmarkByNameRequest = exports.GetAvailableFontsRequest = exports.GetAllRevisionsOnlineRequest = exports.GetAllRevisionsRequest = exports.ExecuteMailMergeOnlineRequest = exports.ExecuteMailMergeRequest = exports.DownloadFileRequest = exports.DeleteWatermarkOnlineRequest = exports.DeleteWatermarkRequest = exports.DeleteTableRowOnlineRequest = exports.DeleteTableRowRequest = exports.DeleteTableOnlineRequest = exports.DeleteTableCellOnlineRequest = exports.DeleteTableCellRequest = exports.DeleteTableRequest = exports.DeleteStructuredDocumentTagOnlineRequest = exports.DeleteStructuredDocumentTagRequest = exports.DeleteSectionOnlineRequest = exports.DeleteSectionRequest = exports.DeleteRunOnlineRequest = exports.DeleteRunRequest = exports.DeleteParagraphTabStopOnlineRequest = exports.DeleteParagraphTabStopRequest = exports.DeleteParagraphOnlineRequest = exports.DeleteParagraphListFormatOnlineRequest = exports.DeleteParagraphListFormatRequest = exports.DeleteParagraphRequest = exports.DeleteOfficeMathObjectsOnlineRequest = exports.DeleteOfficeMathObjectsRequest = exports.DeleteOfficeMathObjectOnlineRequest = exports.DeleteOfficeMathObjectRequest = exports.DeleteMacrosOnlineRequest = exports.DeleteMacrosRequest = exports.DeleteHeadersFootersOnlineRequest = exports.DeleteHeadersFootersRequest = exports.DeleteHeaderFooterOnlineRequest = exports.DeleteHeaderFooterRequest = exports.DeleteFormFieldOnlineRequest = exports.DeleteFormFieldRequest = exports.DeleteFootnoteOnlineRequest = exports.DeleteFootnoteRequest = exports.DeleteFolderRequest = exports.DeleteFileRequest = exports.DeleteFieldsOnlineRequest = exports.DeleteFieldsRequest = exports.DeleteFieldOnlineRequest = exports.DeleteFieldRequest = exports.DeleteDrawingObjectOnlineRequest = exports.DeleteDrawingObjectRequest = void 0;
exports.GetFormFieldsRequest = exports.GetFormFieldOnlineRequest = exports.GetFormFieldRequest = exports.GetFootnotesOnlineRequest = exports.GetFootnotesRequest = exports.GetFootnoteOnlineRequest = exports.GetFootnoteRequest = exports.GetFilesListRequest = exports.GetFieldsOnlineRequest = exports.GetFieldsRequest = exports.GetFieldOnlineRequest = exports.GetFieldRequest = exports.GetDocumentWithFormatRequest = exports.GetDocumentStatisticsOnlineRequest = exports.GetDocumentStatisticsRequest = exports.GetDocumentProtectionOnlineRequest = exports.GetDocumentProtectionRequest = exports.GetDocumentPropertyOnlineRequest = exports.GetDocumentPropertyRequest = exports.GetDocumentPropertiesOnlineRequest = exports.GetDocumentPropertiesRequest = exports.GetDocumentHyperlinksOnlineRequest = exports.GetDocumentHyperlinksRequest = exports.GetDocumentHyperlinkByIndexOnlineRequest = exports.GetDocumentHyperlinkByIndexRequest = exports.GetDocumentFieldNamesOnlineRequest = exports.GetDocumentFieldNamesRequest = exports.GetDocumentDrawingObjectsOnlineRequest = exports.GetDocumentDrawingObjectsRequest = exports.GetDocumentDrawingObjectOleDataOnlineRequest = exports.GetDocumentDrawingObjectOleDataRequest = exports.GetDocumentDrawingObjectImageDataOnlineRequest = exports.GetDocumentDrawingObjectImageDataRequest = exports.GetDocumentDrawingObjectByIndexOnlineRequest = exports.GetDocumentDrawingObjectByIndexRequest = exports.GetDocumentRequest = exports.GetCustomXmlPartsOnlineRequest = exports.GetCustomXmlPartsRequest = exports.GetCustomXmlPartOnlineRequest = exports.GetCustomXmlPartRequest = exports.GetCommentsOnlineRequest = exports.GetCommentsRequest = exports.GetCommentOnlineRequest = exports.GetCommentRequest = exports.GetBordersOnlineRequest = exports.GetBordersRequest = exports.GetBorderOnlineRequest = exports.GetBorderRequest = exports.GetBookmarksOnlineRequest = exports.GetBookmarksRequest = void 0;
exports.GetStyleFromDocumentElementOnlineRequest = exports.GetStyleFromDocumentElementRequest = exports.GetStyleRequest = exports.GetStructuredDocumentTagsOnlineRequest = exports.GetStructuredDocumentTagsRequest = exports.GetStructuredDocumentTagOnlineRequest = exports.GetStructuredDocumentTagRequest = exports.GetSignaturesOnlineRequest = exports.GetSignaturesRequest = exports.GetSectionsOnlineRequest = exports.GetSectionsRequest = exports.GetSectionPageSetupOnlineRequest = exports.GetSectionPageSetupRequest = exports.GetSectionOnlineRequest = exports.GetSectionRequest = exports.GetRunsOnlineRequest = exports.GetRunsRequest = exports.GetRunOnlineRequest = exports.GetRunFontOnlineRequest = exports.GetRunFontRequest = exports.GetRunRequest = exports.GetRangeTextOnlineRequest = exports.GetRangeTextRequest = exports.GetPublicKeyRequest = exports.GetParagraphTabStopsOnlineRequest = exports.GetParagraphTabStopsRequest = exports.GetParagraphsOnlineRequest = exports.GetParagraphsRequest = exports.GetParagraphOnlineRequest = exports.GetParagraphListFormatOnlineRequest = exports.GetParagraphListFormatRequest = exports.GetParagraphFormatOnlineRequest = exports.GetParagraphFormatRequest = exports.GetParagraphRequest = exports.GetOfficeMathObjectsOnlineRequest = exports.GetOfficeMathObjectsRequest = exports.GetOfficeMathObjectOnlineRequest = exports.GetOfficeMathObjectRequest = exports.GetListsOnlineRequest = exports.GetListsRequest = exports.GetListOnlineRequest = exports.GetListRequest = exports.GetInfoRequest = exports.GetHeaderFootersOnlineRequest = exports.GetHeaderFootersRequest = exports.GetHeaderFooterOnlineRequest = exports.GetHeaderFooterOfSectionOnlineRequest = exports.GetHeaderFooterOfSectionRequest = exports.GetHeaderFooterRequest = exports.GetFormFieldsOnlineRequest = void 0;
exports.InsertTableRequest = exports.InsertStyleOnlineRequest = exports.InsertStyleRequest = exports.InsertStructuredDocumentTagOnlineRequest = exports.InsertStructuredDocumentTagRequest = exports.InsertSectionOnlineRequest = exports.InsertSectionRequest = exports.InsertRunOnlineRequest = exports.InsertRunRequest = exports.InsertParagraphOnlineRequest = exports.InsertParagraphRequest = exports.InsertPageNumbersOnlineRequest = exports.InsertPageNumbersRequest = exports.InsertOrUpdateParagraphTabStopOnlineRequest = exports.InsertOrUpdateParagraphTabStopRequest = exports.InsertListOnlineRequest = exports.InsertListRequest = exports.InsertHeaderFooterOnlineRequest = exports.InsertHeaderFooterRequest = exports.InsertFormFieldOnlineRequest = exports.InsertFormFieldRequest = exports.InsertFootnoteOnlineRequest = exports.InsertFootnoteRequest = exports.InsertFieldOnlineRequest = exports.InsertFieldRequest = exports.InsertDrawingObjectOnlineRequest = exports.InsertDrawingObjectRequest = exports.InsertCustomXmlPartOnlineRequest = exports.InsertCustomXmlPartRequest = exports.InsertCommentOnlineRequest = exports.InsertCommentRequest = exports.InsertBookmarkOnlineRequest = exports.InsertBookmarkRequest = exports.GetTablesOnlineRequest = exports.GetTablesRequest = exports.GetTableRowOnlineRequest = exports.GetTableRowFormatOnlineRequest = exports.GetTableRowFormatRequest = exports.GetTableRowRequest = exports.GetTablePropertiesOnlineRequest = exports.GetTablePropertiesRequest = exports.GetTableOnlineRequest = exports.GetTableCellOnlineRequest = exports.GetTableCellFormatOnlineRequest = exports.GetTableCellFormatRequest = exports.GetTableCellRequest = exports.GetTableRequest = exports.GetStylesOnlineRequest = exports.GetStylesRequest = exports.GetStyleOnlineRequest = void 0;
exports.SearchOnlineRequest = exports.SearchRequest = exports.SaveAsTiffOnlineRequest = exports.SaveAsTiffRequest = exports.SaveAsRangeOnlineRequest = exports.SaveAsRangeRequest = exports.SaveAsOnlineRequest = exports.SaveAsRequest = exports.ResetCacheRequest = exports.ReplaceWithTextOnlineRequest = exports.ReplaceWithTextRequest = exports.ReplaceTextOnlineRequest = exports.ReplaceTextRequest = exports.RenderTableOnlineRequest = exports.RenderTableRequest = exports.RenderParagraphOnlineRequest = exports.RenderParagraphRequest = exports.RenderPageOnlineRequest = exports.RenderPageRequest = exports.RenderMathObjectOnlineRequest = exports.RenderMathObjectRequest = exports.RenderDrawingObjectOnlineRequest = exports.RenderDrawingObjectRequest = exports.RemoveRangeOnlineRequest = exports.RemoveRangeRequest = exports.RemoveAllSignaturesOnlineRequest = exports.RemoveAllSignaturesRequest = exports.RejectAllRevisionsOnlineRequest = exports.RejectAllRevisionsRequest = exports.ProtectDocumentOnlineRequest = exports.ProtectDocumentRequest = exports.OptimizeDocumentOnlineRequest = exports.OptimizeDocumentRequest = exports.MoveFolderRequest = exports.MoveFileRequest = exports.MergeWithNextOnlineRequest = exports.MergeWithNextRequest = exports.LoadWebDocumentRequest = exports.LinkHeaderFootersToPreviousRequest = exports.InsertWatermarkTextOnlineRequest = exports.InsertWatermarkTextRequest = exports.InsertWatermarkOnlineRequest = exports.InsertWatermarkImageOnlineRequest = exports.InsertWatermarkImageRequest = exports.InsertWatermarkRequest = exports.InsertTableRowOnlineRequest = exports.InsertTableRowRequest = exports.InsertTableOnlineRequest = exports.InsertTableCellOnlineRequest = exports.InsertTableCellRequest = void 0;
exports.UpdateTableRowFormatOnlineRequest = exports.UpdateTableRowFormatRequest = exports.UpdateTablePropertiesOnlineRequest = exports.UpdateTablePropertiesRequest = exports.UpdateTableCellFormatOnlineRequest = exports.UpdateTableCellFormatRequest = exports.UpdateStyleOnlineRequest = exports.UpdateStyleRequest = exports.UpdateStructuredDocumentTagOnlineRequest = exports.UpdateStructuredDocumentTagRequest = exports.UpdateSectionPageSetupOnlineRequest = exports.UpdateSectionPageSetupRequest = exports.UpdateRunOnlineRequest = exports.UpdateRunFontOnlineRequest = exports.UpdateRunFontRequest = exports.UpdateRunRequest = exports.UpdateParagraphListFormatOnlineRequest = exports.UpdateParagraphListFormatRequest = exports.UpdateParagraphFormatOnlineRequest = exports.UpdateParagraphFormatRequest = exports.UpdateListOnlineRequest = exports.UpdateListLevelOnlineRequest = exports.UpdateListLevelRequest = exports.UpdateListRequest = exports.UpdateFormFieldOnlineRequest = exports.UpdateFormFieldRequest = exports.UpdateFootnoteOnlineRequest = exports.UpdateFootnoteRequest = exports.UpdateFieldsOnlineRequest = exports.UpdateFieldsRequest = exports.UpdateFieldOnlineRequest = exports.UpdateFieldRequest = exports.UpdateDrawingObjectOnlineRequest = exports.UpdateDrawingObjectRequest = exports.UpdateCustomXmlPartOnlineRequest = exports.UpdateCustomXmlPartRequest = exports.UpdateCommentOnlineRequest = exports.UpdateCommentRequest = exports.UpdateBorderOnlineRequest = exports.UpdateBorderRequest = exports.UpdateBookmarkOnlineRequest = exports.UpdateBookmarkRequest = exports.UnprotectDocumentOnlineRequest = exports.UnprotectDocumentRequest = exports.TranslateNodeIdOnlineRequest = exports.TranslateNodeIdRequest = exports.SplitDocumentOnlineRequest = exports.SplitDocumentRequest = exports.SignDocumentOnlineRequest = exports.SignDocumentRequest = void 0;
exports.UpdateCommentOnlineResponse = exports.UpdateBorderOnlineResponse = exports.UpdateBookmarkOnlineResponse = exports.UnprotectDocumentOnlineResponse = exports.SplitDocumentOnlineResponse = exports.SignDocumentOnlineResponse = exports.SaveAsTiffOnlineResponse = exports.SaveAsRangeOnlineResponse = exports.SaveAsOnlineResponse = exports.ReplaceWithTextOnlineResponse = exports.ReplaceTextOnlineResponse = exports.RemoveRangeOnlineResponse = exports.RemoveAllSignaturesOnlineResponse = exports.RejectAllRevisionsOnlineResponse = exports.ProtectDocumentOnlineResponse = exports.InsertWatermarkTextOnlineResponse = exports.InsertWatermarkOnlineResponse = exports.InsertWatermarkImageOnlineResponse = exports.InsertTableRowOnlineResponse = exports.InsertTableOnlineResponse = exports.InsertTableCellOnlineResponse = exports.InsertStyleOnlineResponse = exports.InsertStructuredDocumentTagOnlineResponse = exports.InsertRunOnlineResponse = exports.InsertParagraphOnlineResponse = exports.InsertPageNumbersOnlineResponse = exports.InsertOrUpdateParagraphTabStopOnlineResponse = exports.InsertListOnlineResponse = exports.InsertHeaderFooterOnlineResponse = exports.InsertFormFieldOnlineResponse = exports.InsertFootnoteOnlineResponse = exports.InsertFieldOnlineResponse = exports.InsertDrawingObjectOnlineResponse = exports.InsertCustomXmlPartOnlineResponse = exports.InsertCommentOnlineResponse = exports.InsertBookmarkOnlineResponse = exports.DeleteWatermarkOnlineResponse = exports.DeleteParagraphTabStopOnlineResponse = exports.DeleteParagraphListFormatOnlineResponse = exports.DeleteBordersOnlineResponse = exports.DeleteBorderOnlineResponse = exports.DeleteAllParagraphTabStopsOnlineResponse = exports.CreateOrUpdateDocumentPropertyOnlineResponse = exports.CopyStyleOnlineResponse = exports.CompressDocumentOnlineResponse = exports.CompareDocumentOnlineResponse = exports.ApplyStyleToDocumentElementOnlineResponse = exports.AppendDocumentOnlineResponse = exports.AcceptAllRevisionsOnlineResponse = exports.UploadFileRequest = void 0;
exports.UpdateTableRowFormatOnlineResponse = exports.UpdateTablePropertiesOnlineResponse = exports.UpdateTableCellFormatOnlineResponse = exports.UpdateStyleOnlineResponse = exports.UpdateStructuredDocumentTagOnlineResponse = exports.UpdateSectionPageSetupOnlineResponse = exports.UpdateRunOnlineResponse = exports.UpdateRunFontOnlineResponse = exports.UpdateParagraphListFormatOnlineResponse = exports.UpdateParagraphFormatOnlineResponse = exports.UpdateListOnlineResponse = exports.UpdateListLevelOnlineResponse = exports.UpdateFormFieldOnlineResponse = exports.UpdateFootnoteOnlineResponse = exports.UpdateFieldsOnlineResponse = exports.UpdateFieldOnlineResponse = exports.UpdateDrawingObjectOnlineResponse = exports.UpdateCustomXmlPartOnlineResponse = void 0;
const uuid_1 = require("uuid");
const requestHelper_1 = require("../internal/requestHelper");
const objectSerializer_1 = require("../internal/objectSerializer");
const api_1 = require("../api");
const importedApiError = require("./apiError");
const importedAvailableFontsResponse = require("./availableFontsResponse");
const importedAzw3SaveOptionsData = require("./azw3SaveOptionsData");
const importedBmpSaveOptionsData = require("./bmpSaveOptionsData");
const importedBookmark = require("./bookmark");
const importedBookmarkData = require("./bookmarkData");
const importedBookmarkInsert = require("./bookmarkInsert");
const importedBookmarkResponse = require("./bookmarkResponse");
const importedBookmarks = require("./bookmarks");
const importedBookmarksOutlineLevelData = require("./bookmarksOutlineLevelData");
const importedBookmarksResponse = require("./bookmarksResponse");
const importedBorder = require("./border");
const importedBorderResponse = require("./borderResponse");
const importedBordersCollection = require("./bordersCollection");
const importedBordersResponse = require("./bordersResponse");
const importedClassificationResponse = require("./classificationResponse");
const importedClassificationResult = require("./classificationResult");
const importedComment = require("./comment");
const importedCommentInsert = require("./commentInsert");
const importedCommentLink = require("./commentLink");
const importedCommentResponse = require("./commentResponse");
const importedCommentsCollection = require("./commentsCollection");
const importedCommentsResponse = require("./commentsResponse");
const importedCommentUpdate = require("./commentUpdate");
const importedCompareData = require("./compareData");
const importedCompareOptions = require("./compareOptions");
const importedCompressOptions = require("./compressOptions");
const importedCompressResponse = require("./compressResponse");
const importedCsvDataLoadOptions = require("./csvDataLoadOptions");
const importedCustomXmlPart = require("./customXmlPart");
const importedCustomXmlPartInsert = require("./customXmlPartInsert");
const importedCustomXmlPartLink = require("./customXmlPartLink");
const importedCustomXmlPartResponse = require("./customXmlPartResponse");
const importedCustomXmlPartsCollection = require("./customXmlPartsCollection");
const importedCustomXmlPartsResponse = require("./customXmlPartsResponse");
const importedCustomXmlPartUpdate = require("./customXmlPartUpdate");
const importedDigitalSignatureDetails = require("./digitalSignatureDetails");
const importedDocmSaveOptionsData = require("./docmSaveOptionsData");
const importedDocSaveOptionsData = require("./docSaveOptionsData");
const importedDocument = require("./document");
const importedDocumentEntry = require("./documentEntry");
const importedDocumentEntryList = require("./documentEntryList");
const importedDocumentPosition = require("./documentPosition");
const importedDocumentProperties = require("./documentProperties");
const importedDocumentPropertiesResponse = require("./documentPropertiesResponse");
const importedDocumentProperty = require("./documentProperty");
const importedDocumentPropertyCreateOrUpdate = require("./documentPropertyCreateOrUpdate");
const importedDocumentPropertyResponse = require("./documentPropertyResponse");
const importedDocumentResponse = require("./documentResponse");
const importedDocumentStatData = require("./documentStatData");
const importedDocxSaveOptionsData = require("./docxSaveOptionsData");
const importedDotmSaveOptionsData = require("./dotmSaveOptionsData");
const importedDotSaveOptionsData = require("./dotSaveOptionsData");
const importedDotxSaveOptionsData = require("./dotxSaveOptionsData");
const importedDownsampleOptionsData = require("./downsampleOptionsData");
const importedDrawingObject = require("./drawingObject");
const importedDrawingObjectCollection = require("./drawingObjectCollection");
const importedDrawingObjectInsert = require("./drawingObjectInsert");
const importedDrawingObjectLink = require("./drawingObjectLink");
const importedDrawingObjectResponse = require("./drawingObjectResponse");
const importedDrawingObjectsResponse = require("./drawingObjectsResponse");
const importedDrawingObjectUpdate = require("./drawingObjectUpdate");
const importedEmfSaveOptionsData = require("./emfSaveOptionsData");
const importedEpsSaveOptionsData = require("./epsSaveOptionsData");
const importedEpubSaveOptionsData = require("./epubSaveOptionsData");
const importedError = require("./error");
const importedErrorDetails = require("./errorDetails");
const importedField = require("./field");
const importedFieldCollection = require("./fieldCollection");
const importedFieldInsert = require("./fieldInsert");
const importedFieldLink = require("./fieldLink");
const importedFieldNames = require("./fieldNames");
const importedFieldNamesResponse = require("./fieldNamesResponse");
const importedFieldOptions = require("./fieldOptions");
const importedFieldResponse = require("./fieldResponse");
const importedFieldsResponse = require("./fieldsResponse");
const importedFieldUpdate = require("./fieldUpdate");
const importedFileLink = require("./fileLink");
const importedFileReference = require("./fileReference");
const importedFilesList = require("./filesList");
const importedFilesUploadResult = require("./filesUploadResult");
const importedFixedPageSaveOptionsData = require("./fixedPageSaveOptionsData");
const importedFlatOpcMacroSaveOptionsData = require("./flatOpcMacroSaveOptionsData");
const importedFlatOpcSaveOptionsData = require("./flatOpcSaveOptionsData");
const importedFlatOpcTemplateMacroSaveOptionsData = require("./flatOpcTemplateMacroSaveOptionsData");
const importedFlatOpcTemplateSaveOptionsData = require("./flatOpcTemplateSaveOptionsData");
const importedFont = require("./font");
const importedFontInfo = require("./fontInfo");
const importedFontResponse = require("./fontResponse");
const importedFootnote = require("./footnote");
const importedFootnoteBase = require("./footnoteBase");
const importedFootnoteCollection = require("./footnoteCollection");
const importedFootnoteInsert = require("./footnoteInsert");
const importedFootnoteLink = require("./footnoteLink");
const importedFootnoteResponse = require("./footnoteResponse");
const importedFootnotesResponse = require("./footnotesResponse");
const importedFootnotesStatData = require("./footnotesStatData");
const importedFootnoteUpdate = require("./footnoteUpdate");
const importedFormFieldCheckbox = require("./formFieldCheckbox");
const importedFormFieldCollection = require("./formFieldCollection");
const importedFormFieldDropDown = require("./formFieldDropDown");
const importedFormFieldResponse = require("./formFieldResponse");
const importedFormFieldsResponse = require("./formFieldsResponse");
const importedFormFieldTextInput = require("./formFieldTextInput");
const importedGifSaveOptionsData = require("./gifSaveOptionsData");
const importedHeaderFooter = require("./headerFooter");
const importedHeaderFooterLink = require("./headerFooterLink");
const importedHeaderFooterLinkCollection = require("./headerFooterLinkCollection");
const importedHeaderFooterResponse = require("./headerFooterResponse");
const importedHeaderFootersResponse = require("./headerFootersResponse");
const importedHtmlFixedSaveOptionsData = require("./htmlFixedSaveOptionsData");
const importedHtmlSaveOptionsData = require("./htmlSaveOptionsData");
const importedHyperlink = require("./hyperlink");
const importedHyperlinkResponse = require("./hyperlinkResponse");
const importedHyperlinks = require("./hyperlinks");
const importedHyperlinksResponse = require("./hyperlinksResponse");
const importedImageEntry = require("./imageEntry");
const importedImageEntryList = require("./imageEntryList");
const importedImageSaveOptionsData = require("./imageSaveOptionsData");
const importedInfoAdditionalItem = require("./infoAdditionalItem");
const importedInfoResponse = require("./infoResponse");
const importedJpegSaveOptionsData = require("./jpegSaveOptionsData");
const importedJsonDataLoadOptions = require("./jsonDataLoadOptions");
const importedLink = require("./link");
const importedLinkElement = require("./linkElement");
const importedListFormat = require("./listFormat");
const importedListFormatUpdate = require("./listFormatUpdate");
const importedListInfo = require("./listInfo");
const importedListInsert = require("./listInsert");
const importedListLevel = require("./listLevel");
const importedListLevels = require("./listLevels");
const importedListLevelUpdate = require("./listLevelUpdate");
const importedListResponse = require("./listResponse");
const importedLists = require("./lists");
const importedListsResponse = require("./listsResponse");
const importedListUpdate = require("./listUpdate");
const importedLoadWebDocumentData = require("./loadWebDocumentData");
const importedMarkdownSaveOptionsData = require("./markdownSaveOptionsData");
const importedMetafileRenderingOptionsData = require("./metafileRenderingOptionsData");
const importedMhtmlSaveOptionsData = require("./mhtmlSaveOptionsData");
const importedModificationOperationResult = require("./modificationOperationResult");
const importedNodeLink = require("./nodeLink");
const importedOdtSaveOptionsData = require("./odtSaveOptionsData");
const importedOfficeMathLink = require("./officeMathLink");
const importedOfficeMathObject = require("./officeMathObject");
const importedOfficeMathObjectResponse = require("./officeMathObjectResponse");
const importedOfficeMathObjectsCollection = require("./officeMathObjectsCollection");
const importedOfficeMathObjectsResponse = require("./officeMathObjectsResponse");
const importedOoxmlSaveOptionsData = require("./ooxmlSaveOptionsData");
const importedOpenXpsSaveOptionsData = require("./openXpsSaveOptionsData");
const importedOptimizationOptions = require("./optimizationOptions");
const importedOttSaveOptionsData = require("./ottSaveOptionsData");
const importedOutlineOptionsData = require("./outlineOptionsData");
const importedPageNumber = require("./pageNumber");
const importedPageSetup = require("./pageSetup");
const importedPageStatData = require("./pageStatData");
const importedParagraph = require("./paragraph");
const importedParagraphFormat = require("./paragraphFormat");
const importedParagraphFormatBase = require("./paragraphFormatBase");
const importedParagraphFormatResponse = require("./paragraphFormatResponse");
const importedParagraphFormatUpdate = require("./paragraphFormatUpdate");
const importedParagraphInsert = require("./paragraphInsert");
const importedParagraphLink = require("./paragraphLink");
const importedParagraphLinkCollection = require("./paragraphLinkCollection");
const importedParagraphLinkCollectionResponse = require("./paragraphLinkCollectionResponse");
const importedParagraphListFormatResponse = require("./paragraphListFormatResponse");
const importedParagraphResponse = require("./paragraphResponse");
const importedPclSaveOptionsData = require("./pclSaveOptionsData");
const importedPdfDigitalSignatureDetailsData = require("./pdfDigitalSignatureDetailsData");
const importedPdfEncryptionDetailsData = require("./pdfEncryptionDetailsData");
const importedPdfPermissions = require("./pdfPermissions");
const importedPdfSaveOptionsData = require("./pdfSaveOptionsData");
const importedPngSaveOptionsData = require("./pngSaveOptionsData");
const importedPositionAfterNode = require("./positionAfterNode");
const importedPositionBeforeNode = require("./positionBeforeNode");
const importedPositionInsideNode = require("./positionInsideNode");
const importedPreferredWidth = require("./preferredWidth");
const importedProtectionData = require("./protectionData");
const importedProtectionDataResponse = require("./protectionDataResponse");
const importedProtectionRequest = require("./protectionRequest");
const importedProtectionRequestV2 = require("./protectionRequestV2");
const importedPsSaveOptionsData = require("./psSaveOptionsData");
const importedPublicKeyResponse = require("./publicKeyResponse");
const importedRangeDocument = require("./rangeDocument");
const importedRangeTextResponse = require("./rangeTextResponse");
const importedReplaceRange = require("./replaceRange");
const importedReplaceTextParameters = require("./replaceTextParameters");
const importedReplaceTextResponse = require("./replaceTextResponse");
const importedReportBuildOptions = require("./reportBuildOptions");
const importedReportEngineSettings = require("./reportEngineSettings");
const importedRevision = require("./revision");
const importedRevisionCollection = require("./revisionCollection");
const importedRevisionsModificationResponse = require("./revisionsModificationResponse");
const importedRevisionsResponse = require("./revisionsResponse");
const importedRtfSaveOptionsData = require("./rtfSaveOptionsData");
const importedRun = require("./run");
const importedRunInsert = require("./runInsert");
const importedRunLink = require("./runLink");
const importedRunResponse = require("./runResponse");
const importedRuns = require("./runs");
const importedRunsResponse = require("./runsResponse");
const importedRunUpdate = require("./runUpdate");
const importedSaveOptionsData = require("./saveOptionsData");
const importedSaveResponse = require("./saveResponse");
const importedSaveResult = require("./saveResult");
const importedSearchResponse = require("./searchResponse");
const importedSearchResult = require("./searchResult");
const importedSearchResultsCollection = require("./searchResultsCollection");
const importedSection = require("./section");
const importedSectionLink = require("./sectionLink");
const importedSectionLinkCollection = require("./sectionLinkCollection");
const importedSectionLinkCollectionResponse = require("./sectionLinkCollectionResponse");
const importedSectionPageSetupResponse = require("./sectionPageSetupResponse");
const importedSectionResponse = require("./sectionResponse");
const importedShading = require("./shading");
const importedSignature = require("./signature");
const importedSignatureCollectionResponse = require("./signatureCollectionResponse");
const importedSignOptions = require("./signOptions");
const importedSplitDocumentResponse = require("./splitDocumentResponse");
const importedSplitDocumentResult = require("./splitDocumentResult");
const importedStatDataResponse = require("./statDataResponse");
const importedStorageFile = require("./storageFile");
const importedStoryChildNodes = require("./storyChildNodes");
const importedStructuredDocumentTag = require("./structuredDocumentTag");
const importedStructuredDocumentTagBase = require("./structuredDocumentTagBase");
const importedStructuredDocumentTagCollection = require("./structuredDocumentTagCollection");
const importedStructuredDocumentTagInsert = require("./structuredDocumentTagInsert");
const importedStructuredDocumentTagListItem = require("./structuredDocumentTagListItem");
const importedStructuredDocumentTagResponse = require("./structuredDocumentTagResponse");
const importedStructuredDocumentTagsResponse = require("./structuredDocumentTagsResponse");
const importedStructuredDocumentTagUpdate = require("./structuredDocumentTagUpdate");
const importedStyle = require("./style");
const importedStyleApply = require("./styleApply");
const importedStyleCopy = require("./styleCopy");
const importedStyleInsert = require("./styleInsert");
const importedStyleResponse = require("./styleResponse");
const importedStylesResponse = require("./stylesResponse");
const importedStyleUpdate = require("./styleUpdate");
const importedSvgSaveOptionsData = require("./svgSaveOptionsData");
const importedTable = require("./table");
const importedTableCell = require("./tableCell");
const importedTableCellFormat = require("./tableCellFormat");
const importedTableCellFormatResponse = require("./tableCellFormatResponse");
const importedTableCellInsert = require("./tableCellInsert");
const importedTableCellResponse = require("./tableCellResponse");
const importedTableInsert = require("./tableInsert");
const importedTableLink = require("./tableLink");
const importedTableLinkCollection = require("./tableLinkCollection");
const importedTableLinkCollectionResponse = require("./tableLinkCollectionResponse");
const importedTableProperties = require("./tableProperties");
const importedTablePropertiesResponse = require("./tablePropertiesResponse");
const importedTableResponse = require("./tableResponse");
const importedTableRow = require("./tableRow");
const importedTableRowFormat = require("./tableRowFormat");
const importedTableRowFormatResponse = require("./tableRowFormatResponse");
const importedTableRowInsert = require("./tableRowInsert");
const importedTableRowResponse = require("./tableRowResponse");
const importedTabStop = require("./tabStop");
const importedTabStopBase = require("./tabStopBase");
const importedTabStopInsert = require("./tabStopInsert");
const importedTabStopsResponse = require("./tabStopsResponse");
const importedTextSaveOptionsData = require("./textSaveOptionsData");
const importedTiffSaveOptionsData = require("./tiffSaveOptionsData");
const importedTimeZoneInfoData = require("./timeZoneInfoData");
const importedTranslateNodeIdResponse = require("./translateNodeIdResponse");
const importedTxtSaveOptionsBaseData = require("./txtSaveOptionsBaseData");
const importedUserInformation = require("./userInformation");
const importedWatermarkDataImage = require("./watermarkDataImage");
const importedWatermarkDataText = require("./watermarkDataText");
const importedWatermarkText = require("./watermarkText");
const importedWordMLSaveOptionsData = require("./wordMLSaveOptionsData");
const importedWordsApiErrorResponse = require("./wordsApiErrorResponse");
const importedWordsApiLink = require("./wordsApiLink");
const importedWordsResponse = require("./wordsResponse");
const importedXamlFixedSaveOptionsData = require("./xamlFixedSaveOptionsData");
const importedXamlFlowPackSaveOptionsData = require("./xamlFlowPackSaveOptionsData");
const importedXamlFlowSaveOptionsData = require("./xamlFlowSaveOptionsData");
const importedXmlColor = require("./xmlColor");
const importedXmlDataLoadOptions = require("./xmlDataLoadOptions");
const importedXpsSaveOptionsData = require("./xpsSaveOptionsData");
var attributeInfo_1 = require("../internal/attributeInfo");
Object.defineProperty(exports, "AttributeInfo", { enumerable: true, get: function () { return attributeInfo_1.AttributeInfo; } });
__exportStar(require("./apiError"), exports);
__exportStar(require("./availableFontsResponse"), exports);
__exportStar(require("./azw3SaveOptionsData"), exports);
__exportStar(require("./baseEntry"), exports);
__exportStar(require("./baseEntryList"), exports);
__exportStar(require("./bmpSaveOptionsData"), exports);
__exportStar(require("./bookmark"), exports);
__exportStar(require("./bookmarkData"), exports);
__exportStar(require("./bookmarkInsert"), exports);
__exportStar(require("./bookmarkResponse"), exports);
__exportStar(require("./bookmarks"), exports);
__exportStar(require("./bookmarksOutlineLevelData"), exports);
__exportStar(require("./bookmarksResponse"), exports);
__exportStar(require("./border"), exports);
__exportStar(require("./borderResponse"), exports);
__exportStar(require("./bordersCollection"), exports);
__exportStar(require("./bordersResponse"), exports);
__exportStar(require("./classificationResponse"), exports);
__exportStar(require("./classificationResult"), exports);
__exportStar(require("./comment"), exports);
__exportStar(require("./commentBase"), exports);
__exportStar(require("./commentInsert"), exports);
__exportStar(require("./commentLink"), exports);
__exportStar(require("./commentResponse"), exports);
__exportStar(require("./commentsCollection"), exports);
__exportStar(require("./commentsResponse"), exports);
__exportStar(require("./commentUpdate"), exports);
__exportStar(require("./compareData"), exports);
__exportStar(require("./compareOptions"), exports);
__exportStar(require("./compressOptions"), exports);
__exportStar(require("./compressResponse"), exports);
__exportStar(require("./csvDataLoadOptions"), exports);
__exportStar(require("./customXmlPart"), exports);
__exportStar(require("./customXmlPartInsert"), exports);
__exportStar(require("./customXmlPartLink"), exports);
__exportStar(require("./customXmlPartResponse"), exports);
__exportStar(require("./customXmlPartsCollection"), exports);
__exportStar(require("./customXmlPartsResponse"), exports);
__exportStar(require("./customXmlPartUpdate"), exports);
__exportStar(require("./digitalSignatureDetails"), exports);
__exportStar(require("./docmSaveOptionsData"), exports);
__exportStar(require("./docSaveOptionsData"), exports);
__exportStar(require("./document"), exports);
__exportStar(require("./documentEntry"), exports);
__exportStar(require("./documentEntryList"), exports);
__exportStar(require("./documentPosition"), exports);
__exportStar(require("./documentProperties"), exports);
__exportStar(require("./documentPropertiesResponse"), exports);
__exportStar(require("./documentProperty"), exports);
__exportStar(require("./documentPropertyCreateOrUpdate"), exports);
__exportStar(require("./documentPropertyResponse"), exports);
__exportStar(require("./documentResponse"), exports);
__exportStar(require("./documentStatData"), exports);
__exportStar(require("./docxSaveOptionsData"), exports);
__exportStar(require("./dotmSaveOptionsData"), exports);
__exportStar(require("./dotSaveOptionsData"), exports);
__exportStar(require("./dotxSaveOptionsData"), exports);
__exportStar(require("./downsampleOptionsData"), exports);
__exportStar(require("./drawingObject"), exports);
__exportStar(require("./drawingObjectCollection"), exports);
__exportStar(require("./drawingObjectInsert"), exports);
__exportStar(require("./drawingObjectLink"), exports);
__exportStar(require("./drawingObjectResponse"), exports);
__exportStar(require("./drawingObjectsResponse"), exports);
__exportStar(require("./drawingObjectUpdate"), exports);
__exportStar(require("./emfSaveOptionsData"), exports);
__exportStar(require("./epsSaveOptionsData"), exports);
__exportStar(require("./epubSaveOptionsData"), exports);
__exportStar(require("./error"), exports);
__exportStar(require("./errorDetails"), exports);
__exportStar(require("./field"), exports);
__exportStar(require("./fieldBase"), exports);
__exportStar(require("./fieldCollection"), exports);
__exportStar(require("./fieldInsert"), exports);
__exportStar(require("./fieldLink"), exports);
__exportStar(require("./fieldNames"), exports);
__exportStar(require("./fieldNamesResponse"), exports);
__exportStar(require("./fieldOptions"), exports);
__exportStar(require("./fieldResponse"), exports);
__exportStar(require("./fieldsResponse"), exports);
__exportStar(require("./fieldUpdate"), exports);
__exportStar(require("./fileLink"), exports);
__exportStar(require("./fileReference"), exports);
__exportStar(require("./filesList"), exports);
__exportStar(require("./filesUploadResult"), exports);
__exportStar(require("./fixedPageSaveOptionsData"), exports);
__exportStar(require("./flatOpcMacroSaveOptionsData"), exports);
__exportStar(require("./flatOpcSaveOptionsData"), exports);
__exportStar(require("./flatOpcTemplateMacroSaveOptionsData"), exports);
__exportStar(require("./flatOpcTemplateSaveOptionsData"), exports);
__exportStar(require("./font"), exports);
__exportStar(require("./fontInfo"), exports);
__exportStar(require("./fontResponse"), exports);
__exportStar(require("./footnote"), exports);
__exportStar(require("./footnoteBase"), exports);
__exportStar(require("./footnoteCollection"), exports);
__exportStar(require("./footnoteInsert"), exports);
__exportStar(require("./footnoteLink"), exports);
__exportStar(require("./footnoteResponse"), exports);
__exportStar(require("./footnotesResponse"), exports);
__exportStar(require("./footnotesStatData"), exports);
__exportStar(require("./footnoteUpdate"), exports);
__exportStar(require("./formField"), exports);
__exportStar(require("./formFieldCheckbox"), exports);
__exportStar(require("./formFieldCollection"), exports);
__exportStar(require("./formFieldDropDown"), exports);
__exportStar(require("./formFieldResponse"), exports);
__exportStar(require("./formFieldsResponse"), exports);
__exportStar(require("./formFieldTextInput"), exports);
__exportStar(require("./gifSaveOptionsData"), exports);
__exportStar(require("./headerFooter"), exports);
__exportStar(require("./headerFooterLink"), exports);
__exportStar(require("./headerFooterLinkCollection"), exports);
__exportStar(require("./headerFooterResponse"), exports);
__exportStar(require("./headerFootersResponse"), exports);
__exportStar(require("./htmlFixedSaveOptionsData"), exports);
__exportStar(require("./htmlSaveOptionsData"), exports);
__exportStar(require("./hyperlink"), exports);
__exportStar(require("./hyperlinkResponse"), exports);
__exportStar(require("./hyperlinks"), exports);
__exportStar(require("./hyperlinksResponse"), exports);
__exportStar(require("./imageEntry"), exports);
__exportStar(require("./imageEntryList"), exports);
__exportStar(require("./imageSaveOptionsData"), exports);
__exportStar(require("./infoAdditionalItem"), exports);
__exportStar(require("./infoResponse"), exports);
__exportStar(require("./jpegSaveOptionsData"), exports);
__exportStar(require("./jsonDataLoadOptions"), exports);
__exportStar(require("./link"), exports);
__exportStar(require("./linkElement"), exports);
__exportStar(require("./listFormat"), exports);
__exportStar(require("./listFormatUpdate"), exports);
__exportStar(require("./listInfo"), exports);
__exportStar(require("./listInsert"), exports);
__exportStar(require("./listLevel"), exports);
__exportStar(require("./listLevels"), exports);
__exportStar(require("./listLevelUpdate"), exports);
__exportStar(require("./listResponse"), exports);
__exportStar(require("./lists"), exports);
__exportStar(require("./listsResponse"), exports);
__exportStar(require("./listUpdate"), exports);
__exportStar(require("./loadWebDocumentData"), exports);
__exportStar(require("./markdownSaveOptionsData"), exports);
__exportStar(require("./metafileRenderingOptionsData"), exports);
__exportStar(require("./mhtmlSaveOptionsData"), exports);
__exportStar(require("./modificationOperationResult"), exports);
__exportStar(require("./nodeLink"), exports);
__exportStar(require("./odtSaveOptionsData"), exports);
__exportStar(require("./officeMathLink"), exports);
__exportStar(require("./officeMathObject"), exports);
__exportStar(require("./officeMathObjectResponse"), exports);
__exportStar(require("./officeMathObjectsCollection"), exports);
__exportStar(require("./officeMathObjectsResponse"), exports);
__exportStar(require("./ooxmlSaveOptionsData"), exports);
__exportStar(require("./openXpsSaveOptionsData"), exports);
__exportStar(require("./optimizationOptions"), exports);
__exportStar(require("./ottSaveOptionsData"), exports);
__exportStar(require("./outlineOptionsData"), exports);
__exportStar(require("./pageNumber"), exports);
__exportStar(require("./pageSetup"), exports);
__exportStar(require("./pageStatData"), exports);
__exportStar(require("./paragraph"), exports);
__exportStar(require("./paragraphFormat"), exports);
__exportStar(require("./paragraphFormatBase"), exports);
__exportStar(require("./paragraphFormatResponse"), exports);
__exportStar(require("./paragraphFormatUpdate"), exports);
__exportStar(require("./paragraphInsert"), exports);
__exportStar(require("./paragraphLink"), exports);
__exportStar(require("./paragraphLinkCollection"), exports);
__exportStar(require("./paragraphLinkCollectionResponse"), exports);
__exportStar(require("./paragraphListFormatResponse"), exports);
__exportStar(require("./paragraphResponse"), exports);
__exportStar(require("./pclSaveOptionsData"), exports);
__exportStar(require("./pdfDigitalSignatureDetailsData"), exports);
__exportStar(require("./pdfEncryptionDetailsData"), exports);
__exportStar(require("./pdfPermissions"), exports);
__exportStar(require("./pdfSaveOptionsData"), exports);
__exportStar(require("./pngSaveOptionsData"), exports);
__exportStar(require("./position"), exports);
__exportStar(require("./positionAfterNode"), exports);
__exportStar(require("./positionBeforeNode"), exports);
__exportStar(require("./positionInsideNode"), exports);
__exportStar(require("./preferredWidth"), exports);
__exportStar(require("./protectionData"), exports);
__exportStar(require("./protectionDataResponse"), exports);
__exportStar(require("./protectionRequest"), exports);
__exportStar(require("./protectionRequestBase"), exports);
__exportStar(require("./protectionRequestV2"), exports);
__exportStar(require("./psSaveOptionsData"), exports);
__exportStar(require("./publicKeyResponse"), exports);
__exportStar(require("./rangeDocument"), exports);
__exportStar(require("./rangeTextResponse"), exports);
__exportStar(require("./replaceRange"), exports);
__exportStar(require("./replaceTextParameters"), exports);
__exportStar(require("./replaceTextResponse"), exports);
__exportStar(require("./reportBuildOptions"), exports);
__exportStar(require("./reportEngineSettings"), exports);
__exportStar(require("./revision"), exports);
__exportStar(require("./revisionCollection"), exports);
__exportStar(require("./revisionsModificationResponse"), exports);
__exportStar(require("./revisionsResponse"), exports);
__exportStar(require("./rtfSaveOptionsData"), exports);
__exportStar(require("./run"), exports);
__exportStar(require("./runBase"), exports);
__exportStar(require("./runInsert"), exports);
__exportStar(require("./runLink"), exports);
__exportStar(require("./runResponse"), exports);
__exportStar(require("./runs"), exports);
__exportStar(require("./runsResponse"), exports);
__exportStar(require("./runUpdate"), exports);
__exportStar(require("./saveOptionsData"), exports);
__exportStar(require("./saveResponse"), exports);
__exportStar(require("./saveResult"), exports);
__exportStar(require("./searchResponse"), exports);
__exportStar(require("./searchResult"), exports);
__exportStar(require("./searchResultsCollection"), exports);
__exportStar(require("./section"), exports);
__exportStar(require("./sectionLink"), exports);
__exportStar(require("./sectionLinkCollection"), exports);
__exportStar(require("./sectionLinkCollectionResponse"), exports);
__exportStar(require("./sectionPageSetupResponse"), exports);
__exportStar(require("./sectionResponse"), exports);
__exportStar(require("./shading"), exports);
__exportStar(require("./signature"), exports);
__exportStar(require("./signatureCollectionResponse"), exports);
__exportStar(require("./signOptions"), exports);
__exportStar(require("./splitDocumentResponse"), exports);
__exportStar(require("./splitDocumentResult"), exports);
__exportStar(require("./statDataResponse"), exports);
__exportStar(require("./storageFile"), exports);
__exportStar(require("./storyChildNodes"), exports);
__exportStar(require("./structuredDocumentTag"), exports);
__exportStar(require("./structuredDocumentTagBase"), exports);
__exportStar(require("./structuredDocumentTagCollection"), exports);
__exportStar(require("./structuredDocumentTagInsert"), exports);
__exportStar(require("./structuredDocumentTagListItem"), exports);
__exportStar(require("./structuredDocumentTagResponse"), exports);
__exportStar(require("./structuredDocumentTagsResponse"), exports);
__exportStar(require("./structuredDocumentTagUpdate"), exports);
__exportStar(require("./style"), exports);
__exportStar(require("./styleApply"), exports);
__exportStar(require("./styleCopy"), exports);
__exportStar(require("./styleInsert"), exports);
__exportStar(require("./styleResponse"), exports);
__exportStar(require("./stylesResponse"), exports);
__exportStar(require("./styleUpdate"), exports);
__exportStar(require("./svgSaveOptionsData"), exports);
__exportStar(require("./table"), exports);
__exportStar(require("./tableCell"), exports);
__exportStar(require("./tableCellFormat"), exports);
__exportStar(require("./tableCellFormatResponse"), exports);
__exportStar(require("./tableCellInsert"), exports);
__exportStar(require("./tableCellResponse"), exports);
__exportStar(require("./tableInsert"), exports);
__exportStar(require("./tableLink"), exports);
__exportStar(require("./tableLinkCollection"), exports);
__exportStar(require("./tableLinkCollectionResponse"), exports);
__exportStar(require("./tableProperties"), exports);
__exportStar(require("./tablePropertiesResponse"), exports);
__exportStar(require("./tableResponse"), exports);
__exportStar(require("./tableRow"), exports);
__exportStar(require("./tableRowFormat"), exports);
__exportStar(require("./tableRowFormatResponse"), exports);
__exportStar(require("./tableRowInsert"), exports);
__exportStar(require("./tableRowResponse"), exports);
__exportStar(require("./tabStop"), exports);
__exportStar(require("./tabStopBase"), exports);
__exportStar(require("./tabStopInsert"), exports);
__exportStar(require("./tabStopsResponse"), exports);
__exportStar(require("./textSaveOptionsData"), exports);
__exportStar(require("./tiffSaveOptionsData"), exports);
__exportStar(require("./timeZoneInfoData"), exports);
__exportStar(require("./translateNodeIdResponse"), exports);
__exportStar(require("./txtSaveOptionsBaseData"), exports);
__exportStar(require("./userInformation"), exports);
__exportStar(require("./watermarkDataBase"), exports);
__exportStar(require("./watermarkDataImage"), exports);
__exportStar(require("./watermarkDataText"), exports);
__exportStar(require("./watermarkText"), exports);
__exportStar(require("./wordMLSaveOptionsData"), exports);
__exportStar(require("./wordsApiErrorResponse"), exports);
__exportStar(require("./wordsApiLink"), exports);
__exportStar(require("./wordsResponse"), exports);
__exportStar(require("./xamlFixedSaveOptionsData"), exports);
__exportStar(require("./xamlFlowPackSaveOptionsData"), exports);
__exportStar(require("./xamlFlowSaveOptionsData"), exports);
__exportStar(require("./xmlColor"), exports);
__exportStar(require("./xmlDataLoadOptions"), exports);
__exportStar(require("./xpsSaveOptionsData"), exports);
/**
 * WordsIncomingMessage
 */
class WordsIncomingMessage {
}
exports.WordsIncomingMessage = WordsIncomingMessage;
const enumsMap = {
    "Border.BorderTypeEnum": importedBorder.Border.BorderTypeEnum,
    "Border.LineStyleEnum": importedBorder.Border.LineStyleEnum,
    "CompareOptions.TargetEnum": importedCompareOptions.CompareOptions.TargetEnum,
    "Document.SourceFormatEnum": importedDocument.Document.SourceFormatEnum,
    "DocumentEntry.ImportFormatModeEnum": importedDocumentEntry.DocumentEntry.ImportFormatModeEnum,
    "DrawingObject.RelativeHorizontalPositionEnum": importedDrawingObject.DrawingObject.RelativeHorizontalPositionEnum,
    "DrawingObject.RelativeVerticalPositionEnum": importedDrawingObject.DrawingObject.RelativeVerticalPositionEnum,
    "DrawingObject.WrapTypeEnum": importedDrawingObject.DrawingObject.WrapTypeEnum,
    "DrawingObjectInsert.RelativeHorizontalPositionEnum": importedDrawingObjectInsert.DrawingObjectInsert.RelativeHorizontalPositionEnum,
    "DrawingObjectInsert.RelativeVerticalPositionEnum": importedDrawingObjectInsert.DrawingObjectInsert.RelativeVerticalPositionEnum,
    "DrawingObjectInsert.WrapTypeEnum": importedDrawingObjectInsert.DrawingObjectInsert.WrapTypeEnum,
    "DrawingObjectUpdate.RelativeHorizontalPositionEnum": importedDrawingObjectUpdate.DrawingObjectUpdate.RelativeHorizontalPositionEnum,
    "DrawingObjectUpdate.RelativeVerticalPositionEnum": importedDrawingObjectUpdate.DrawingObjectUpdate.RelativeVerticalPositionEnum,
    "DrawingObjectUpdate.WrapTypeEnum": importedDrawingObjectUpdate.DrawingObjectUpdate.WrapTypeEnum,
    "FieldOptions.FieldIndexFormatEnum": importedFieldOptions.FieldOptions.FieldIndexFormatEnum,
    "FieldOptions.FieldUpdateCultureSourceEnum": importedFieldOptions.FieldOptions.FieldUpdateCultureSourceEnum,
    "FileReference.SourceEnum": importedFileReference.FileReference.SourceEnum,
    "FixedPageSaveOptionsData.ColorModeEnum": importedFixedPageSaveOptionsData.FixedPageSaveOptionsData.ColorModeEnum,
    "FixedPageSaveOptionsData.NumeralFormatEnum": importedFixedPageSaveOptionsData.FixedPageSaveOptionsData.NumeralFormatEnum,
    "Font.StyleIdentifierEnum": importedFont.Font.StyleIdentifierEnum,
    "Font.TextEffectEnum": importedFont.Font.TextEffectEnum,
    "Font.UnderlineEnum": importedFont.Font.UnderlineEnum,
    "Footnote.FootnoteTypeEnum": importedFootnote.Footnote.FootnoteTypeEnum,
    "FootnoteBase.FootnoteTypeEnum": importedFootnoteBase.FootnoteBase.FootnoteTypeEnum,
    "FormFieldTextInput.TextInputTypeEnum": importedFormFieldTextInput.FormFieldTextInput.TextInputTypeEnum,
    "HeaderFooterLink.TypeEnum": importedHeaderFooterLink.HeaderFooterLink.TypeEnum,
    "HtmlFixedSaveOptionsData.FontFormatEnum": importedHtmlFixedSaveOptionsData.HtmlFixedSaveOptionsData.FontFormatEnum,
    "HtmlFixedSaveOptionsData.PageHorizontalAlignmentEnum": importedHtmlFixedSaveOptionsData.HtmlFixedSaveOptionsData.PageHorizontalAlignmentEnum,
    "HtmlSaveOptionsData.CssStyleSheetTypeEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.CssStyleSheetTypeEnum,
    "HtmlSaveOptionsData.DocumentSplitCriteriaEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.DocumentSplitCriteriaEnum,
    "HtmlSaveOptionsData.ExportHeadersFootersModeEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.ExportHeadersFootersModeEnum,
    "HtmlSaveOptionsData.ExportListLabelsEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.ExportListLabelsEnum,
    "HtmlSaveOptionsData.HtmlVersionEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.HtmlVersionEnum,
    "HtmlSaveOptionsData.MetafileFormatEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.MetafileFormatEnum,
    "HtmlSaveOptionsData.OfficeMathOutputModeEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.OfficeMathOutputModeEnum,
    "HtmlSaveOptionsData.TableWidthOutputModeEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.TableWidthOutputModeEnum,
    "ImageSaveOptionsData.ImageColorModeEnum": importedImageSaveOptionsData.ImageSaveOptionsData.ImageColorModeEnum,
    "ImageSaveOptionsData.PixelFormatEnum": importedImageSaveOptionsData.ImageSaveOptionsData.PixelFormatEnum,
    "JsonDataLoadOptions.SimpleValueParseModeEnum": importedJsonDataLoadOptions.JsonDataLoadOptions.SimpleValueParseModeEnum,
    "ListInsert.TemplateEnum": importedListInsert.ListInsert.TemplateEnum,
    "ListLevel.NumberStyleEnum": importedListLevel.ListLevel.NumberStyleEnum,
    "ListLevel.AlignmentEnum": importedListLevel.ListLevel.AlignmentEnum,
    "ListLevel.TrailingCharacterEnum": importedListLevel.ListLevel.TrailingCharacterEnum,
    "ListLevelUpdate.NumberStyleEnum": importedListLevelUpdate.ListLevelUpdate.NumberStyleEnum,
    "ListLevelUpdate.AlignmentEnum": importedListLevelUpdate.ListLevelUpdate.AlignmentEnum,
    "ListLevelUpdate.TrailingCharacterEnum": importedListLevelUpdate.ListLevelUpdate.TrailingCharacterEnum,
    "MarkdownSaveOptionsData.TableContentAlignmentEnum": importedMarkdownSaveOptionsData.MarkdownSaveOptionsData.TableContentAlignmentEnum,
    "MetafileRenderingOptionsData.EmfPlusDualRenderingModeEnum": importedMetafileRenderingOptionsData.MetafileRenderingOptionsData.EmfPlusDualRenderingModeEnum,
    "MetafileRenderingOptionsData.RenderingModeEnum": importedMetafileRenderingOptionsData.MetafileRenderingOptionsData.RenderingModeEnum,
    "OdtSaveOptionsData.MeasureUnitEnum": importedOdtSaveOptionsData.OdtSaveOptionsData.MeasureUnitEnum,
    "OfficeMathObject.DisplayTypeEnum": importedOfficeMathObject.OfficeMathObject.DisplayTypeEnum,
    "OfficeMathObject.JustificationEnum": importedOfficeMathObject.OfficeMathObject.JustificationEnum,
    "OfficeMathObject.MathObjectTypeEnum": importedOfficeMathObject.OfficeMathObject.MathObjectTypeEnum,
    "OoxmlSaveOptionsData.ComplianceEnum": importedOoxmlSaveOptionsData.OoxmlSaveOptionsData.ComplianceEnum,
    "OoxmlSaveOptionsData.CompressionLevelEnum": importedOoxmlSaveOptionsData.OoxmlSaveOptionsData.CompressionLevelEnum,
    "OptimizationOptions.MsWordVersionEnum": importedOptimizationOptions.OptimizationOptions.MsWordVersionEnum,
    "PageSetup.BorderAppliesToEnum": importedPageSetup.PageSetup.BorderAppliesToEnum,
    "PageSetup.BorderDistanceFromEnum": importedPageSetup.PageSetup.BorderDistanceFromEnum,
    "PageSetup.LineNumberRestartModeEnum": importedPageSetup.PageSetup.LineNumberRestartModeEnum,
    "PageSetup.OrientationEnum": importedPageSetup.PageSetup.OrientationEnum,
    "PageSetup.PageNumberStyleEnum": importedPageSetup.PageSetup.PageNumberStyleEnum,
    "PageSetup.PaperSizeEnum": importedPageSetup.PageSetup.PaperSizeEnum,
    "PageSetup.SectionStartEnum": importedPageSetup.PageSetup.SectionStartEnum,
    "PageSetup.VerticalAlignmentEnum": importedPageSetup.PageSetup.VerticalAlignmentEnum,
    "ParagraphFormatBase.AlignmentEnum": importedParagraphFormatBase.ParagraphFormatBase.AlignmentEnum,
    "ParagraphFormatBase.DropCapPositionEnum": importedParagraphFormatBase.ParagraphFormatBase.DropCapPositionEnum,
    "ParagraphFormatBase.LineSpacingRuleEnum": importedParagraphFormatBase.ParagraphFormatBase.LineSpacingRuleEnum,
    "ParagraphFormatBase.OutlineLevelEnum": importedParagraphFormatBase.ParagraphFormatBase.OutlineLevelEnum,
    "ParagraphFormatBase.StyleIdentifierEnum": importedParagraphFormatBase.ParagraphFormatBase.StyleIdentifierEnum,
    "PdfDigitalSignatureDetailsData.HashAlgorithmEnum": importedPdfDigitalSignatureDetailsData.PdfDigitalSignatureDetailsData.HashAlgorithmEnum,
    "PdfPermissions": importedPdfPermissions.PdfPermissions,
    "PdfSaveOptionsData.ComplianceEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.ComplianceEnum,
    "PdfSaveOptionsData.CustomPropertiesExportEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.CustomPropertiesExportEnum,
    "PdfSaveOptionsData.FontEmbeddingModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.FontEmbeddingModeEnum,
    "PdfSaveOptionsData.HeaderFooterBookmarksExportModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.HeaderFooterBookmarksExportModeEnum,
    "PdfSaveOptionsData.ImageColorSpaceExportModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.ImageColorSpaceExportModeEnum,
    "PdfSaveOptionsData.PageModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.PageModeEnum,
    "PdfSaveOptionsData.TextCompressionEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.TextCompressionEnum,
    "PdfSaveOptionsData.ZoomBehaviorEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.ZoomBehaviorEnum,
    "PreferredWidth.TypeEnum": importedPreferredWidth.PreferredWidth.TypeEnum,
    "ProtectionData.ProtectionTypeEnum": importedProtectionData.ProtectionData.ProtectionTypeEnum,
    "ProtectionRequestV2.ProtectionTypeEnum": importedProtectionRequestV2.ProtectionRequestV2.ProtectionTypeEnum,
    "ReplaceRange.TextTypeEnum": importedReplaceRange.ReplaceRange.TextTypeEnum,
    "ReportBuildOptions": importedReportBuildOptions.ReportBuildOptions,
    "ReportEngineSettings.DataSourceTypeEnum": importedReportEngineSettings.ReportEngineSettings.DataSourceTypeEnum,
    "SaveOptionsData.Dml3DEffectsRenderingModeEnum": importedSaveOptionsData.SaveOptionsData.Dml3DEffectsRenderingModeEnum,
    "SaveOptionsData.DmlEffectsRenderingModeEnum": importedSaveOptionsData.SaveOptionsData.DmlEffectsRenderingModeEnum,
    "SaveOptionsData.DmlRenderingModeEnum": importedSaveOptionsData.SaveOptionsData.DmlRenderingModeEnum,
    "SaveOptionsData.ImlRenderingModeEnum": importedSaveOptionsData.SaveOptionsData.ImlRenderingModeEnum,
    "Shading.TextureEnum": importedShading.Shading.TextureEnum,
    "StructuredDocumentTag.LevelEnum": importedStructuredDocumentTag.StructuredDocumentTag.LevelEnum,
    "StructuredDocumentTag.SdtTypeEnum": importedStructuredDocumentTag.StructuredDocumentTag.SdtTypeEnum,
    "StructuredDocumentTagBase.AppearanceEnum": importedStructuredDocumentTagBase.StructuredDocumentTagBase.AppearanceEnum,
    "StructuredDocumentTagBase.DateStorageFormatEnum": importedStructuredDocumentTagBase.StructuredDocumentTagBase.DateStorageFormatEnum,
    "StructuredDocumentTagBase.CalendarTypeEnum": importedStructuredDocumentTagBase.StructuredDocumentTagBase.CalendarTypeEnum,
    "StructuredDocumentTagInsert.LevelEnum": importedStructuredDocumentTagInsert.StructuredDocumentTagInsert.LevelEnum,
    "StructuredDocumentTagInsert.SdtTypeEnum": importedStructuredDocumentTagInsert.StructuredDocumentTagInsert.SdtTypeEnum,
    "Style.TypeEnum": importedStyle.Style.TypeEnum,
    "Style.StyleIdentifierEnum": importedStyle.Style.StyleIdentifierEnum,
    "StyleInsert.StyleTypeEnum": importedStyleInsert.StyleInsert.StyleTypeEnum,
    "SvgSaveOptionsData.TextOutputModeEnum": importedSvgSaveOptionsData.SvgSaveOptionsData.TextOutputModeEnum,
    "TableCellFormat.HorizontalMergeEnum": importedTableCellFormat.TableCellFormat.HorizontalMergeEnum,
    "TableCellFormat.OrientationEnum": importedTableCellFormat.TableCellFormat.OrientationEnum,
    "TableCellFormat.VerticalAlignmentEnum": importedTableCellFormat.TableCellFormat.VerticalAlignmentEnum,
    "TableCellFormat.VerticalMergeEnum": importedTableCellFormat.TableCellFormat.VerticalMergeEnum,
    "TableProperties.AlignmentEnum": importedTableProperties.TableProperties.AlignmentEnum,
    "TableProperties.StyleIdentifierEnum": importedTableProperties.TableProperties.StyleIdentifierEnum,
    "TableProperties.StyleOptionsEnum": importedTableProperties.TableProperties.StyleOptionsEnum,
    "TableProperties.TextWrappingEnum": importedTableProperties.TableProperties.TextWrappingEnum,
    "TableRowFormat.HeightRuleEnum": importedTableRowFormat.TableRowFormat.HeightRuleEnum,
    "TabStopBase.AlignmentEnum": importedTabStopBase.TabStopBase.AlignmentEnum,
    "TabStopBase.LeaderEnum": importedTabStopBase.TabStopBase.LeaderEnum,
    "TiffSaveOptionsData.TiffBinarizationMethodEnum": importedTiffSaveOptionsData.TiffSaveOptionsData.TiffBinarizationMethodEnum,
    "TiffSaveOptionsData.TiffCompressionEnum": importedTiffSaveOptionsData.TiffSaveOptionsData.TiffCompressionEnum,
    "TxtSaveOptionsBaseData.ExportHeadersFootersModeEnum": importedTxtSaveOptionsBaseData.TxtSaveOptionsBaseData.ExportHeadersFootersModeEnum,
    "WatermarkDataText.LayoutEnum": importedWatermarkDataText.WatermarkDataText.LayoutEnum,
};
exports.enumsMap = enumsMap;
const typeMap = {
    FileReference: importedFileReference.FileReference,
    ApiError: importedApiError.ApiError,
    AvailableFontsResponse: importedAvailableFontsResponse.AvailableFontsResponse,
    Azw3SaveOptionsData: importedAzw3SaveOptionsData.Azw3SaveOptionsData,
    BmpSaveOptionsData: importedBmpSaveOptionsData.BmpSaveOptionsData,
    Bookmark: importedBookmark.Bookmark,
    BookmarkData: importedBookmarkData.BookmarkData,
    BookmarkInsert: importedBookmarkInsert.BookmarkInsert,
    BookmarkResponse: importedBookmarkResponse.BookmarkResponse,
    Bookmarks: importedBookmarks.Bookmarks,
    BookmarksOutlineLevelData: importedBookmarksOutlineLevelData.BookmarksOutlineLevelData,
    BookmarksResponse: importedBookmarksResponse.BookmarksResponse,
    Border: importedBorder.Border,
    BorderResponse: importedBorderResponse.BorderResponse,
    BordersCollection: importedBordersCollection.BordersCollection,
    BordersResponse: importedBordersResponse.BordersResponse,
    ClassificationResponse: importedClassificationResponse.ClassificationResponse,
    ClassificationResult: importedClassificationResult.ClassificationResult,
    Comment: importedComment.Comment,
    CommentInsert: importedCommentInsert.CommentInsert,
    CommentLink: importedCommentLink.CommentLink,
    CommentResponse: importedCommentResponse.CommentResponse,
    CommentsCollection: importedCommentsCollection.CommentsCollection,
    CommentsResponse: importedCommentsResponse.CommentsResponse,
    CommentUpdate: importedCommentUpdate.CommentUpdate,
    CompareData: importedCompareData.CompareData,
    CompareOptions: importedCompareOptions.CompareOptions,
    CompressOptions: importedCompressOptions.CompressOptions,
    CompressResponse: importedCompressResponse.CompressResponse,
    CsvDataLoadOptions: importedCsvDataLoadOptions.CsvDataLoadOptions,
    CustomXmlPart: importedCustomXmlPart.CustomXmlPart,
    CustomXmlPartInsert: importedCustomXmlPartInsert.CustomXmlPartInsert,
    CustomXmlPartLink: importedCustomXmlPartLink.CustomXmlPartLink,
    CustomXmlPartResponse: importedCustomXmlPartResponse.CustomXmlPartResponse,
    CustomXmlPartsCollection: importedCustomXmlPartsCollection.CustomXmlPartsCollection,
    CustomXmlPartsResponse: importedCustomXmlPartsResponse.CustomXmlPartsResponse,
    CustomXmlPartUpdate: importedCustomXmlPartUpdate.CustomXmlPartUpdate,
    DigitalSignatureDetails: importedDigitalSignatureDetails.DigitalSignatureDetails,
    DocmSaveOptionsData: importedDocmSaveOptionsData.DocmSaveOptionsData,
    DocSaveOptionsData: importedDocSaveOptionsData.DocSaveOptionsData,
    Document: importedDocument.Document,
    DocumentEntry: importedDocumentEntry.DocumentEntry,
    DocumentEntryList: importedDocumentEntryList.DocumentEntryList,
    DocumentPosition: importedDocumentPosition.DocumentPosition,
    DocumentProperties: importedDocumentProperties.DocumentProperties,
    DocumentPropertiesResponse: importedDocumentPropertiesResponse.DocumentPropertiesResponse,
    DocumentProperty: importedDocumentProperty.DocumentProperty,
    DocumentPropertyCreateOrUpdate: importedDocumentPropertyCreateOrUpdate.DocumentPropertyCreateOrUpdate,
    DocumentPropertyResponse: importedDocumentPropertyResponse.DocumentPropertyResponse,
    DocumentResponse: importedDocumentResponse.DocumentResponse,
    DocumentStatData: importedDocumentStatData.DocumentStatData,
    DocxSaveOptionsData: importedDocxSaveOptionsData.DocxSaveOptionsData,
    DotmSaveOptionsData: importedDotmSaveOptionsData.DotmSaveOptionsData,
    DotSaveOptionsData: importedDotSaveOptionsData.DotSaveOptionsData,
    DotxSaveOptionsData: importedDotxSaveOptionsData.DotxSaveOptionsData,
    DownsampleOptionsData: importedDownsampleOptionsData.DownsampleOptionsData,
    DrawingObject: importedDrawingObject.DrawingObject,
    DrawingObjectCollection: importedDrawingObjectCollection.DrawingObjectCollection,
    DrawingObjectInsert: importedDrawingObjectInsert.DrawingObjectInsert,
    DrawingObjectLink: importedDrawingObjectLink.DrawingObjectLink,
    DrawingObjectResponse: importedDrawingObjectResponse.DrawingObjectResponse,
    DrawingObjectsResponse: importedDrawingObjectsResponse.DrawingObjectsResponse,
    DrawingObjectUpdate: importedDrawingObjectUpdate.DrawingObjectUpdate,
    EmfSaveOptionsData: importedEmfSaveOptionsData.EmfSaveOptionsData,
    EpsSaveOptionsData: importedEpsSaveOptionsData.EpsSaveOptionsData,
    EpubSaveOptionsData: importedEpubSaveOptionsData.EpubSaveOptionsData,
    Error: importedError.Error,
    ErrorDetails: importedErrorDetails.ErrorDetails,
    Field: importedField.Field,
    FieldCollection: importedFieldCollection.FieldCollection,
    FieldInsert: importedFieldInsert.FieldInsert,
    FieldLink: importedFieldLink.FieldLink,
    FieldNames: importedFieldNames.FieldNames,
    FieldNamesResponse: importedFieldNamesResponse.FieldNamesResponse,
    FieldOptions: importedFieldOptions.FieldOptions,
    FieldResponse: importedFieldResponse.FieldResponse,
    FieldsResponse: importedFieldsResponse.FieldsResponse,
    FieldUpdate: importedFieldUpdate.FieldUpdate,
    FileLink: importedFileLink.FileLink,
    FilesList: importedFilesList.FilesList,
    FilesUploadResult: importedFilesUploadResult.FilesUploadResult,
    FlatOpcMacroSaveOptionsData: importedFlatOpcMacroSaveOptionsData.FlatOpcMacroSaveOptionsData,
    FlatOpcSaveOptionsData: importedFlatOpcSaveOptionsData.FlatOpcSaveOptionsData,
    FlatOpcTemplateMacroSaveOptionsData: importedFlatOpcTemplateMacroSaveOptionsData.FlatOpcTemplateMacroSaveOptionsData,
    FlatOpcTemplateSaveOptionsData: importedFlatOpcTemplateSaveOptionsData.FlatOpcTemplateSaveOptionsData,
    Font: importedFont.Font,
    FontInfo: importedFontInfo.FontInfo,
    FontResponse: importedFontResponse.FontResponse,
    Footnote: importedFootnote.Footnote,
    FootnoteCollection: importedFootnoteCollection.FootnoteCollection,
    FootnoteInsert: importedFootnoteInsert.FootnoteInsert,
    FootnoteLink: importedFootnoteLink.FootnoteLink,
    FootnoteResponse: importedFootnoteResponse.FootnoteResponse,
    FootnotesResponse: importedFootnotesResponse.FootnotesResponse,
    FootnotesStatData: importedFootnotesStatData.FootnotesStatData,
    FootnoteUpdate: importedFootnoteUpdate.FootnoteUpdate,
    FormFieldCheckbox: importedFormFieldCheckbox.FormFieldCheckbox,
    FormFieldCollection: importedFormFieldCollection.FormFieldCollection,
    FormFieldDropDown: importedFormFieldDropDown.FormFieldDropDown,
    FormFieldResponse: importedFormFieldResponse.FormFieldResponse,
    FormFieldsResponse: importedFormFieldsResponse.FormFieldsResponse,
    FormFieldTextInput: importedFormFieldTextInput.FormFieldTextInput,
    GifSaveOptionsData: importedGifSaveOptionsData.GifSaveOptionsData,
    HeaderFooter: importedHeaderFooter.HeaderFooter,
    HeaderFooterLink: importedHeaderFooterLink.HeaderFooterLink,
    HeaderFooterLinkCollection: importedHeaderFooterLinkCollection.HeaderFooterLinkCollection,
    HeaderFooterResponse: importedHeaderFooterResponse.HeaderFooterResponse,
    HeaderFootersResponse: importedHeaderFootersResponse.HeaderFootersResponse,
    HtmlFixedSaveOptionsData: importedHtmlFixedSaveOptionsData.HtmlFixedSaveOptionsData,
    HtmlSaveOptionsData: importedHtmlSaveOptionsData.HtmlSaveOptionsData,
    Hyperlink: importedHyperlink.Hyperlink,
    HyperlinkResponse: importedHyperlinkResponse.HyperlinkResponse,
    Hyperlinks: importedHyperlinks.Hyperlinks,
    HyperlinksResponse: importedHyperlinksResponse.HyperlinksResponse,
    ImageEntry: importedImageEntry.ImageEntry,
    ImageEntryList: importedImageEntryList.ImageEntryList,
    InfoAdditionalItem: importedInfoAdditionalItem.InfoAdditionalItem,
    InfoResponse: importedInfoResponse.InfoResponse,
    JpegSaveOptionsData: importedJpegSaveOptionsData.JpegSaveOptionsData,
    JsonDataLoadOptions: importedJsonDataLoadOptions.JsonDataLoadOptions,
    Link: importedLink.Link,
    LinkElement: importedLinkElement.LinkElement,
    ListFormat: importedListFormat.ListFormat,
    ListFormatUpdate: importedListFormatUpdate.ListFormatUpdate,
    ListInfo: importedListInfo.ListInfo,
    ListInsert: importedListInsert.ListInsert,
    ListLevel: importedListLevel.ListLevel,
    ListLevels: importedListLevels.ListLevels,
    ListLevelUpdate: importedListLevelUpdate.ListLevelUpdate,
    ListResponse: importedListResponse.ListResponse,
    Lists: importedLists.Lists,
    ListsResponse: importedListsResponse.ListsResponse,
    ListUpdate: importedListUpdate.ListUpdate,
    LoadWebDocumentData: importedLoadWebDocumentData.LoadWebDocumentData,
    MarkdownSaveOptionsData: importedMarkdownSaveOptionsData.MarkdownSaveOptionsData,
    MetafileRenderingOptionsData: importedMetafileRenderingOptionsData.MetafileRenderingOptionsData,
    MhtmlSaveOptionsData: importedMhtmlSaveOptionsData.MhtmlSaveOptionsData,
    ModificationOperationResult: importedModificationOperationResult.ModificationOperationResult,
    NodeLink: importedNodeLink.NodeLink,
    OdtSaveOptionsData: importedOdtSaveOptionsData.OdtSaveOptionsData,
    OfficeMathLink: importedOfficeMathLink.OfficeMathLink,
    OfficeMathObject: importedOfficeMathObject.OfficeMathObject,
    OfficeMathObjectResponse: importedOfficeMathObjectResponse.OfficeMathObjectResponse,
    OfficeMathObjectsCollection: importedOfficeMathObjectsCollection.OfficeMathObjectsCollection,
    OfficeMathObjectsResponse: importedOfficeMathObjectsResponse.OfficeMathObjectsResponse,
    OpenXpsSaveOptionsData: importedOpenXpsSaveOptionsData.OpenXpsSaveOptionsData,
    OptimizationOptions: importedOptimizationOptions.OptimizationOptions,
    OttSaveOptionsData: importedOttSaveOptionsData.OttSaveOptionsData,
    OutlineOptionsData: importedOutlineOptionsData.OutlineOptionsData,
    PageNumber: importedPageNumber.PageNumber,
    PageSetup: importedPageSetup.PageSetup,
    PageStatData: importedPageStatData.PageStatData,
    Paragraph: importedParagraph.Paragraph,
    ParagraphFormat: importedParagraphFormat.ParagraphFormat,
    ParagraphFormatResponse: importedParagraphFormatResponse.ParagraphFormatResponse,
    ParagraphFormatUpdate: importedParagraphFormatUpdate.ParagraphFormatUpdate,
    ParagraphInsert: importedParagraphInsert.ParagraphInsert,
    ParagraphLink: importedParagraphLink.ParagraphLink,
    ParagraphLinkCollection: importedParagraphLinkCollection.ParagraphLinkCollection,
    ParagraphLinkCollectionResponse: importedParagraphLinkCollectionResponse.ParagraphLinkCollectionResponse,
    ParagraphListFormatResponse: importedParagraphListFormatResponse.ParagraphListFormatResponse,
    ParagraphResponse: importedParagraphResponse.ParagraphResponse,
    PclSaveOptionsData: importedPclSaveOptionsData.PclSaveOptionsData,
    PdfDigitalSignatureDetailsData: importedPdfDigitalSignatureDetailsData.PdfDigitalSignatureDetailsData,
    PdfEncryptionDetailsData: importedPdfEncryptionDetailsData.PdfEncryptionDetailsData,
    PdfPermissions: importedPdfPermissions.PdfPermissions,
    PdfSaveOptionsData: importedPdfSaveOptionsData.PdfSaveOptionsData,
    PngSaveOptionsData: importedPngSaveOptionsData.PngSaveOptionsData,
    PositionAfterNode: importedPositionAfterNode.PositionAfterNode,
    PositionBeforeNode: importedPositionBeforeNode.PositionBeforeNode,
    PositionInsideNode: importedPositionInsideNode.PositionInsideNode,
    PreferredWidth: importedPreferredWidth.PreferredWidth,
    ProtectionData: importedProtectionData.ProtectionData,
    ProtectionDataResponse: importedProtectionDataResponse.ProtectionDataResponse,
    ProtectionRequest: importedProtectionRequest.ProtectionRequest,
    ProtectionRequestV2: importedProtectionRequestV2.ProtectionRequestV2,
    PsSaveOptionsData: importedPsSaveOptionsData.PsSaveOptionsData,
    PublicKeyResponse: importedPublicKeyResponse.PublicKeyResponse,
    RangeDocument: importedRangeDocument.RangeDocument,
    RangeTextResponse: importedRangeTextResponse.RangeTextResponse,
    ReplaceRange: importedReplaceRange.ReplaceRange,
    ReplaceTextParameters: importedReplaceTextParameters.ReplaceTextParameters,
    ReplaceTextResponse: importedReplaceTextResponse.ReplaceTextResponse,
    ReportBuildOptions: importedReportBuildOptions.ReportBuildOptions,
    ReportEngineSettings: importedReportEngineSettings.ReportEngineSettings,
    Revision: importedRevision.Revision,
    RevisionCollection: importedRevisionCollection.RevisionCollection,
    RevisionsModificationResponse: importedRevisionsModificationResponse.RevisionsModificationResponse,
    RevisionsResponse: importedRevisionsResponse.RevisionsResponse,
    RtfSaveOptionsData: importedRtfSaveOptionsData.RtfSaveOptionsData,
    Run: importedRun.Run,
    RunInsert: importedRunInsert.RunInsert,
    RunLink: importedRunLink.RunLink,
    RunResponse: importedRunResponse.RunResponse,
    Runs: importedRuns.Runs,
    RunsResponse: importedRunsResponse.RunsResponse,
    RunUpdate: importedRunUpdate.RunUpdate,
    SaveResponse: importedSaveResponse.SaveResponse,
    SaveResult: importedSaveResult.SaveResult,
    SearchResponse: importedSearchResponse.SearchResponse,
    SearchResult: importedSearchResult.SearchResult,
    SearchResultsCollection: importedSearchResultsCollection.SearchResultsCollection,
    Section: importedSection.Section,
    SectionLink: importedSectionLink.SectionLink,
    SectionLinkCollection: importedSectionLinkCollection.SectionLinkCollection,
    SectionLinkCollectionResponse: importedSectionLinkCollectionResponse.SectionLinkCollectionResponse,
    SectionPageSetupResponse: importedSectionPageSetupResponse.SectionPageSetupResponse,
    SectionResponse: importedSectionResponse.SectionResponse,
    Shading: importedShading.Shading,
    Signature: importedSignature.Signature,
    SignatureCollectionResponse: importedSignatureCollectionResponse.SignatureCollectionResponse,
    SignOptions: importedSignOptions.SignOptions,
    SplitDocumentResponse: importedSplitDocumentResponse.SplitDocumentResponse,
    SplitDocumentResult: importedSplitDocumentResult.SplitDocumentResult,
    StatDataResponse: importedStatDataResponse.StatDataResponse,
    StorageFile: importedStorageFile.StorageFile,
    StoryChildNodes: importedStoryChildNodes.StoryChildNodes,
    StructuredDocumentTag: importedStructuredDocumentTag.StructuredDocumentTag,
    StructuredDocumentTagCollection: importedStructuredDocumentTagCollection.StructuredDocumentTagCollection,
    StructuredDocumentTagInsert: importedStructuredDocumentTagInsert.StructuredDocumentTagInsert,
    StructuredDocumentTagListItem: importedStructuredDocumentTagListItem.StructuredDocumentTagListItem,
    StructuredDocumentTagResponse: importedStructuredDocumentTagResponse.StructuredDocumentTagResponse,
    StructuredDocumentTagsResponse: importedStructuredDocumentTagsResponse.StructuredDocumentTagsResponse,
    StructuredDocumentTagUpdate: importedStructuredDocumentTagUpdate.StructuredDocumentTagUpdate,
    Style: importedStyle.Style,
    StyleApply: importedStyleApply.StyleApply,
    StyleCopy: importedStyleCopy.StyleCopy,
    StyleInsert: importedStyleInsert.StyleInsert,
    StyleResponse: importedStyleResponse.StyleResponse,
    StylesResponse: importedStylesResponse.StylesResponse,
    StyleUpdate: importedStyleUpdate.StyleUpdate,
    SvgSaveOptionsData: importedSvgSaveOptionsData.SvgSaveOptionsData,
    Table: importedTable.Table,
    TableCell: importedTableCell.TableCell,
    TableCellFormat: importedTableCellFormat.TableCellFormat,
    TableCellFormatResponse: importedTableCellFormatResponse.TableCellFormatResponse,
    TableCellInsert: importedTableCellInsert.TableCellInsert,
    TableCellResponse: importedTableCellResponse.TableCellResponse,
    TableInsert: importedTableInsert.TableInsert,
    TableLink: importedTableLink.TableLink,
    TableLinkCollection: importedTableLinkCollection.TableLinkCollection,
    TableLinkCollectionResponse: importedTableLinkCollectionResponse.TableLinkCollectionResponse,
    TableProperties: importedTableProperties.TableProperties,
    TablePropertiesResponse: importedTablePropertiesResponse.TablePropertiesResponse,
    TableResponse: importedTableResponse.TableResponse,
    TableRow: importedTableRow.TableRow,
    TableRowFormat: importedTableRowFormat.TableRowFormat,
    TableRowFormatResponse: importedTableRowFormatResponse.TableRowFormatResponse,
    TableRowInsert: importedTableRowInsert.TableRowInsert,
    TableRowResponse: importedTableRowResponse.TableRowResponse,
    TabStop: importedTabStop.TabStop,
    TabStopInsert: importedTabStopInsert.TabStopInsert,
    TabStopsResponse: importedTabStopsResponse.TabStopsResponse,
    TextSaveOptionsData: importedTextSaveOptionsData.TextSaveOptionsData,
    TiffSaveOptionsData: importedTiffSaveOptionsData.TiffSaveOptionsData,
    TimeZoneInfoData: importedTimeZoneInfoData.TimeZoneInfoData,
    TranslateNodeIdResponse: importedTranslateNodeIdResponse.TranslateNodeIdResponse,
    UserInformation: importedUserInformation.UserInformation,
    WatermarkDataImage: importedWatermarkDataImage.WatermarkDataImage,
    WatermarkDataText: importedWatermarkDataText.WatermarkDataText,
    WatermarkText: importedWatermarkText.WatermarkText,
    WordMLSaveOptionsData: importedWordMLSaveOptionsData.WordMLSaveOptionsData,
    WordsApiErrorResponse: importedWordsApiErrorResponse.WordsApiErrorResponse,
    WordsApiLink: importedWordsApiLink.WordsApiLink,
    WordsResponse: importedWordsResponse.WordsResponse,
    XamlFixedSaveOptionsData: importedXamlFixedSaveOptionsData.XamlFixedSaveOptionsData,
    XamlFlowPackSaveOptionsData: importedXamlFlowPackSaveOptionsData.XamlFlowPackSaveOptionsData,
    XamlFlowSaveOptionsData: importedXamlFlowSaveOptionsData.XamlFlowSaveOptionsData,
    XmlColor: importedXmlColor.XmlColor,
    XmlDataLoadOptions: importedXmlDataLoadOptions.XmlDataLoadOptions,
    XpsSaveOptionsData: importedXpsSaveOptionsData.XpsSaveOptionsData
};
exports.typeMap = typeMap;
/**
 * Create unique request id
 */
function createUid() {
    return (0, uuid_1.v4)();
}
exports.createUid = createUid;
/**
 * Request model for AcceptAllRevisions operation.
 * Accepts all revisions in the document.
 */
class AcceptAllRevisionsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/revisions/acceptAll"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling acceptAllRevisions.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling acceptAllRevisions.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RevisionsModificationResponse");
    }
}
exports.AcceptAllRevisionsRequest = AcceptAllRevisionsRequest;
/**
 * Request model for AcceptAllRevisionsOnline operation.
 * Accepts all revisions in the document.
 */
class AcceptAllRevisionsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/revisions/acceptAll"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling acceptAllRevisionsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling acceptAllRevisionsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new AcceptAllRevisionsOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "RevisionsModificationResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.AcceptAllRevisionsOnlineRequest = AcceptAllRevisionsOnlineRequest;
/**
 * Request model for AppendDocument operation.
 * Appends documents to the original document.
 */
class AppendDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/appendDocument"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling appendDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling appendDocument.');
            }
            // verify required parameter 'this.documentList' is not undefined
            if (this.documentList === undefined) {
                throw new Error('Required parameter "this.documentList" was undefined when calling appendDocument.');
            }
            // verify required parameter 'this.documentList' is not null
            if (this.documentList === null) {
                throw new Error('Required parameter "this.documentList" was null when calling appendDocument.');
            }
            (_a = this.documentList) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.documentList !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.documentList, this.documentList.constructor.name === "Object" ? "importedBaseEntryList.BaseEntryList" : this.documentList.constructor.name);
                formParams.push(['DocumentList', JSON.stringify(_obj), 'application/json']);
                this.documentList.collectFilesContent(filesContent);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.AppendDocumentRequest = AppendDocumentRequest;
/**
 * Request model for AppendDocumentOnline operation.
 * Appends documents to the original document.
 */
class AppendDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/appendDocument"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling appendDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling appendDocumentOnline.');
            }
            // verify required parameter 'this.documentList' is not undefined
            if (this.documentList === undefined) {
                throw new Error('Required parameter "this.documentList" was undefined when calling appendDocumentOnline.');
            }
            // verify required parameter 'this.documentList' is not null
            if (this.documentList === null) {
                throw new Error('Required parameter "this.documentList" was null when calling appendDocumentOnline.');
            }
            (_a = this.documentList) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.documentList !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.documentList, this.documentList.constructor.name === "Object" ? "importedBaseEntryList.BaseEntryList" : this.documentList.constructor.name);
                formParams.push(['DocumentList', JSON.stringify(_obj), 'application/json']);
                this.documentList.collectFilesContent(filesContent);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new AppendDocumentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.AppendDocumentOnlineRequest = AppendDocumentOnlineRequest;
/**
 * Request model for ApplyStyleToDocumentElement operation.
 * Applies a style to the document node.
 */
class ApplyStyleToDocumentElementRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{styledNodePath}/style"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "styledNodePath" + "}", (this.styledNodePath !== null && this.styledNodePath !== undefined) ? "/" + String(this.styledNodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling applyStyleToDocumentElement.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling applyStyleToDocumentElement.');
            }
            // verify required parameter 'this.styledNodePath' is not undefined
            if (this.styledNodePath === undefined) {
                throw new Error('Required parameter "this.styledNodePath" was undefined when calling applyStyleToDocumentElement.');
            }
            // verify required parameter 'this.styledNodePath' is not null
            if (this.styledNodePath === null) {
                throw new Error('Required parameter "this.styledNodePath" was null when calling applyStyleToDocumentElement.');
            }
            // verify required parameter 'this.styleApply' is not undefined
            if (this.styleApply === undefined) {
                throw new Error('Required parameter "this.styleApply" was undefined when calling applyStyleToDocumentElement.');
            }
            // verify required parameter 'this.styleApply' is not null
            if (this.styleApply === null) {
                throw new Error('Required parameter "this.styleApply" was null when calling applyStyleToDocumentElement.');
            }
            (_a = this.styleApply) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.styleApply !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.styleApply, this.styleApply.constructor.name === "Object" ? "importedStyleApply.StyleApply" : this.styleApply.constructor.name);
                formParams.push(['StyleApply', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "WordsResponse");
    }
}
exports.ApplyStyleToDocumentElementRequest = ApplyStyleToDocumentElementRequest;
/**
 * Request model for ApplyStyleToDocumentElementOnline operation.
 * Applies a style to the document node.
 */
class ApplyStyleToDocumentElementOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{styledNodePath}/style"
                .replace("/{" + "styledNodePath" + "}", (this.styledNodePath !== null && this.styledNodePath !== undefined) ? "/" + String(this.styledNodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling applyStyleToDocumentElementOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling applyStyleToDocumentElementOnline.');
            }
            // verify required parameter 'this.styledNodePath' is not undefined
            if (this.styledNodePath === undefined) {
                throw new Error('Required parameter "this.styledNodePath" was undefined when calling applyStyleToDocumentElementOnline.');
            }
            // verify required parameter 'this.styledNodePath' is not null
            if (this.styledNodePath === null) {
                throw new Error('Required parameter "this.styledNodePath" was null when calling applyStyleToDocumentElementOnline.');
            }
            // verify required parameter 'this.styleApply' is not undefined
            if (this.styleApply === undefined) {
                throw new Error('Required parameter "this.styleApply" was undefined when calling applyStyleToDocumentElementOnline.');
            }
            // verify required parameter 'this.styleApply' is not null
            if (this.styleApply === null) {
                throw new Error('Required parameter "this.styleApply" was null when calling applyStyleToDocumentElementOnline.');
            }
            (_a = this.styleApply) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.styleApply !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.styleApply, this.styleApply.constructor.name === "Object" ? "importedStyleApply.StyleApply" : this.styleApply.constructor.name);
                formParams.push(['StyleApply', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new ApplyStyleToDocumentElementOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "WordsResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.ApplyStyleToDocumentElementOnlineRequest = ApplyStyleToDocumentElementOnlineRequest;
/**
 * Request model for BuildReport operation.
 * Executes the report generation process using the specified document template and the external data source in XML, JSON or CSV format.
 */
class BuildReportRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/buildReport"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling buildReport.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling buildReport.');
            }
            // verify required parameter 'this.data' is not undefined
            if (this.data === undefined) {
                throw new Error('Required parameter "this.data" was undefined when calling buildReport.');
            }
            // verify required parameter 'this.data' is not null
            if (this.data === null) {
                throw new Error('Required parameter "this.data" was null when calling buildReport.');
            }
            // verify required parameter 'this.reportEngineSettings' is not undefined
            if (this.reportEngineSettings === undefined) {
                throw new Error('Required parameter "this.reportEngineSettings" was undefined when calling buildReport.');
            }
            // verify required parameter 'this.reportEngineSettings' is not null
            if (this.reportEngineSettings === null) {
                throw new Error('Required parameter "this.reportEngineSettings" was null when calling buildReport.');
            }
            (_a = this.reportEngineSettings) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.data !== undefined) {
                formParams.push(['Data', this.data, 'text/plain']);
            }
            if (this.reportEngineSettings !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.reportEngineSettings, this.reportEngineSettings.constructor.name === "Object" ? "importedReportEngineSettings.ReportEngineSettings" : this.reportEngineSettings.constructor.name);
                formParams.push(['ReportEngineSettings', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.BuildReportRequest = BuildReportRequest;
/**
 * Request model for BuildReportOnline operation.
 * Executes the report generation process online using the specified document template and the external data source in XML, JSON or CSV format.
 */
class BuildReportOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/buildReport"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.template' is not undefined
            if (this.template === undefined) {
                throw new Error('Required parameter "this.template" was undefined when calling buildReportOnline.');
            }
            // verify required parameter 'this.template' is not null
            if (this.template === null) {
                throw new Error('Required parameter "this.template" was null when calling buildReportOnline.');
            }
            // verify required parameter 'this.data' is not undefined
            if (this.data === undefined) {
                throw new Error('Required parameter "this.data" was undefined when calling buildReportOnline.');
            }
            // verify required parameter 'this.data' is not null
            if (this.data === null) {
                throw new Error('Required parameter "this.data" was null when calling buildReportOnline.');
            }
            // verify required parameter 'this.reportEngineSettings' is not undefined
            if (this.reportEngineSettings === undefined) {
                throw new Error('Required parameter "this.reportEngineSettings" was undefined when calling buildReportOnline.');
            }
            // verify required parameter 'this.reportEngineSettings' is not null
            if (this.reportEngineSettings === null) {
                throw new Error('Required parameter "this.reportEngineSettings" was null when calling buildReportOnline.');
            }
            (_a = this.reportEngineSettings) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "documentFileName", this.documentFileName, _encryptor);
            if (this.template !== undefined) {
                formParams.push(['Template', this.template, 'application/octet-stream']);
            }
            if (this.data !== undefined) {
                formParams.push(['Data', this.data, 'text/plain']);
            }
            if (this.reportEngineSettings !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.reportEngineSettings, this.reportEngineSettings.constructor.name === "Object" ? "importedReportEngineSettings.ReportEngineSettings" : this.reportEngineSettings.constructor.name);
                formParams.push(['ReportEngineSettings', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.BuildReportOnlineRequest = BuildReportOnlineRequest;
/**
 * Request model for Classify operation.
 * Runs a multi-class text classification for the specified raw text.
 */
class ClassifyRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/classify"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.text' is not undefined
            if (this.text === undefined) {
                throw new Error('Required parameter "this.text" was undefined when calling classify.');
            }
            // verify required parameter 'this.text' is not null
            if (this.text === null) {
                throw new Error('Required parameter "this.text" was null when calling classify.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bestClassesCount", this.bestClassesCount, _encryptor);
            if (this.text !== undefined) {
                formParams.push(['Text', this.text, 'text/plain']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ClassificationResponse");
    }
}
exports.ClassifyRequest = ClassifyRequest;
/**
 * Request model for ClassifyDocument operation.
 * Runs a multi-class text classification for the document.
 */
class ClassifyDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/classify"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling classifyDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling classifyDocument.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bestClassesCount", this.bestClassesCount, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "taxonomy", this.taxonomy, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ClassificationResponse");
    }
}
exports.ClassifyDocumentRequest = ClassifyDocumentRequest;
/**
 * Request model for ClassifyDocumentOnline operation.
 * Runs a multi-class text classification for the document.
 */
class ClassifyDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/classify"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling classifyDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling classifyDocumentOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "bestClassesCount", this.bestClassesCount, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "taxonomy", this.taxonomy, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ClassificationResponse");
    }
}
exports.ClassifyDocumentOnlineRequest = ClassifyDocumentOnlineRequest;
/**
 * Request model for CompareDocument operation.
 * Compares two documents.
 */
class CompareDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/compareDocument"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling compareDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling compareDocument.');
            }
            // verify required parameter 'this.compareData' is not undefined
            if (this.compareData === undefined) {
                throw new Error('Required parameter "this.compareData" was undefined when calling compareDocument.');
            }
            // verify required parameter 'this.compareData' is not null
            if (this.compareData === null) {
                throw new Error('Required parameter "this.compareData" was null when calling compareDocument.');
            }
            (_a = this.compareData) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.compareData !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.compareData, this.compareData.constructor.name === "Object" ? "importedCompareData.CompareData" : this.compareData.constructor.name);
                formParams.push(['CompareData', JSON.stringify(_obj), 'application/json']);
                this.compareData.collectFilesContent(filesContent);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.CompareDocumentRequest = CompareDocumentRequest;
/**
 * Request model for CompareDocumentOnline operation.
 * Compares two documents.
 */
class CompareDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/compareDocument"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling compareDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling compareDocumentOnline.');
            }
            // verify required parameter 'this.compareData' is not undefined
            if (this.compareData === undefined) {
                throw new Error('Required parameter "this.compareData" was undefined when calling compareDocumentOnline.');
            }
            // verify required parameter 'this.compareData' is not null
            if (this.compareData === null) {
                throw new Error('Required parameter "this.compareData" was null when calling compareDocumentOnline.');
            }
            (_a = this.compareData) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.compareData !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.compareData, this.compareData.constructor.name === "Object" ? "importedCompareData.CompareData" : this.compareData.constructor.name);
                formParams.push(['CompareData', JSON.stringify(_obj), 'application/json']);
                this.compareData.collectFilesContent(filesContent);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new CompareDocumentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.CompareDocumentOnlineRequest = CompareDocumentOnlineRequest;
/**
 * Request model for CompressDocument operation.
 * Compress and resize images inside the document.
 * The default settings allows to reduce the size of the document without any visible degradation of images quality.
 */
class CompressDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/compress"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling compressDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling compressDocument.');
            }
            // verify required parameter 'this.compressOptions' is not undefined
            if (this.compressOptions === undefined) {
                throw new Error('Required parameter "this.compressOptions" was undefined when calling compressDocument.');
            }
            // verify required parameter 'this.compressOptions' is not null
            if (this.compressOptions === null) {
                throw new Error('Required parameter "this.compressOptions" was null when calling compressDocument.');
            }
            (_a = this.compressOptions) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.compressOptions !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.compressOptions, this.compressOptions.constructor.name === "Object" ? "importedCompressOptions.CompressOptions" : this.compressOptions.constructor.name);
                formParams.push(['CompressOptions', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CompressResponse");
    }
}
exports.CompressDocumentRequest = CompressDocumentRequest;
/**
 * Request model for CompressDocumentOnline operation.
 * Compress and resize images inside the document.
 * The default settings allows to reduce the size of the document without any visible degradation of images quality.
 */
class CompressDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/compress"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling compressDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling compressDocumentOnline.');
            }
            // verify required parameter 'this.compressOptions' is not undefined
            if (this.compressOptions === undefined) {
                throw new Error('Required parameter "this.compressOptions" was undefined when calling compressDocumentOnline.');
            }
            // verify required parameter 'this.compressOptions' is not null
            if (this.compressOptions === null) {
                throw new Error('Required parameter "this.compressOptions" was null when calling compressDocumentOnline.');
            }
            (_a = this.compressOptions) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.compressOptions !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.compressOptions, this.compressOptions.constructor.name === "Object" ? "importedCompressOptions.CompressOptions" : this.compressOptions.constructor.name);
                formParams.push(['CompressOptions', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new CompressDocumentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "CompressResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.CompressDocumentOnlineRequest = CompressDocumentOnlineRequest;
/**
 * Request model for ConvertDocument operation.
 * Converts a document on a local drive to the specified format.
 */
class ConvertDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/convert"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling convertDocument.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling convertDocument.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling convertDocument.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling convertDocument.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", this.outPath, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fileNameFieldValue", this.fileNameFieldValue, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.ConvertDocumentRequest = ConvertDocumentRequest;
/**
 * Request model for CopyFile operation.
 * Copy file.
 */
class CopyFileRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/copy/{srcPath}"
                .replace("/{" + "srcPath" + "}", (this.srcPath !== null && this.srcPath !== undefined) ? "/" + String(this.srcPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.destPath' is not undefined
            if (this.destPath === undefined) {
                throw new Error('Required parameter "this.destPath" was undefined when calling copyFile.');
            }
            // verify required parameter 'this.destPath' is not null
            if (this.destPath === null) {
                throw new Error('Required parameter "this.destPath" was null when calling copyFile.');
            }
            // verify required parameter 'this.srcPath' is not undefined
            if (this.srcPath === undefined) {
                throw new Error('Required parameter "this.srcPath" was undefined when calling copyFile.');
            }
            // verify required parameter 'this.srcPath' is not null
            if (this.srcPath === null) {
                throw new Error('Required parameter "this.srcPath" was null when calling copyFile.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destPath", this.destPath, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "srcStorageName", this.srcStorageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destStorageName", this.destStorageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", this.versionId, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.CopyFileRequest = CopyFileRequest;
/**
 * Request model for CopyFolder operation.
 * Copy folder.
 */
class CopyFolderRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/copy/{srcPath}"
                .replace("/{" + "srcPath" + "}", (this.srcPath !== null && this.srcPath !== undefined) ? "/" + String(this.srcPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.destPath' is not undefined
            if (this.destPath === undefined) {
                throw new Error('Required parameter "this.destPath" was undefined when calling copyFolder.');
            }
            // verify required parameter 'this.destPath' is not null
            if (this.destPath === null) {
                throw new Error('Required parameter "this.destPath" was null when calling copyFolder.');
            }
            // verify required parameter 'this.srcPath' is not undefined
            if (this.srcPath === undefined) {
                throw new Error('Required parameter "this.srcPath" was undefined when calling copyFolder.');
            }
            // verify required parameter 'this.srcPath' is not null
            if (this.srcPath === null) {
                throw new Error('Required parameter "this.srcPath" was null when calling copyFolder.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destPath", this.destPath, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "srcStorageName", this.srcStorageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destStorageName", this.destStorageName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.CopyFolderRequest = CopyFolderRequest;
/**
 * Request model for CopyStyle operation.
 * Makes a copy of the style in the document.
 */
class CopyStyleRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/copy"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling copyStyle.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling copyStyle.');
            }
            // verify required parameter 'this.styleCopy' is not undefined
            if (this.styleCopy === undefined) {
                throw new Error('Required parameter "this.styleCopy" was undefined when calling copyStyle.');
            }
            // verify required parameter 'this.styleCopy' is not null
            if (this.styleCopy === null) {
                throw new Error('Required parameter "this.styleCopy" was null when calling copyStyle.');
            }
            (_a = this.styleCopy) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.styleCopy !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.styleCopy, this.styleCopy.constructor.name === "Object" ? "importedStyleCopy.StyleCopy" : this.styleCopy.constructor.name);
                formParams.push(['StyleCopy', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
    }
}
exports.CopyStyleRequest = CopyStyleRequest;
/**
 * Request model for CopyStyleOnline operation.
 * Makes a copy of the style in the document.
 */
class CopyStyleOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/styles/copy"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling copyStyleOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling copyStyleOnline.');
            }
            // verify required parameter 'this.styleCopy' is not undefined
            if (this.styleCopy === undefined) {
                throw new Error('Required parameter "this.styleCopy" was undefined when calling copyStyleOnline.');
            }
            // verify required parameter 'this.styleCopy' is not null
            if (this.styleCopy === null) {
                throw new Error('Required parameter "this.styleCopy" was null when calling copyStyleOnline.');
            }
            (_a = this.styleCopy) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.styleCopy !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.styleCopy, this.styleCopy.constructor.name === "Object" ? "importedStyleCopy.StyleCopy" : this.styleCopy.constructor.name);
                formParams.push(['StyleCopy', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new CopyStyleOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "StyleResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.CopyStyleOnlineRequest = CopyStyleOnlineRequest;
/**
 * Request model for CopyStylesFromTemplate operation.
 * Copies styles from the origin document to the target document.
 */
class CopyStylesFromTemplateRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/copy_from"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling copyStylesFromTemplate.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling copyStylesFromTemplate.');
            }
            // verify required parameter 'this.templateName' is not undefined
            if (this.templateName === undefined) {
                throw new Error('Required parameter "this.templateName" was undefined when calling copyStylesFromTemplate.');
            }
            // verify required parameter 'this.templateName' is not null
            if (this.templateName === null) {
                throw new Error('Required parameter "this.templateName" was null when calling copyStylesFromTemplate.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "templateName", this.templateName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "WordsResponse");
    }
}
exports.CopyStylesFromTemplateRequest = CopyStylesFromTemplateRequest;
/**
 * Request model for CreateDocument operation.
 * Creates a new document in cloud storage in the format, determined by the file extension.
 * Supported all save format extensions.
 */
class CreateDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/create"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.fileName' is not undefined
            if (this.fileName === undefined) {
                throw new Error('Required parameter "this.fileName" was undefined when calling createDocument.');
            }
            // verify required parameter 'this.fileName' is not null
            if (this.fileName === null) {
                throw new Error('Required parameter "this.fileName" was null when calling createDocument.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fileName", this.fileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.CreateDocumentRequest = CreateDocumentRequest;
/**
 * Request model for CreateFolder operation.
 * Create the folder.
 */
class CreateFolderRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/{path}"
                .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.path' is not undefined
            if (this.path === undefined) {
                throw new Error('Required parameter "this.path" was undefined when calling createFolder.');
            }
            // verify required parameter 'this.path' is not null
            if (this.path === null) {
                throw new Error('Required parameter "this.path" was null when calling createFolder.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.CreateFolderRequest = CreateFolderRequest;
/**
 * Request model for CreateOrUpdateDocumentProperty operation.
 * Adds a new or updates an existing document property.
 */
class CreateOrUpdateDocumentPropertyRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/documentProperties/{propertyName}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling createOrUpdateDocumentProperty.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling createOrUpdateDocumentProperty.');
            }
            // verify required parameter 'this.propertyName' is not undefined
            if (this.propertyName === undefined) {
                throw new Error('Required parameter "this.propertyName" was undefined when calling createOrUpdateDocumentProperty.');
            }
            // verify required parameter 'this.propertyName' is not null
            if (this.propertyName === null) {
                throw new Error('Required parameter "this.propertyName" was null when calling createOrUpdateDocumentProperty.');
            }
            // verify required parameter 'this.property' is not undefined
            if (this.property === undefined) {
                throw new Error('Required parameter "this.property" was undefined when calling createOrUpdateDocumentProperty.');
            }
            // verify required parameter 'this.property' is not null
            if (this.property === null) {
                throw new Error('Required parameter "this.property" was null when calling createOrUpdateDocumentProperty.');
            }
            (_a = this.property) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.property !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.property, this.property.constructor.name === "Object" ? "importedDocumentPropertyCreateOrUpdate.DocumentPropertyCreateOrUpdate" : this.property.constructor.name);
                formParams.push(['Property', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertyResponse");
    }
}
exports.CreateOrUpdateDocumentPropertyRequest = CreateOrUpdateDocumentPropertyRequest;
/**
 * Request model for CreateOrUpdateDocumentPropertyOnline operation.
 * Adds a new or updates an existing document property.
 */
class CreateOrUpdateDocumentPropertyOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/documentProperties/{propertyName}"
                .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling createOrUpdateDocumentPropertyOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling createOrUpdateDocumentPropertyOnline.');
            }
            // verify required parameter 'this.propertyName' is not undefined
            if (this.propertyName === undefined) {
                throw new Error('Required parameter "this.propertyName" was undefined when calling createOrUpdateDocumentPropertyOnline.');
            }
            // verify required parameter 'this.propertyName' is not null
            if (this.propertyName === null) {
                throw new Error('Required parameter "this.propertyName" was null when calling createOrUpdateDocumentPropertyOnline.');
            }
            // verify required parameter 'this.property' is not undefined
            if (this.property === undefined) {
                throw new Error('Required parameter "this.property" was undefined when calling createOrUpdateDocumentPropertyOnline.');
            }
            // verify required parameter 'this.property' is not null
            if (this.property === null) {
                throw new Error('Required parameter "this.property" was null when calling createOrUpdateDocumentPropertyOnline.');
            }
            (_a = this.property) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.property !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.property, this.property.constructor.name === "Object" ? "importedDocumentPropertyCreateOrUpdate.DocumentPropertyCreateOrUpdate" : this.property.constructor.name);
                formParams.push(['Property', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new CreateOrUpdateDocumentPropertyOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentPropertyResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.CreateOrUpdateDocumentPropertyOnlineRequest = CreateOrUpdateDocumentPropertyOnlineRequest;
/**
 * Request model for DeleteAllParagraphTabStops operation.
 * Removes paragraph tab stops from the document node.
 */
class DeleteAllParagraphTabStopsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/tabstops"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteAllParagraphTabStops.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteAllParagraphTabStops.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteAllParagraphTabStops.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteAllParagraphTabStops.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
    }
}
exports.DeleteAllParagraphTabStopsRequest = DeleteAllParagraphTabStopsRequest;
/**
 * Request model for DeleteAllParagraphTabStopsOnline operation.
 * Removes paragraph tab stops from the document node.
 */
class DeleteAllParagraphTabStopsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/paragraphs/{index}/tabstops"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteAllParagraphTabStopsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteAllParagraphTabStopsOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteAllParagraphTabStopsOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteAllParagraphTabStopsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new DeleteAllParagraphTabStopsOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TabStopsResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.DeleteAllParagraphTabStopsOnlineRequest = DeleteAllParagraphTabStopsOnlineRequest;
/**
 * Request model for DeleteBookmark operation.
 * Removes a bookmark from the document.
 */
class DeleteBookmarkRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks/{bookmarkName}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteBookmark.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteBookmark.');
            }
            // verify required parameter 'this.bookmarkName' is not undefined
            if (this.bookmarkName === undefined) {
                throw new Error('Required parameter "this.bookmarkName" was undefined when calling deleteBookmark.');
            }
            // verify required parameter 'this.bookmarkName' is not null
            if (this.bookmarkName === null) {
                throw new Error('Required parameter "this.bookmarkName" was null when calling deleteBookmark.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteBookmarkRequest = DeleteBookmarkRequest;
/**
 * Request model for DeleteBookmarkOnline operation.
 * Removes a bookmark from the document.
 */
class DeleteBookmarkOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/bookmarks/{bookmarkName}"
                .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteBookmarkOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteBookmarkOnline.');
            }
            // verify required parameter 'this.bookmarkName' is not undefined
            if (this.bookmarkName === undefined) {
                throw new Error('Required parameter "this.bookmarkName" was undefined when calling deleteBookmarkOnline.');
            }
            // verify required parameter 'this.bookmarkName' is not null
            if (this.bookmarkName === null) {
                throw new Error('Required parameter "this.bookmarkName" was null when calling deleteBookmarkOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteBookmarkOnlineRequest = DeleteBookmarkOnlineRequest;
/**
 * Request model for DeleteBookmarks operation.
 * Removes all bookmarks from the document.
 */
class DeleteBookmarksRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteBookmarks.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteBookmarks.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteBookmarksRequest = DeleteBookmarksRequest;
/**
 * Request model for DeleteBookmarksOnline operation.
 * Removes all bookmarks from the document.
 */
class DeleteBookmarksOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/bookmarks"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteBookmarksOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteBookmarksOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteBookmarksOnlineRequest = DeleteBookmarksOnlineRequest;
/**
 * Request model for DeleteBorder operation.
 * Removes a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class DeleteBorderRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders/{borderType}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteBorder.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteBorder.');
            }
            // verify required parameter 'this.borderType' is not undefined
            if (this.borderType === undefined) {
                throw new Error('Required parameter "this.borderType" was undefined when calling deleteBorder.');
            }
            // verify required parameter 'this.borderType' is not null
            if (this.borderType === null) {
                throw new Error('Required parameter "this.borderType" was null when calling deleteBorder.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BorderResponse");
    }
}
exports.DeleteBorderRequest = DeleteBorderRequest;
/**
 * Request model for DeleteBorderOnline operation.
 * Removes a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class DeleteBorderOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/borders/{borderType}"
                .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteBorderOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteBorderOnline.');
            }
            // verify required parameter 'this.borderType' is not undefined
            if (this.borderType === undefined) {
                throw new Error('Required parameter "this.borderType" was undefined when calling deleteBorderOnline.');
            }
            // verify required parameter 'this.borderType' is not null
            if (this.borderType === null) {
                throw new Error('Required parameter "this.borderType" was null when calling deleteBorderOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new DeleteBorderOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "BorderResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.DeleteBorderOnlineRequest = DeleteBorderOnlineRequest;
/**
 * Request model for DeleteBorders operation.
 * Removes borders from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class DeleteBordersRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteBorders.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteBorders.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BordersResponse");
    }
}
exports.DeleteBordersRequest = DeleteBordersRequest;
/**
 * Request model for DeleteBordersOnline operation.
 * Removes borders from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class DeleteBordersOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/borders"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteBordersOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteBordersOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new DeleteBordersOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "BordersResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.DeleteBordersOnlineRequest = DeleteBordersOnlineRequest;
/**
 * Request model for DeleteComment operation.
 * Removes a comment from the document.
 */
class DeleteCommentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments/{commentIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteComment.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteComment.');
            }
            // verify required parameter 'this.commentIndex' is not undefined
            if (this.commentIndex === undefined) {
                throw new Error('Required parameter "this.commentIndex" was undefined when calling deleteComment.');
            }
            // verify required parameter 'this.commentIndex' is not null
            if (this.commentIndex === null) {
                throw new Error('Required parameter "this.commentIndex" was null when calling deleteComment.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteCommentRequest = DeleteCommentRequest;
/**
 * Request model for DeleteCommentOnline operation.
 * Removes a comment from the document.
 */
class DeleteCommentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/comments/{commentIndex}"
                .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteCommentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteCommentOnline.');
            }
            // verify required parameter 'this.commentIndex' is not undefined
            if (this.commentIndex === undefined) {
                throw new Error('Required parameter "this.commentIndex" was undefined when calling deleteCommentOnline.');
            }
            // verify required parameter 'this.commentIndex' is not null
            if (this.commentIndex === null) {
                throw new Error('Required parameter "this.commentIndex" was null when calling deleteCommentOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteCommentOnlineRequest = DeleteCommentOnlineRequest;
/**
 * Request model for DeleteComments operation.
 * Removes all comments from the document.
 */
class DeleteCommentsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteComments.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteComments.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteCommentsRequest = DeleteCommentsRequest;
/**
 * Request model for DeleteCommentsOnline operation.
 * Removes all comments from the document.
 */
class DeleteCommentsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/comments"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteCommentsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteCommentsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteCommentsOnlineRequest = DeleteCommentsOnlineRequest;
/**
 * Request model for DeleteCustomXmlPart operation.
 * Removes the custom xml part from the document.
 */
class DeleteCustomXmlPartRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts/{customXmlPartIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteCustomXmlPart.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not undefined
            if (this.customXmlPartIndex === undefined) {
                throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling deleteCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not null
            if (this.customXmlPartIndex === null) {
                throw new Error('Required parameter "this.customXmlPartIndex" was null when calling deleteCustomXmlPart.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteCustomXmlPartRequest = DeleteCustomXmlPartRequest;
/**
 * Request model for DeleteCustomXmlPartOnline operation.
 * Removes the custom xml part from the document.
 */
class DeleteCustomXmlPartOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/customXmlParts/{customXmlPartIndex}"
                .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteCustomXmlPartOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not undefined
            if (this.customXmlPartIndex === undefined) {
                throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling deleteCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not null
            if (this.customXmlPartIndex === null) {
                throw new Error('Required parameter "this.customXmlPartIndex" was null when calling deleteCustomXmlPartOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteCustomXmlPartOnlineRequest = DeleteCustomXmlPartOnlineRequest;
/**
 * Request model for DeleteCustomXmlParts operation.
 * Removes all custom xml parts from the document.
 */
class DeleteCustomXmlPartsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteCustomXmlParts.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteCustomXmlParts.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteCustomXmlPartsRequest = DeleteCustomXmlPartsRequest;
/**
 * Request model for DeleteCustomXmlPartsOnline operation.
 * Removes all custom xml parts from the document.
 */
class DeleteCustomXmlPartsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/customXmlParts"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteCustomXmlPartsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteCustomXmlPartsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteCustomXmlPartsOnlineRequest = DeleteCustomXmlPartsOnlineRequest;
/**
 * Request model for DeleteDocumentProperty operation.
 * Removes a document property.
 */
class DeleteDocumentPropertyRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/documentProperties/{propertyName}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteDocumentProperty.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteDocumentProperty.');
            }
            // verify required parameter 'this.propertyName' is not undefined
            if (this.propertyName === undefined) {
                throw new Error('Required parameter "this.propertyName" was undefined when calling deleteDocumentProperty.');
            }
            // verify required parameter 'this.propertyName' is not null
            if (this.propertyName === null) {
                throw new Error('Required parameter "this.propertyName" was null when calling deleteDocumentProperty.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteDocumentPropertyRequest = DeleteDocumentPropertyRequest;
/**
 * Request model for DeleteDocumentPropertyOnline operation.
 * Removes a document property.
 */
class DeleteDocumentPropertyOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/documentProperties/{propertyName}"
                .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteDocumentPropertyOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteDocumentPropertyOnline.');
            }
            // verify required parameter 'this.propertyName' is not undefined
            if (this.propertyName === undefined) {
                throw new Error('Required parameter "this.propertyName" was undefined when calling deleteDocumentPropertyOnline.');
            }
            // verify required parameter 'this.propertyName' is not null
            if (this.propertyName === null) {
                throw new Error('Required parameter "this.propertyName" was null when calling deleteDocumentPropertyOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteDocumentPropertyOnlineRequest = DeleteDocumentPropertyOnlineRequest;
/**
 * Request model for DeleteDrawingObject operation.
 * Removes a DrawingObject from the document node.
 */
class DeleteDrawingObjectRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteDrawingObject.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteDrawingObject.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteDrawingObject.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteDrawingObject.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteDrawingObjectRequest = DeleteDrawingObjectRequest;
/**
 * Request model for DeleteDrawingObjectOnline operation.
 * Removes a DrawingObject from the document node.
 */
class DeleteDrawingObjectOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/drawingObjects/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteDrawingObjectOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteDrawingObjectOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteDrawingObjectOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteDrawingObjectOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteDrawingObjectOnlineRequest = DeleteDrawingObjectOnlineRequest;
/**
 * Request model for DeleteField operation.
 * Removes a field from the document node.
 */
class DeleteFieldRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteField.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteField.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteField.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteField.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteFieldRequest = DeleteFieldRequest;
/**
 * Request model for DeleteFieldOnline operation.
 * Removes a field from the document node.
 */
class DeleteFieldOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/fields/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteFieldOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteFieldOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteFieldOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteFieldOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteFieldOnlineRequest = DeleteFieldOnlineRequest;
/**
 * Request model for DeleteFields operation.
 * Removes fields from the document node.
 */
class DeleteFieldsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteFields.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteFields.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteFieldsRequest = DeleteFieldsRequest;
/**
 * Request model for DeleteFieldsOnline operation.
 * Removes fields from the document node.
 */
class DeleteFieldsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/fields"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteFieldsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteFieldsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteFieldsOnlineRequest = DeleteFieldsOnlineRequest;
/**
 * Request model for DeleteFile operation.
 * Delete file.
 */
class DeleteFileRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/{path}"
                .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.path' is not undefined
            if (this.path === undefined) {
                throw new Error('Required parameter "this.path" was undefined when calling deleteFile.');
            }
            // verify required parameter 'this.path' is not null
            if (this.path === null) {
                throw new Error('Required parameter "this.path" was null when calling deleteFile.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", this.versionId, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteFileRequest = DeleteFileRequest;
/**
 * Request model for DeleteFolder operation.
 * Delete folder.
 */
class DeleteFolderRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/{path}"
                .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.path' is not undefined
            if (this.path === undefined) {
                throw new Error('Required parameter "this.path" was undefined when calling deleteFolder.');
            }
            // verify required parameter 'this.path' is not null
            if (this.path === null) {
                throw new Error('Required parameter "this.path" was null when calling deleteFolder.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "recursive", this.recursive, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteFolderRequest = DeleteFolderRequest;
/**
 * Request model for DeleteFootnote operation.
 * Removes a footnote from the document node.
 */
class DeleteFootnoteRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteFootnote.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteFootnote.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteFootnote.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteFootnote.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteFootnoteRequest = DeleteFootnoteRequest;
/**
 * Request model for DeleteFootnoteOnline operation.
 * Removes a footnote from the document node.
 */
class DeleteFootnoteOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/footnotes/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteFootnoteOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteFootnoteOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteFootnoteOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteFootnoteOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteFootnoteOnlineRequest = DeleteFootnoteOnlineRequest;
/**
 * Request model for DeleteFormField operation.
 * Removes a form field from the document node.
 */
class DeleteFormFieldRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteFormField.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteFormField.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteFormField.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteFormField.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteFormFieldRequest = DeleteFormFieldRequest;
/**
 * Request model for DeleteFormFieldOnline operation.
 * Removes a form field from the document node.
 */
class DeleteFormFieldOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/formfields/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteFormFieldOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteFormFieldOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteFormFieldOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteFormFieldOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteFormFieldOnlineRequest = DeleteFormFieldOnlineRequest;
/**
 * Request model for DeleteHeaderFooter operation.
 * Removes a HeaderFooter object from the document section.
 */
class DeleteHeaderFooterRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{sectionPath}/headersfooters/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteHeaderFooter.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteHeaderFooter.');
            }
            // verify required parameter 'this.sectionPath' is not undefined
            if (this.sectionPath === undefined) {
                throw new Error('Required parameter "this.sectionPath" was undefined when calling deleteHeaderFooter.');
            }
            // verify required parameter 'this.sectionPath' is not null
            if (this.sectionPath === null) {
                throw new Error('Required parameter "this.sectionPath" was null when calling deleteHeaderFooter.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteHeaderFooter.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteHeaderFooter.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteHeaderFooterRequest = DeleteHeaderFooterRequest;
/**
 * Request model for DeleteHeaderFooterOnline operation.
 * Removes a HeaderFooter object from the document section.
 */
class DeleteHeaderFooterOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{sectionPath}/headersfooters/{index}"
                .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteHeaderFooterOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteHeaderFooterOnline.');
            }
            // verify required parameter 'this.sectionPath' is not undefined
            if (this.sectionPath === undefined) {
                throw new Error('Required parameter "this.sectionPath" was undefined when calling deleteHeaderFooterOnline.');
            }
            // verify required parameter 'this.sectionPath' is not null
            if (this.sectionPath === null) {
                throw new Error('Required parameter "this.sectionPath" was null when calling deleteHeaderFooterOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteHeaderFooterOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteHeaderFooterOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteHeaderFooterOnlineRequest = DeleteHeaderFooterOnlineRequest;
/**
 * Request model for DeleteHeadersFooters operation.
 * Removes HeaderFooter objects from the document section.
 */
class DeleteHeadersFootersRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{sectionPath}/headersfooters"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteHeadersFooters.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteHeadersFooters.');
            }
            // verify required parameter 'this.sectionPath' is not undefined
            if (this.sectionPath === undefined) {
                throw new Error('Required parameter "this.sectionPath" was undefined when calling deleteHeadersFooters.');
            }
            // verify required parameter 'this.sectionPath' is not null
            if (this.sectionPath === null) {
                throw new Error('Required parameter "this.sectionPath" was null when calling deleteHeadersFooters.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "headersFootersTypes", this.headersFootersTypes, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteHeadersFootersRequest = DeleteHeadersFootersRequest;
/**
 * Request model for DeleteHeadersFootersOnline operation.
 * Removes HeaderFooter objects from the document section.
 */
class DeleteHeadersFootersOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{sectionPath}/headersfooters"
                .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteHeadersFootersOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteHeadersFootersOnline.');
            }
            // verify required parameter 'this.sectionPath' is not undefined
            if (this.sectionPath === undefined) {
                throw new Error('Required parameter "this.sectionPath" was undefined when calling deleteHeadersFootersOnline.');
            }
            // verify required parameter 'this.sectionPath' is not null
            if (this.sectionPath === null) {
                throw new Error('Required parameter "this.sectionPath" was null when calling deleteHeadersFootersOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "headersFootersTypes", this.headersFootersTypes, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteHeadersFootersOnlineRequest = DeleteHeadersFootersOnlineRequest;
/**
 * Request model for DeleteMacros operation.
 * Removes macros from the document.
 */
class DeleteMacrosRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/macros"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteMacros.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteMacros.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteMacrosRequest = DeleteMacrosRequest;
/**
 * Request model for DeleteMacrosOnline operation.
 * Removes macros from the document.
 */
class DeleteMacrosOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/macros"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteMacrosOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteMacrosOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteMacrosOnlineRequest = DeleteMacrosOnlineRequest;
/**
 * Request model for DeleteOfficeMathObject operation.
 * Removes an OfficeMath object from the document node.
 */
class DeleteOfficeMathObjectRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/OfficeMathObjects/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteOfficeMathObject.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteOfficeMathObject.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteOfficeMathObject.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteOfficeMathObject.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteOfficeMathObjectRequest = DeleteOfficeMathObjectRequest;
/**
 * Request model for DeleteOfficeMathObjectOnline operation.
 * Removes an OfficeMath object from the document node.
 */
class DeleteOfficeMathObjectOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/OfficeMathObjects/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteOfficeMathObjectOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteOfficeMathObjectOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteOfficeMathObjectOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteOfficeMathObjectOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteOfficeMathObjectOnlineRequest = DeleteOfficeMathObjectOnlineRequest;
/**
 * Request model for DeleteOfficeMathObjects operation.
 * Removes all office math objects from the document.
 */
class DeleteOfficeMathObjectsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/OfficeMathObjects"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteOfficeMathObjects.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteOfficeMathObjects.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteOfficeMathObjectsRequest = DeleteOfficeMathObjectsRequest;
/**
 * Request model for DeleteOfficeMathObjectsOnline operation.
 * Removes all office math objects from the document.
 */
class DeleteOfficeMathObjectsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/OfficeMathObjects"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteOfficeMathObjectsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteOfficeMathObjectsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteOfficeMathObjectsOnlineRequest = DeleteOfficeMathObjectsOnlineRequest;
/**
 * Request model for DeleteParagraph operation.
 * Removes a paragraph from the document node.
 */
class DeleteParagraphRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteParagraph.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteParagraph.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteParagraph.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteParagraph.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteParagraphRequest = DeleteParagraphRequest;
/**
 * Request model for DeleteParagraphListFormat operation.
 * Removes the formatting properties of a paragraph list from the document node.
 */
class DeleteParagraphListFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/listFormat"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteParagraphListFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteParagraphListFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphListFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteParagraphListFormat.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphListFormatResponse");
    }
}
exports.DeleteParagraphListFormatRequest = DeleteParagraphListFormatRequest;
/**
 * Request model for DeleteParagraphListFormatOnline operation.
 * Removes the formatting properties of a paragraph list from the document node.
 */
class DeleteParagraphListFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/paragraphs/{index}/listFormat"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteParagraphListFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteParagraphListFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphListFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteParagraphListFormatOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new DeleteParagraphListFormatOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ParagraphListFormatResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.DeleteParagraphListFormatOnlineRequest = DeleteParagraphListFormatOnlineRequest;
/**
 * Request model for DeleteParagraphOnline operation.
 * Removes a paragraph from the document node.
 */
class DeleteParagraphOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/paragraphs/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteParagraphOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteParagraphOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteParagraphOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteParagraphOnlineRequest = DeleteParagraphOnlineRequest;
/**
 * Request model for DeleteParagraphTabStop operation.
 * Removes a paragraph tab stop from the document node.
 */
class DeleteParagraphTabStopRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/tabstop"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteParagraphTabStop.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteParagraphTabStop.');
            }
            // verify required parameter 'this.position' is not undefined
            if (this.position === undefined) {
                throw new Error('Required parameter "this.position" was undefined when calling deleteParagraphTabStop.');
            }
            // verify required parameter 'this.position' is not null
            if (this.position === null) {
                throw new Error('Required parameter "this.position" was null when calling deleteParagraphTabStop.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphTabStop.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteParagraphTabStop.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", this.position, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
    }
}
exports.DeleteParagraphTabStopRequest = DeleteParagraphTabStopRequest;
/**
 * Request model for DeleteParagraphTabStopOnline operation.
 * Removes a paragraph tab stop from the document node.
 */
class DeleteParagraphTabStopOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/paragraphs/{index}/tabstop"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteParagraphTabStopOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteParagraphTabStopOnline.');
            }
            // verify required parameter 'this.position' is not undefined
            if (this.position === undefined) {
                throw new Error('Required parameter "this.position" was undefined when calling deleteParagraphTabStopOnline.');
            }
            // verify required parameter 'this.position' is not null
            if (this.position === null) {
                throw new Error('Required parameter "this.position" was null when calling deleteParagraphTabStopOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphTabStopOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteParagraphTabStopOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "position", this.position, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new DeleteParagraphTabStopOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TabStopsResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.DeleteParagraphTabStopOnlineRequest = DeleteParagraphTabStopOnlineRequest;
/**
 * Request model for DeleteRun operation.
 * Removes a Run object from the paragraph.
 */
class DeleteRunRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteRun.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteRun.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling deleteRun.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling deleteRun.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteRun.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteRun.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteRunRequest = DeleteRunRequest;
/**
 * Request model for DeleteRunOnline operation.
 * Removes a Run object from the paragraph.
 */
class DeleteRunOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{paragraphPath}/runs/{index}"
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteRunOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteRunOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling deleteRunOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling deleteRunOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteRunOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteRunOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteRunOnlineRequest = DeleteRunOnlineRequest;
/**
 * Request model for DeleteSection operation.
 * Removes a section from the document.
 */
class DeleteSectionRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteSection.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteSection.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling deleteSection.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling deleteSection.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteSectionRequest = DeleteSectionRequest;
/**
 * Request model for DeleteSectionOnline operation.
 * Removes a section from the document.
 */
class DeleteSectionOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/sections/{sectionIndex}"
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteSectionOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteSectionOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling deleteSectionOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling deleteSectionOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteSectionOnlineRequest = DeleteSectionOnlineRequest;
/**
 * Request model for DeleteStructuredDocumentTag operation.
 * Removes a StructuredDocumentTag (SDT) from the document node.
 */
class DeleteStructuredDocumentTagRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteStructuredDocumentTag.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteStructuredDocumentTag.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteStructuredDocumentTag.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteStructuredDocumentTag.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteStructuredDocumentTagRequest = DeleteStructuredDocumentTagRequest;
/**
 * Request model for DeleteStructuredDocumentTagOnline operation.
 * Removes a StructuredDocumentTag (SDT) from the document node.
 */
class DeleteStructuredDocumentTagOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/sdt/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteStructuredDocumentTagOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteStructuredDocumentTagOnlineRequest = DeleteStructuredDocumentTagOnlineRequest;
/**
 * Request model for DeleteTable operation.
 * Removes a table from the document node.
 */
class DeleteTableRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteTable.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteTable.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteTable.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteTable.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteTableRequest = DeleteTableRequest;
/**
 * Request model for DeleteTableCell operation.
 * Removes a cell from the table row.
 */
class DeleteTableCellRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteTableCell.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteTableCell.');
            }
            // verify required parameter 'this.tableRowPath' is not undefined
            if (this.tableRowPath === undefined) {
                throw new Error('Required parameter "this.tableRowPath" was undefined when calling deleteTableCell.');
            }
            // verify required parameter 'this.tableRowPath' is not null
            if (this.tableRowPath === null) {
                throw new Error('Required parameter "this.tableRowPath" was null when calling deleteTableCell.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteTableCell.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteTableCell.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteTableCellRequest = DeleteTableCellRequest;
/**
 * Request model for DeleteTableCellOnline operation.
 * Removes a cell from the table row.
 */
class DeleteTableCellOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{tableRowPath}/cells/{index}"
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteTableCellOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteTableCellOnline.');
            }
            // verify required parameter 'this.tableRowPath' is not undefined
            if (this.tableRowPath === undefined) {
                throw new Error('Required parameter "this.tableRowPath" was undefined when calling deleteTableCellOnline.');
            }
            // verify required parameter 'this.tableRowPath' is not null
            if (this.tableRowPath === null) {
                throw new Error('Required parameter "this.tableRowPath" was null when calling deleteTableCellOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteTableCellOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteTableCellOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteTableCellOnlineRequest = DeleteTableCellOnlineRequest;
/**
 * Request model for DeleteTableOnline operation.
 * Removes a table from the document node.
 */
class DeleteTableOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/tables/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteTableOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteTableOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteTableOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteTableOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteTableOnlineRequest = DeleteTableOnlineRequest;
/**
 * Request model for DeleteTableRow operation.
 * Removes a row from the table.
 */
class DeleteTableRowRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tablePath}/rows/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteTableRow.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteTableRow.');
            }
            // verify required parameter 'this.tablePath' is not undefined
            if (this.tablePath === undefined) {
                throw new Error('Required parameter "this.tablePath" was undefined when calling deleteTableRow.');
            }
            // verify required parameter 'this.tablePath' is not null
            if (this.tablePath === null) {
                throw new Error('Required parameter "this.tablePath" was null when calling deleteTableRow.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteTableRow.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteTableRow.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.DeleteTableRowRequest = DeleteTableRowRequest;
/**
 * Request model for DeleteTableRowOnline operation.
 * Removes a row from the table.
 */
class DeleteTableRowOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{tablePath}/rows/{index}"
                .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteTableRowOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteTableRowOnline.');
            }
            // verify required parameter 'this.tablePath' is not undefined
            if (this.tablePath === undefined) {
                throw new Error('Required parameter "this.tablePath" was undefined when calling deleteTableRowOnline.');
            }
            // verify required parameter 'this.tablePath' is not null
            if (this.tablePath === null) {
                throw new Error('Required parameter "this.tablePath" was null when calling deleteTableRowOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling deleteTableRowOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling deleteTableRowOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.DeleteTableRowOnlineRequest = DeleteTableRowOnlineRequest;
/**
 * Request model for DeleteWatermark operation.
 * Removes a watermark from the document.
 */
class DeleteWatermarkRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/watermarks/deleteLast"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling deleteWatermark.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling deleteWatermark.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.DeleteWatermarkRequest = DeleteWatermarkRequest;
/**
 * Request model for DeleteWatermarkOnline operation.
 * Removes a watermark from the document.
 */
class DeleteWatermarkOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/watermarks/deleteLast"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling deleteWatermarkOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling deleteWatermarkOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new DeleteWatermarkOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.DeleteWatermarkOnlineRequest = DeleteWatermarkOnlineRequest;
/**
 * Request model for DownloadFile operation.
 * Download file.
 */
class DownloadFileRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/{path}"
                .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.path' is not undefined
            if (this.path === undefined) {
                throw new Error('Required parameter "this.path" was undefined when calling downloadFile.');
            }
            // verify required parameter 'this.path' is not null
            if (this.path === null) {
                throw new Error('Required parameter "this.path" was null when calling downloadFile.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", this.versionId, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.DownloadFileRequest = DownloadFileRequest;
/**
 * Request model for ExecuteMailMerge operation.
 * Executes a Mail Merge operation.
 */
class ExecuteMailMergeRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/MailMerge"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling executeMailMerge.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling executeMailMerge.');
            }
            (_a = this.options) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withRegions", this.withRegions, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "mailMergeDataFile", this.mailMergeDataFile, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "cleanup", this.cleanup, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "useWholeParagraphAsRegion", this.useWholeParagraphAsRegion, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "mergeWholeDocument", this.mergeWholeDocument, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.data !== undefined) {
                formParams.push(['Data', this.data, 'text/plain']);
            }
            if (this.options !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.options, this.options.constructor.name === "Object" ? "importedFieldOptions.FieldOptions" : this.options.constructor.name);
                formParams.push(['Options', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.ExecuteMailMergeRequest = ExecuteMailMergeRequest;
/**
 * Request model for ExecuteMailMergeOnline operation.
 * Executes a Mail Merge operation online.
 */
class ExecuteMailMergeOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/MailMerge"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.template' is not undefined
            if (this.template === undefined) {
                throw new Error('Required parameter "this.template" was undefined when calling executeMailMergeOnline.');
            }
            // verify required parameter 'this.template' is not null
            if (this.template === null) {
                throw new Error('Required parameter "this.template" was null when calling executeMailMergeOnline.');
            }
            // verify required parameter 'this.data' is not undefined
            if (this.data === undefined) {
                throw new Error('Required parameter "this.data" was undefined when calling executeMailMergeOnline.');
            }
            // verify required parameter 'this.data' is not null
            if (this.data === null) {
                throw new Error('Required parameter "this.data" was null when calling executeMailMergeOnline.');
            }
            (_a = this.options) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "withRegions", this.withRegions, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "mergeWholeDocument", this.mergeWholeDocument, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "cleanup", this.cleanup, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "documentFileName", this.documentFileName, _encryptor);
            if (this.template !== undefined) {
                formParams.push(['Template', this.template, 'application/octet-stream']);
            }
            if (this.data !== undefined) {
                formParams.push(['Data', this.data, 'application/octet-stream']);
            }
            if (this.options !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.options, this.options.constructor.name === "Object" ? "importedFieldOptions.FieldOptions" : this.options.constructor.name);
                formParams.push(['Options', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.ExecuteMailMergeOnlineRequest = ExecuteMailMergeOnlineRequest;
/**
 * Request model for GetAllRevisions operation.
 * Get all information about revisions.
 */
class GetAllRevisionsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/revisions/getAll"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getAllRevisions.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getAllRevisions.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RevisionsResponse");
    }
}
exports.GetAllRevisionsRequest = GetAllRevisionsRequest;
/**
 * Request model for GetAllRevisionsOnline operation.
 * Get all information about revisions.
 */
class GetAllRevisionsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/revisions/getAll"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getAllRevisionsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getAllRevisionsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RevisionsResponse");
    }
}
exports.GetAllRevisionsOnlineRequest = GetAllRevisionsOnlineRequest;
/**
 * Request model for GetAvailableFonts operation.
 * Reads available fonts from the document.
 */
class GetAvailableFontsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/fonts/available"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "AvailableFontsResponse");
    }
}
exports.GetAvailableFontsRequest = GetAvailableFontsRequest;
/**
 * Request model for GetBookmarkByName operation.
 * Reads a bookmark, specified by name, from the document.
 */
class GetBookmarkByNameRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks/{bookmarkName}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getBookmarkByName.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getBookmarkByName.');
            }
            // verify required parameter 'this.bookmarkName' is not undefined
            if (this.bookmarkName === undefined) {
                throw new Error('Required parameter "this.bookmarkName" was undefined when calling getBookmarkByName.');
            }
            // verify required parameter 'this.bookmarkName' is not null
            if (this.bookmarkName === null) {
                throw new Error('Required parameter "this.bookmarkName" was null when calling getBookmarkByName.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarkResponse");
    }
}
exports.GetBookmarkByNameRequest = GetBookmarkByNameRequest;
/**
 * Request model for GetBookmarkByNameOnline operation.
 * Reads a bookmark, specified by name, from the document.
 */
class GetBookmarkByNameOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/bookmarks/{bookmarkName}"
                .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getBookmarkByNameOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getBookmarkByNameOnline.');
            }
            // verify required parameter 'this.bookmarkName' is not undefined
            if (this.bookmarkName === undefined) {
                throw new Error('Required parameter "this.bookmarkName" was undefined when calling getBookmarkByNameOnline.');
            }
            // verify required parameter 'this.bookmarkName' is not null
            if (this.bookmarkName === null) {
                throw new Error('Required parameter "this.bookmarkName" was null when calling getBookmarkByNameOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarkResponse");
    }
}
exports.GetBookmarkByNameOnlineRequest = GetBookmarkByNameOnlineRequest;
/**
 * Request model for GetBookmarks operation.
 * Reads bookmarks from the document.
 */
class GetBookmarksRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getBookmarks.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getBookmarks.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarksResponse");
    }
}
exports.GetBookmarksRequest = GetBookmarksRequest;
/**
 * Request model for GetBookmarksOnline operation.
 * Reads bookmarks from the document.
 */
class GetBookmarksOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/bookmarks"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getBookmarksOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getBookmarksOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarksResponse");
    }
}
exports.GetBookmarksOnlineRequest = GetBookmarksOnlineRequest;
/**
 * Request model for GetBorder operation.
 * Reads a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class GetBorderRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders/{borderType}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getBorder.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getBorder.');
            }
            // verify required parameter 'this.borderType' is not undefined
            if (this.borderType === undefined) {
                throw new Error('Required parameter "this.borderType" was undefined when calling getBorder.');
            }
            // verify required parameter 'this.borderType' is not null
            if (this.borderType === null) {
                throw new Error('Required parameter "this.borderType" was null when calling getBorder.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BorderResponse");
    }
}
exports.GetBorderRequest = GetBorderRequest;
/**
 * Request model for GetBorderOnline operation.
 * Reads a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class GetBorderOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/borders/{borderType}"
                .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getBorderOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getBorderOnline.');
            }
            // verify required parameter 'this.borderType' is not undefined
            if (this.borderType === undefined) {
                throw new Error('Required parameter "this.borderType" was undefined when calling getBorderOnline.');
            }
            // verify required parameter 'this.borderType' is not null
            if (this.borderType === null) {
                throw new Error('Required parameter "this.borderType" was null when calling getBorderOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BorderResponse");
    }
}
exports.GetBorderOnlineRequest = GetBorderOnlineRequest;
/**
 * Request model for GetBorders operation.
 * Reads borders from the document node.
 */
class GetBordersRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getBorders.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getBorders.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BordersResponse");
    }
}
exports.GetBordersRequest = GetBordersRequest;
/**
 * Request model for GetBordersOnline operation.
 * Reads borders from the document node.
 */
class GetBordersOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/borders"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getBordersOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getBordersOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BordersResponse");
    }
}
exports.GetBordersOnlineRequest = GetBordersOnlineRequest;
/**
 * Request model for GetComment operation.
 * Reads a comment from the document.
 */
class GetCommentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments/{commentIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getComment.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getComment.');
            }
            // verify required parameter 'this.commentIndex' is not undefined
            if (this.commentIndex === undefined) {
                throw new Error('Required parameter "this.commentIndex" was undefined when calling getComment.');
            }
            // verify required parameter 'this.commentIndex' is not null
            if (this.commentIndex === null) {
                throw new Error('Required parameter "this.commentIndex" was null when calling getComment.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentResponse");
    }
}
exports.GetCommentRequest = GetCommentRequest;
/**
 * Request model for GetCommentOnline operation.
 * Reads a comment from the document.
 */
class GetCommentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/comments/{commentIndex}"
                .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getCommentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getCommentOnline.');
            }
            // verify required parameter 'this.commentIndex' is not undefined
            if (this.commentIndex === undefined) {
                throw new Error('Required parameter "this.commentIndex" was undefined when calling getCommentOnline.');
            }
            // verify required parameter 'this.commentIndex' is not null
            if (this.commentIndex === null) {
                throw new Error('Required parameter "this.commentIndex" was null when calling getCommentOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentResponse");
    }
}
exports.GetCommentOnlineRequest = GetCommentOnlineRequest;
/**
 * Request model for GetComments operation.
 * Reads comments from the document.
 */
class GetCommentsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getComments.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getComments.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentsResponse");
    }
}
exports.GetCommentsRequest = GetCommentsRequest;
/**
 * Request model for GetCommentsOnline operation.
 * Reads comments from the document.
 */
class GetCommentsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/comments"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getCommentsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getCommentsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentsResponse");
    }
}
exports.GetCommentsOnlineRequest = GetCommentsOnlineRequest;
/**
 * Request model for GetCustomXmlPart operation.
 * Reads the custom xml part from the document.
 */
class GetCustomXmlPartRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts/{customXmlPartIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getCustomXmlPart.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not undefined
            if (this.customXmlPartIndex === undefined) {
                throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling getCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not null
            if (this.customXmlPartIndex === null) {
                throw new Error('Required parameter "this.customXmlPartIndex" was null when calling getCustomXmlPart.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartResponse");
    }
}
exports.GetCustomXmlPartRequest = GetCustomXmlPartRequest;
/**
 * Request model for GetCustomXmlPartOnline operation.
 * Reads the custom xml part from the document.
 */
class GetCustomXmlPartOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/customXmlParts/{customXmlPartIndex}"
                .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getCustomXmlPartOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not undefined
            if (this.customXmlPartIndex === undefined) {
                throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling getCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not null
            if (this.customXmlPartIndex === null) {
                throw new Error('Required parameter "this.customXmlPartIndex" was null when calling getCustomXmlPartOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartResponse");
    }
}
exports.GetCustomXmlPartOnlineRequest = GetCustomXmlPartOnlineRequest;
/**
 * Request model for GetCustomXmlParts operation.
 * Reads custom xml parts from the document.
 */
class GetCustomXmlPartsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getCustomXmlParts.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getCustomXmlParts.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartsResponse");
    }
}
exports.GetCustomXmlPartsRequest = GetCustomXmlPartsRequest;
/**
 * Request model for GetCustomXmlPartsOnline operation.
 * Reads custom xml parts from the document.
 */
class GetCustomXmlPartsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/customXmlParts"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getCustomXmlPartsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getCustomXmlPartsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartsResponse");
    }
}
exports.GetCustomXmlPartsOnlineRequest = GetCustomXmlPartsOnlineRequest;
/**
 * Request model for GetDocument operation.
 * Reads common information from the document.
 */
class GetDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{documentName}"
                .replace("/{" + "documentName" + "}", (this.documentName !== null && this.documentName !== undefined) ? "/" + String(this.documentName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.documentName' is not undefined
            if (this.documentName === undefined) {
                throw new Error('Required parameter "this.documentName" was undefined when calling getDocument.');
            }
            // verify required parameter 'this.documentName' is not null
            if (this.documentName === null) {
                throw new Error('Required parameter "this.documentName" was null when calling getDocument.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.GetDocumentRequest = GetDocumentRequest;
/**
 * Request model for GetDocumentDrawingObjectByIndex operation.
 * Reads a DrawingObject from the document node.
 */
class GetDocumentDrawingObjectByIndexRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentDrawingObjectByIndex.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentDrawingObjectByIndex.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectByIndex.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectByIndex.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectResponse");
    }
}
exports.GetDocumentDrawingObjectByIndexRequest = GetDocumentDrawingObjectByIndexRequest;
/**
 * Request model for GetDocumentDrawingObjectByIndexOnline operation.
 * Reads a DrawingObject from the document node.
 */
class GetDocumentDrawingObjectByIndexOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentDrawingObjectByIndexOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentDrawingObjectByIndexOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectByIndexOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectByIndexOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectResponse");
    }
}
exports.GetDocumentDrawingObjectByIndexOnlineRequest = GetDocumentDrawingObjectByIndexOnlineRequest;
/**
 * Request model for GetDocumentDrawingObjectImageData operation.
 * Reads image data of a DrawingObject from the document node.
 */
class GetDocumentDrawingObjectImageDataRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}/imageData"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentDrawingObjectImageData.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentDrawingObjectImageData.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectImageData.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectImageData.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.GetDocumentDrawingObjectImageDataRequest = GetDocumentDrawingObjectImageDataRequest;
/**
 * Request model for GetDocumentDrawingObjectImageDataOnline operation.
 * Reads image data of a DrawingObject from the document node.
 */
class GetDocumentDrawingObjectImageDataOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects/{index}/imageData"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentDrawingObjectImageDataOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentDrawingObjectImageDataOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectImageDataOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectImageDataOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.GetDocumentDrawingObjectImageDataOnlineRequest = GetDocumentDrawingObjectImageDataOnlineRequest;
/**
 * Request model for GetDocumentDrawingObjectOleData operation.
 * Reads OLE data of a DrawingObject from the document node.
 */
class GetDocumentDrawingObjectOleDataRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}/oleData"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentDrawingObjectOleData.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentDrawingObjectOleData.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectOleData.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectOleData.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.GetDocumentDrawingObjectOleDataRequest = GetDocumentDrawingObjectOleDataRequest;
/**
 * Request model for GetDocumentDrawingObjectOleDataOnline operation.
 * Reads OLE data of a DrawingObject from the document node.
 */
class GetDocumentDrawingObjectOleDataOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects/{index}/oleData"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentDrawingObjectOleDataOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentDrawingObjectOleDataOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectOleDataOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectOleDataOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.GetDocumentDrawingObjectOleDataOnlineRequest = GetDocumentDrawingObjectOleDataOnlineRequest;
/**
 * Request model for GetDocumentDrawingObjects operation.
 * Reads DrawingObjects from the document node.
 */
class GetDocumentDrawingObjectsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentDrawingObjects.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentDrawingObjects.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectsResponse");
    }
}
exports.GetDocumentDrawingObjectsRequest = GetDocumentDrawingObjectsRequest;
/**
 * Request model for GetDocumentDrawingObjectsOnline operation.
 * Reads DrawingObjects from the document node.
 */
class GetDocumentDrawingObjectsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentDrawingObjectsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentDrawingObjectsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectsResponse");
    }
}
exports.GetDocumentDrawingObjectsOnlineRequest = GetDocumentDrawingObjectsOnlineRequest;
/**
 * Request model for GetDocumentFieldNames operation.
 * Reads merge field names from the document.
 */
class GetDocumentFieldNamesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/mailMerge/FieldNames"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentFieldNames.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentFieldNames.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "useNonMergeFields", this.useNonMergeFields, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldNamesResponse");
    }
}
exports.GetDocumentFieldNamesRequest = GetDocumentFieldNamesRequest;
/**
 * Request model for GetDocumentFieldNamesOnline operation.
 * Reads merge field names from the document.
 */
class GetDocumentFieldNamesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/mailMerge/FieldNames"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.template' is not undefined
            if (this.template === undefined) {
                throw new Error('Required parameter "this.template" was undefined when calling getDocumentFieldNamesOnline.');
            }
            // verify required parameter 'this.template' is not null
            if (this.template === null) {
                throw new Error('Required parameter "this.template" was null when calling getDocumentFieldNamesOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "useNonMergeFields", this.useNonMergeFields, _encryptor);
            if (this.template !== undefined) {
                formParams.push(['Template', this.template, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldNamesResponse");
    }
}
exports.GetDocumentFieldNamesOnlineRequest = GetDocumentFieldNamesOnlineRequest;
/**
 * Request model for GetDocumentHyperlinkByIndex operation.
 * Reads a hyperlink from the document.
 */
class GetDocumentHyperlinkByIndexRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/hyperlinks/{hyperlinkIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "hyperlinkIndex" + "}", (this.hyperlinkIndex !== null && this.hyperlinkIndex !== undefined) ? "/" + String(this.hyperlinkIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentHyperlinkByIndex.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentHyperlinkByIndex.');
            }
            // verify required parameter 'this.hyperlinkIndex' is not undefined
            if (this.hyperlinkIndex === undefined) {
                throw new Error('Required parameter "this.hyperlinkIndex" was undefined when calling getDocumentHyperlinkByIndex.');
            }
            // verify required parameter 'this.hyperlinkIndex' is not null
            if (this.hyperlinkIndex === null) {
                throw new Error('Required parameter "this.hyperlinkIndex" was null when calling getDocumentHyperlinkByIndex.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HyperlinkResponse");
    }
}
exports.GetDocumentHyperlinkByIndexRequest = GetDocumentHyperlinkByIndexRequest;
/**
 * Request model for GetDocumentHyperlinkByIndexOnline operation.
 * Reads a hyperlink from the document.
 */
class GetDocumentHyperlinkByIndexOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/hyperlinks/{hyperlinkIndex}"
                .replace("/{" + "hyperlinkIndex" + "}", (this.hyperlinkIndex !== null && this.hyperlinkIndex !== undefined) ? "/" + String(this.hyperlinkIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentHyperlinkByIndexOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentHyperlinkByIndexOnline.');
            }
            // verify required parameter 'this.hyperlinkIndex' is not undefined
            if (this.hyperlinkIndex === undefined) {
                throw new Error('Required parameter "this.hyperlinkIndex" was undefined when calling getDocumentHyperlinkByIndexOnline.');
            }
            // verify required parameter 'this.hyperlinkIndex' is not null
            if (this.hyperlinkIndex === null) {
                throw new Error('Required parameter "this.hyperlinkIndex" was null when calling getDocumentHyperlinkByIndexOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HyperlinkResponse");
    }
}
exports.GetDocumentHyperlinkByIndexOnlineRequest = GetDocumentHyperlinkByIndexOnlineRequest;
/**
 * Request model for GetDocumentHyperlinks operation.
 * Reads hyperlinks from the document.
 */
class GetDocumentHyperlinksRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/hyperlinks"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentHyperlinks.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentHyperlinks.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HyperlinksResponse");
    }
}
exports.GetDocumentHyperlinksRequest = GetDocumentHyperlinksRequest;
/**
 * Request model for GetDocumentHyperlinksOnline operation.
 * Reads hyperlinks from the document.
 */
class GetDocumentHyperlinksOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/hyperlinks"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentHyperlinksOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentHyperlinksOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HyperlinksResponse");
    }
}
exports.GetDocumentHyperlinksOnlineRequest = GetDocumentHyperlinksOnlineRequest;
/**
 * Request model for GetDocumentProperties operation.
 * Reads document properties.
 */
class GetDocumentPropertiesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/documentProperties"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentProperties.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentProperties.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertiesResponse");
    }
}
exports.GetDocumentPropertiesRequest = GetDocumentPropertiesRequest;
/**
 * Request model for GetDocumentPropertiesOnline operation.
 * Reads document properties.
 */
class GetDocumentPropertiesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/documentProperties"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentPropertiesOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentPropertiesOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertiesResponse");
    }
}
exports.GetDocumentPropertiesOnlineRequest = GetDocumentPropertiesOnlineRequest;
/**
 * Request model for GetDocumentProperty operation.
 * Reads a document property.
 */
class GetDocumentPropertyRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/documentProperties/{propertyName}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentProperty.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentProperty.');
            }
            // verify required parameter 'this.propertyName' is not undefined
            if (this.propertyName === undefined) {
                throw new Error('Required parameter "this.propertyName" was undefined when calling getDocumentProperty.');
            }
            // verify required parameter 'this.propertyName' is not null
            if (this.propertyName === null) {
                throw new Error('Required parameter "this.propertyName" was null when calling getDocumentProperty.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertyResponse");
    }
}
exports.GetDocumentPropertyRequest = GetDocumentPropertyRequest;
/**
 * Request model for GetDocumentPropertyOnline operation.
 * Reads a document property.
 */
class GetDocumentPropertyOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/documentProperties/{propertyName}"
                .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentPropertyOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentPropertyOnline.');
            }
            // verify required parameter 'this.propertyName' is not undefined
            if (this.propertyName === undefined) {
                throw new Error('Required parameter "this.propertyName" was undefined when calling getDocumentPropertyOnline.');
            }
            // verify required parameter 'this.propertyName' is not null
            if (this.propertyName === null) {
                throw new Error('Required parameter "this.propertyName" was null when calling getDocumentPropertyOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertyResponse");
    }
}
exports.GetDocumentPropertyOnlineRequest = GetDocumentPropertyOnlineRequest;
/**
 * Request model for GetDocumentProtection operation.
 * Reads protection properties from the document.
 */
class GetDocumentProtectionRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/protection"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentProtection.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentProtection.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ProtectionDataResponse");
    }
}
exports.GetDocumentProtectionRequest = GetDocumentProtectionRequest;
/**
 * Request model for GetDocumentProtectionOnline operation.
 * Reads protection properties from the document.
 */
class GetDocumentProtectionOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/protection"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentProtectionOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentProtectionOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ProtectionDataResponse");
    }
}
exports.GetDocumentProtectionOnlineRequest = GetDocumentProtectionOnlineRequest;
/**
 * Request model for GetDocumentStatistics operation.
 * Reads document statistics.
 */
class GetDocumentStatisticsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/statistics"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentStatistics.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentStatistics.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "includeComments", this.includeComments, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "includeFootnotes", this.includeFootnotes, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "includeTextInShapes", this.includeTextInShapes, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StatDataResponse");
    }
}
exports.GetDocumentStatisticsRequest = GetDocumentStatisticsRequest;
/**
 * Request model for GetDocumentStatisticsOnline operation.
 * Reads document statistics.
 */
class GetDocumentStatisticsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/statistics"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getDocumentStatisticsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getDocumentStatisticsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "includeComments", this.includeComments, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "includeFootnotes", this.includeFootnotes, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "includeTextInShapes", this.includeTextInShapes, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StatDataResponse");
    }
}
exports.GetDocumentStatisticsOnlineRequest = GetDocumentStatisticsOnlineRequest;
/**
 * Request model for GetDocumentWithFormat operation.
 * Converts a document in cloud storage to the specified format.
 */
class GetDocumentWithFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getDocumentWithFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getDocumentWithFormat.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling getDocumentWithFormat.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling getDocumentWithFormat.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "outPath", this.outPath, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.GetDocumentWithFormatRequest = GetDocumentWithFormatRequest;
/**
 * Request model for GetField operation.
 * Reads a field from the document node.
 */
class GetFieldRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getField.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getField.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getField.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getField.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldResponse");
    }
}
exports.GetFieldRequest = GetFieldRequest;
/**
 * Request model for GetFieldOnline operation.
 * Reads a field from the document node.
 */
class GetFieldOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/fields/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getFieldOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getFieldOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getFieldOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getFieldOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldResponse");
    }
}
exports.GetFieldOnlineRequest = GetFieldOnlineRequest;
/**
 * Request model for GetFields operation.
 * Reads fields from the document node.
 */
class GetFieldsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getFields.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getFields.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldsResponse");
    }
}
exports.GetFieldsRequest = GetFieldsRequest;
/**
 * Request model for GetFieldsOnline operation.
 * Reads fields from the document node.
 */
class GetFieldsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/fields"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getFieldsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getFieldsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldsResponse");
    }
}
exports.GetFieldsOnlineRequest = GetFieldsOnlineRequest;
/**
 * Request model for GetFilesList operation.
 * Get all files and folders within a folder.
 */
class GetFilesListRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/{path}"
                .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.path' is not undefined
            if (this.path === undefined) {
                throw new Error('Required parameter "this.path" was undefined when calling getFilesList.');
            }
            // verify required parameter 'this.path' is not null
            if (this.path === null) {
                throw new Error('Required parameter "this.path" was null when calling getFilesList.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FilesList");
    }
}
exports.GetFilesListRequest = GetFilesListRequest;
/**
 * Request model for GetFootnote operation.
 * Reads a footnote from the document node.
 */
class GetFootnoteRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getFootnote.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getFootnote.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getFootnote.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getFootnote.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnoteResponse");
    }
}
exports.GetFootnoteRequest = GetFootnoteRequest;
/**
 * Request model for GetFootnoteOnline operation.
 * Reads a footnote from the document node.
 */
class GetFootnoteOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/footnotes/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getFootnoteOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getFootnoteOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getFootnoteOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getFootnoteOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnoteResponse");
    }
}
exports.GetFootnoteOnlineRequest = GetFootnoteOnlineRequest;
/**
 * Request model for GetFootnotes operation.
 * Reads footnotes from the document node.
 */
class GetFootnotesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getFootnotes.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getFootnotes.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnotesResponse");
    }
}
exports.GetFootnotesRequest = GetFootnotesRequest;
/**
 * Request model for GetFootnotesOnline operation.
 * Reads footnotes from the document node.
 */
class GetFootnotesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/footnotes"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getFootnotesOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getFootnotesOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnotesResponse");
    }
}
exports.GetFootnotesOnlineRequest = GetFootnotesOnlineRequest;
/**
 * Request model for GetFormField operation.
 * Reads a form field from the document node.
 */
class GetFormFieldRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getFormField.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getFormField.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getFormField.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getFormField.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldResponse");
    }
}
exports.GetFormFieldRequest = GetFormFieldRequest;
/**
 * Request model for GetFormFieldOnline operation.
 * Reads a form field from the document node.
 */
class GetFormFieldOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/formfields/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getFormFieldOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getFormFieldOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getFormFieldOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getFormFieldOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldResponse");
    }
}
exports.GetFormFieldOnlineRequest = GetFormFieldOnlineRequest;
/**
 * Request model for GetFormFields operation.
 * Reads form fields from the document node.
 */
class GetFormFieldsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getFormFields.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getFormFields.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldsResponse");
    }
}
exports.GetFormFieldsRequest = GetFormFieldsRequest;
/**
 * Request model for GetFormFieldsOnline operation.
 * Reads form fields from the document node.
 */
class GetFormFieldsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/formfields"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getFormFieldsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getFormFieldsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldsResponse");
    }
}
exports.GetFormFieldsOnlineRequest = GetFormFieldsOnlineRequest;
/**
 * Request model for GetHeaderFooter operation.
 * Reads a HeaderFooter object from the document.
 */
class GetHeaderFooterRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/headersfooters/{headerFooterIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "headerFooterIndex" + "}", (this.headerFooterIndex !== null && this.headerFooterIndex !== undefined) ? "/" + String(this.headerFooterIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getHeaderFooter.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getHeaderFooter.');
            }
            // verify required parameter 'this.headerFooterIndex' is not undefined
            if (this.headerFooterIndex === undefined) {
                throw new Error('Required parameter "this.headerFooterIndex" was undefined when calling getHeaderFooter.');
            }
            // verify required parameter 'this.headerFooterIndex' is not null
            if (this.headerFooterIndex === null) {
                throw new Error('Required parameter "this.headerFooterIndex" was null when calling getHeaderFooter.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
    }
}
exports.GetHeaderFooterRequest = GetHeaderFooterRequest;
/**
 * Request model for GetHeaderFooterOfSection operation.
 * Reads a HeaderFooter object from the document section.
 */
class GetHeaderFooterOfSectionRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}/headersfooters/{headerFooterIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "headerFooterIndex" + "}", (this.headerFooterIndex !== null && this.headerFooterIndex !== undefined) ? "/" + String(this.headerFooterIndex) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getHeaderFooterOfSection.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getHeaderFooterOfSection.');
            }
            // verify required parameter 'this.headerFooterIndex' is not undefined
            if (this.headerFooterIndex === undefined) {
                throw new Error('Required parameter "this.headerFooterIndex" was undefined when calling getHeaderFooterOfSection.');
            }
            // verify required parameter 'this.headerFooterIndex' is not null
            if (this.headerFooterIndex === null) {
                throw new Error('Required parameter "this.headerFooterIndex" was null when calling getHeaderFooterOfSection.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling getHeaderFooterOfSection.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling getHeaderFooterOfSection.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
    }
}
exports.GetHeaderFooterOfSectionRequest = GetHeaderFooterOfSectionRequest;
/**
 * Request model for GetHeaderFooterOfSectionOnline operation.
 * Reads a HeaderFooter object from the document section.
 */
class GetHeaderFooterOfSectionOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/sections/{sectionIndex}/headersfooters/{headerFooterIndex}"
                .replace("/{" + "headerFooterIndex" + "}", (this.headerFooterIndex !== null && this.headerFooterIndex !== undefined) ? "/" + String(this.headerFooterIndex) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getHeaderFooterOfSectionOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getHeaderFooterOfSectionOnline.');
            }
            // verify required parameter 'this.headerFooterIndex' is not undefined
            if (this.headerFooterIndex === undefined) {
                throw new Error('Required parameter "this.headerFooterIndex" was undefined when calling getHeaderFooterOfSectionOnline.');
            }
            // verify required parameter 'this.headerFooterIndex' is not null
            if (this.headerFooterIndex === null) {
                throw new Error('Required parameter "this.headerFooterIndex" was null when calling getHeaderFooterOfSectionOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling getHeaderFooterOfSectionOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling getHeaderFooterOfSectionOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
    }
}
exports.GetHeaderFooterOfSectionOnlineRequest = GetHeaderFooterOfSectionOnlineRequest;
/**
 * Request model for GetHeaderFooterOnline operation.
 * Reads a HeaderFooter object from the document.
 */
class GetHeaderFooterOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/headersfooters/{headerFooterIndex}"
                .replace("/{" + "headerFooterIndex" + "}", (this.headerFooterIndex !== null && this.headerFooterIndex !== undefined) ? "/" + String(this.headerFooterIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getHeaderFooterOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getHeaderFooterOnline.');
            }
            // verify required parameter 'this.headerFooterIndex' is not undefined
            if (this.headerFooterIndex === undefined) {
                throw new Error('Required parameter "this.headerFooterIndex" was undefined when calling getHeaderFooterOnline.');
            }
            // verify required parameter 'this.headerFooterIndex' is not null
            if (this.headerFooterIndex === null) {
                throw new Error('Required parameter "this.headerFooterIndex" was null when calling getHeaderFooterOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
    }
}
exports.GetHeaderFooterOnlineRequest = GetHeaderFooterOnlineRequest;
/**
 * Request model for GetHeaderFooters operation.
 * Reads HeaderFooter objects from the document section.
 */
class GetHeaderFootersRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{sectionPath}/headersfooters"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getHeaderFooters.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getHeaderFooters.');
            }
            // verify required parameter 'this.sectionPath' is not undefined
            if (this.sectionPath === undefined) {
                throw new Error('Required parameter "this.sectionPath" was undefined when calling getHeaderFooters.');
            }
            // verify required parameter 'this.sectionPath' is not null
            if (this.sectionPath === null) {
                throw new Error('Required parameter "this.sectionPath" was null when calling getHeaderFooters.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFootersResponse");
    }
}
exports.GetHeaderFootersRequest = GetHeaderFootersRequest;
/**
 * Request model for GetHeaderFootersOnline operation.
 * Reads HeaderFooter objects from the document section.
 */
class GetHeaderFootersOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{sectionPath}/headersfooters"
                .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getHeaderFootersOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getHeaderFootersOnline.');
            }
            // verify required parameter 'this.sectionPath' is not undefined
            if (this.sectionPath === undefined) {
                throw new Error('Required parameter "this.sectionPath" was undefined when calling getHeaderFootersOnline.');
            }
            // verify required parameter 'this.sectionPath' is not null
            if (this.sectionPath === null) {
                throw new Error('Required parameter "this.sectionPath" was null when calling getHeaderFootersOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFootersResponse");
    }
}
exports.GetHeaderFootersOnlineRequest = GetHeaderFootersOnlineRequest;
/**
 * Request model for GetInfo operation.
 * Returns application info.
 */
class GetInfoRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            const localVarPath = configuration.getApiBaseUrl() + "/words/info"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "InfoResponse");
    }
}
exports.GetInfoRequest = GetInfoRequest;
/**
 * Request model for GetList operation.
 * Reads a list from the document.
 */
class GetListRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists/{listId}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getList.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getList.');
            }
            // verify required parameter 'this.listId' is not undefined
            if (this.listId === undefined) {
                throw new Error('Required parameter "this.listId" was undefined when calling getList.');
            }
            // verify required parameter 'this.listId' is not null
            if (this.listId === null) {
                throw new Error('Required parameter "this.listId" was null when calling getList.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
    }
}
exports.GetListRequest = GetListRequest;
/**
 * Request model for GetListOnline operation.
 * Reads a list from the document.
 */
class GetListOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/lists/{listId}"
                .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getListOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getListOnline.');
            }
            // verify required parameter 'this.listId' is not undefined
            if (this.listId === undefined) {
                throw new Error('Required parameter "this.listId" was undefined when calling getListOnline.');
            }
            // verify required parameter 'this.listId' is not null
            if (this.listId === null) {
                throw new Error('Required parameter "this.listId" was null when calling getListOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
    }
}
exports.GetListOnlineRequest = GetListOnlineRequest;
/**
 * Request model for GetLists operation.
 * Reads lists from the document.
 */
class GetListsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getLists.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getLists.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListsResponse");
    }
}
exports.GetListsRequest = GetListsRequest;
/**
 * Request model for GetListsOnline operation.
 * Reads lists from the document.
 */
class GetListsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/lists"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getListsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getListsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListsResponse");
    }
}
exports.GetListsOnlineRequest = GetListsOnlineRequest;
/**
 * Request model for GetOfficeMathObject operation.
 * Reads an OfficeMath object from the document node.
 */
class GetOfficeMathObjectRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/OfficeMathObjects/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getOfficeMathObject.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getOfficeMathObject.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getOfficeMathObject.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getOfficeMathObject.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "OfficeMathObjectResponse");
    }
}
exports.GetOfficeMathObjectRequest = GetOfficeMathObjectRequest;
/**
 * Request model for GetOfficeMathObjectOnline operation.
 * Reads an OfficeMath object from the document node.
 */
class GetOfficeMathObjectOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/OfficeMathObjects/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getOfficeMathObjectOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getOfficeMathObjectOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getOfficeMathObjectOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getOfficeMathObjectOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "OfficeMathObjectResponse");
    }
}
exports.GetOfficeMathObjectOnlineRequest = GetOfficeMathObjectOnlineRequest;
/**
 * Request model for GetOfficeMathObjects operation.
 * Reads OfficeMath objects from the document node.
 */
class GetOfficeMathObjectsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/OfficeMathObjects"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getOfficeMathObjects.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getOfficeMathObjects.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "OfficeMathObjectsResponse");
    }
}
exports.GetOfficeMathObjectsRequest = GetOfficeMathObjectsRequest;
/**
 * Request model for GetOfficeMathObjectsOnline operation.
 * Reads OfficeMath objects from the document node.
 */
class GetOfficeMathObjectsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/OfficeMathObjects"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getOfficeMathObjectsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getOfficeMathObjectsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "OfficeMathObjectsResponse");
    }
}
exports.GetOfficeMathObjectsOnlineRequest = GetOfficeMathObjectsOnlineRequest;
/**
 * Request model for GetParagraph operation.
 * Reads a paragraph from the document node.
 */
class GetParagraphRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getParagraph.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getParagraph.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getParagraph.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getParagraph.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphResponse");
    }
}
exports.GetParagraphRequest = GetParagraphRequest;
/**
 * Request model for GetParagraphFormat operation.
 * Reads the formatting properties of a paragraph from the document node.
 */
class GetParagraphFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/format"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getParagraphFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getParagraphFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getParagraphFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getParagraphFormat.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphFormatResponse");
    }
}
exports.GetParagraphFormatRequest = GetParagraphFormatRequest;
/**
 * Request model for GetParagraphFormatOnline operation.
 * Reads the formatting properties of a paragraph from the document node.
 */
class GetParagraphFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}/format"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getParagraphFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getParagraphFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getParagraphFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getParagraphFormatOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphFormatResponse");
    }
}
exports.GetParagraphFormatOnlineRequest = GetParagraphFormatOnlineRequest;
/**
 * Request model for GetParagraphListFormat operation.
 * Reads the formatting properties of a paragraph list from the document node.
 */
class GetParagraphListFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/listFormat"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getParagraphListFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getParagraphListFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getParagraphListFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getParagraphListFormat.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphListFormatResponse");
    }
}
exports.GetParagraphListFormatRequest = GetParagraphListFormatRequest;
/**
 * Request model for GetParagraphListFormatOnline operation.
 * Reads the formatting properties of a paragraph list from the document node.
 */
class GetParagraphListFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}/listFormat"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getParagraphListFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getParagraphListFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getParagraphListFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getParagraphListFormatOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphListFormatResponse");
    }
}
exports.GetParagraphListFormatOnlineRequest = GetParagraphListFormatOnlineRequest;
/**
 * Request model for GetParagraphOnline operation.
 * Reads a paragraph from the document node.
 */
class GetParagraphOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getParagraphOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getParagraphOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getParagraphOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getParagraphOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphResponse");
    }
}
exports.GetParagraphOnlineRequest = GetParagraphOnlineRequest;
/**
 * Request model for GetParagraphs operation.
 * Reads paragraphs from the document node.
 */
class GetParagraphsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getParagraphs.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getParagraphs.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphLinkCollectionResponse");
    }
}
exports.GetParagraphsRequest = GetParagraphsRequest;
/**
 * Request model for GetParagraphsOnline operation.
 * Reads paragraphs from the document node.
 */
class GetParagraphsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getParagraphsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getParagraphsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphLinkCollectionResponse");
    }
}
exports.GetParagraphsOnlineRequest = GetParagraphsOnlineRequest;
/**
 * Request model for GetParagraphTabStops operation.
 * Reads paragraph tab stops from the document node.
 */
class GetParagraphTabStopsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/tabstops"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getParagraphTabStops.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getParagraphTabStops.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getParagraphTabStops.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getParagraphTabStops.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
    }
}
exports.GetParagraphTabStopsRequest = GetParagraphTabStopsRequest;
/**
 * Request model for GetParagraphTabStopsOnline operation.
 * Reads paragraph tab stops from the document node.
 */
class GetParagraphTabStopsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}/tabstops"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getParagraphTabStopsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getParagraphTabStopsOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getParagraphTabStopsOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getParagraphTabStopsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
    }
}
exports.GetParagraphTabStopsOnlineRequest = GetParagraphTabStopsOnlineRequest;
/**
 * Request model for GetPublicKey operation.
 * Get assymetric public key.
 */
class GetPublicKeyRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            const localVarPath = configuration.getApiBaseUrl() + "/words/encryption/publickey"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "PublicKeyResponse");
    }
}
exports.GetPublicKeyRequest = GetPublicKeyRequest;
/**
 * Request model for GetRangeText operation.
 * Reads range text from the document.
 */
class GetRangeTextRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
                .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getRangeText.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getRangeText.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not undefined
            if (this.rangeStartIdentifier === undefined) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling getRangeText.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not null
            if (this.rangeStartIdentifier === null) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling getRangeText.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RangeTextResponse");
    }
}
exports.GetRangeTextRequest = GetRangeTextRequest;
/**
 * Request model for GetRangeTextOnline operation.
 * Reads range text from the document.
 */
class GetRangeTextOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
                .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
                .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getRangeTextOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getRangeTextOnline.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not undefined
            if (this.rangeStartIdentifier === undefined) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling getRangeTextOnline.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not null
            if (this.rangeStartIdentifier === null) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling getRangeTextOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RangeTextResponse");
    }
}
exports.GetRangeTextOnlineRequest = GetRangeTextOnlineRequest;
/**
 * Request model for GetRun operation.
 * Reads a Run object from the paragraph.
 */
class GetRunRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getRun.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getRun.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRun.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling getRun.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getRun.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getRun.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunResponse");
    }
}
exports.GetRunRequest = GetRunRequest;
/**
 * Request model for GetRunFont operation.
 * Reads the font properties of a Run object from the paragraph.
 */
class GetRunFontRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}/font"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getRunFont.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getRunFont.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRunFont.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling getRunFont.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getRunFont.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getRunFont.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FontResponse");
    }
}
exports.GetRunFontRequest = GetRunFontRequest;
/**
 * Request model for GetRunFontOnline operation.
 * Reads the font properties of a Run object from the paragraph.
 */
class GetRunFontOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{paragraphPath}/runs/{index}/font"
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getRunFontOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getRunFontOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRunFontOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling getRunFontOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getRunFontOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getRunFontOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FontResponse");
    }
}
exports.GetRunFontOnlineRequest = GetRunFontOnlineRequest;
/**
 * Request model for GetRunOnline operation.
 * Reads a Run object from the paragraph.
 */
class GetRunOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{paragraphPath}/runs/{index}"
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getRunOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getRunOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRunOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling getRunOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getRunOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getRunOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunResponse");
    }
}
exports.GetRunOnlineRequest = GetRunOnlineRequest;
/**
 * Request model for GetRuns operation.
 * Reads Run objects from the paragraph.
 */
class GetRunsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getRuns.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getRuns.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRuns.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling getRuns.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunsResponse");
    }
}
exports.GetRunsRequest = GetRunsRequest;
/**
 * Request model for GetRunsOnline operation.
 * Reads Run objects from the paragraph.
 */
class GetRunsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{paragraphPath}/runs"
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getRunsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getRunsOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRunsOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling getRunsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunsResponse");
    }
}
exports.GetRunsOnlineRequest = GetRunsOnlineRequest;
/**
 * Request model for GetSection operation.
 * Reads a section from the document.
 */
class GetSectionRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getSection.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getSection.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling getSection.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling getSection.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionResponse");
    }
}
exports.GetSectionRequest = GetSectionRequest;
/**
 * Request model for GetSectionOnline operation.
 * Reads a section from the document.
 */
class GetSectionOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/sections/{sectionIndex}"
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getSectionOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getSectionOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling getSectionOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling getSectionOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionResponse");
    }
}
exports.GetSectionOnlineRequest = GetSectionOnlineRequest;
/**
 * Request model for GetSectionPageSetup operation.
 * Reads the page setup of a section from the document.
 */
class GetSectionPageSetupRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}/pageSetup"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getSectionPageSetup.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getSectionPageSetup.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling getSectionPageSetup.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling getSectionPageSetup.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionPageSetupResponse");
    }
}
exports.GetSectionPageSetupRequest = GetSectionPageSetupRequest;
/**
 * Request model for GetSectionPageSetupOnline operation.
 * Reads the page setup of a section from the document.
 */
class GetSectionPageSetupOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/sections/{sectionIndex}/pageSetup"
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getSectionPageSetupOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getSectionPageSetupOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling getSectionPageSetupOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling getSectionPageSetupOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionPageSetupResponse");
    }
}
exports.GetSectionPageSetupOnlineRequest = GetSectionPageSetupOnlineRequest;
/**
 * Request model for GetSections operation.
 * Reads sections from the document.
 */
class GetSectionsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getSections.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getSections.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionLinkCollectionResponse");
    }
}
exports.GetSectionsRequest = GetSectionsRequest;
/**
 * Request model for GetSectionsOnline operation.
 * Reads sections from the document.
 */
class GetSectionsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/sections"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getSectionsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getSectionsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionLinkCollectionResponse");
    }
}
exports.GetSectionsOnlineRequest = GetSectionsOnlineRequest;
/**
 * Request model for GetSignatures operation.
 * Gets signatures from the document.
 */
class GetSignaturesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/signatures"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getSignatures.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getSignatures.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SignatureCollectionResponse");
    }
}
exports.GetSignaturesRequest = GetSignaturesRequest;
/**
 * Request model for GetSignaturesOnline operation.
 * Gets signatures from the document.
 */
class GetSignaturesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/signatures"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getSignaturesOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getSignaturesOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SignatureCollectionResponse");
    }
}
exports.GetSignaturesOnlineRequest = GetSignaturesOnlineRequest;
/**
 * Request model for GetStructuredDocumentTag operation.
 * Reads a StructuredDocumentTag (SDT) from the document node.
 */
class GetStructuredDocumentTagRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getStructuredDocumentTag.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getStructuredDocumentTag.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getStructuredDocumentTag.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getStructuredDocumentTag.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagResponse");
    }
}
exports.GetStructuredDocumentTagRequest = GetStructuredDocumentTagRequest;
/**
 * Request model for GetStructuredDocumentTagOnline operation.
 * Reads a StructuredDocumentTag (SDT) from the document node.
 */
class GetStructuredDocumentTagOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/sdt/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getStructuredDocumentTagOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagResponse");
    }
}
exports.GetStructuredDocumentTagOnlineRequest = GetStructuredDocumentTagOnlineRequest;
/**
 * Request model for GetStructuredDocumentTags operation.
 * Reads StructuredDocumentTags (SDT) from the document node.
 */
class GetStructuredDocumentTagsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getStructuredDocumentTags.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getStructuredDocumentTags.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagsResponse");
    }
}
exports.GetStructuredDocumentTagsRequest = GetStructuredDocumentTagsRequest;
/**
 * Request model for GetStructuredDocumentTagsOnline operation.
 * Reads StructuredDocumentTags (SDT) from the document node.
 */
class GetStructuredDocumentTagsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/sdt"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getStructuredDocumentTagsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getStructuredDocumentTagsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagsResponse");
    }
}
exports.GetStructuredDocumentTagsOnlineRequest = GetStructuredDocumentTagsOnlineRequest;
/**
 * Request model for GetStyle operation.
 * Reads a style from the document.
 */
class GetStyleRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/{styleName}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "styleName" + "}", (this.styleName !== null && this.styleName !== undefined) ? "/" + String(this.styleName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getStyle.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getStyle.');
            }
            // verify required parameter 'this.styleName' is not undefined
            if (this.styleName === undefined) {
                throw new Error('Required parameter "this.styleName" was undefined when calling getStyle.');
            }
            // verify required parameter 'this.styleName' is not null
            if (this.styleName === null) {
                throw new Error('Required parameter "this.styleName" was null when calling getStyle.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
    }
}
exports.GetStyleRequest = GetStyleRequest;
/**
 * Request model for GetStyleFromDocumentElement operation.
 * Reads a style from the document node.
 */
class GetStyleFromDocumentElementRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{styledNodePath}/style"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "styledNodePath" + "}", (this.styledNodePath !== null && this.styledNodePath !== undefined) ? "/" + String(this.styledNodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getStyleFromDocumentElement.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getStyleFromDocumentElement.');
            }
            // verify required parameter 'this.styledNodePath' is not undefined
            if (this.styledNodePath === undefined) {
                throw new Error('Required parameter "this.styledNodePath" was undefined when calling getStyleFromDocumentElement.');
            }
            // verify required parameter 'this.styledNodePath' is not null
            if (this.styledNodePath === null) {
                throw new Error('Required parameter "this.styledNodePath" was null when calling getStyleFromDocumentElement.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
    }
}
exports.GetStyleFromDocumentElementRequest = GetStyleFromDocumentElementRequest;
/**
 * Request model for GetStyleFromDocumentElementOnline operation.
 * Reads a style from the document node.
 */
class GetStyleFromDocumentElementOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{styledNodePath}/style"
                .replace("/{" + "styledNodePath" + "}", (this.styledNodePath !== null && this.styledNodePath !== undefined) ? "/" + String(this.styledNodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getStyleFromDocumentElementOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getStyleFromDocumentElementOnline.');
            }
            // verify required parameter 'this.styledNodePath' is not undefined
            if (this.styledNodePath === undefined) {
                throw new Error('Required parameter "this.styledNodePath" was undefined when calling getStyleFromDocumentElementOnline.');
            }
            // verify required parameter 'this.styledNodePath' is not null
            if (this.styledNodePath === null) {
                throw new Error('Required parameter "this.styledNodePath" was null when calling getStyleFromDocumentElementOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
    }
}
exports.GetStyleFromDocumentElementOnlineRequest = GetStyleFromDocumentElementOnlineRequest;
/**
 * Request model for GetStyleOnline operation.
 * Reads a style from the document.
 */
class GetStyleOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/styles/{styleName}"
                .replace("/{" + "styleName" + "}", (this.styleName !== null && this.styleName !== undefined) ? "/" + String(this.styleName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getStyleOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getStyleOnline.');
            }
            // verify required parameter 'this.styleName' is not undefined
            if (this.styleName === undefined) {
                throw new Error('Required parameter "this.styleName" was undefined when calling getStyleOnline.');
            }
            // verify required parameter 'this.styleName' is not null
            if (this.styleName === null) {
                throw new Error('Required parameter "this.styleName" was null when calling getStyleOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
    }
}
exports.GetStyleOnlineRequest = GetStyleOnlineRequest;
/**
 * Request model for GetStyles operation.
 * Reads styles from the document.
 */
class GetStylesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getStyles.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getStyles.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StylesResponse");
    }
}
exports.GetStylesRequest = GetStylesRequest;
/**
 * Request model for GetStylesOnline operation.
 * Reads styles from the document.
 */
class GetStylesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/styles"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getStylesOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getStylesOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StylesResponse");
    }
}
exports.GetStylesOnlineRequest = GetStylesOnlineRequest;
/**
 * Request model for GetTable operation.
 * Reads a table from the document node.
 */
class GetTableRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getTable.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getTable.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTable.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTable.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableResponse");
    }
}
exports.GetTableRequest = GetTableRequest;
/**
 * Request model for GetTableCell operation.
 * Reads a cell from the table row.
 */
class GetTableCellRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getTableCell.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getTableCell.');
            }
            // verify required parameter 'this.tableRowPath' is not undefined
            if (this.tableRowPath === undefined) {
                throw new Error('Required parameter "this.tableRowPath" was undefined when calling getTableCell.');
            }
            // verify required parameter 'this.tableRowPath' is not null
            if (this.tableRowPath === null) {
                throw new Error('Required parameter "this.tableRowPath" was null when calling getTableCell.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableCell.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableCell.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellResponse");
    }
}
exports.GetTableCellRequest = GetTableCellRequest;
/**
 * Request model for GetTableCellFormat operation.
 * Reads the formatting properties of a table cell.
 */
class GetTableCellFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells/{index}/cellformat"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getTableCellFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getTableCellFormat.');
            }
            // verify required parameter 'this.tableRowPath' is not undefined
            if (this.tableRowPath === undefined) {
                throw new Error('Required parameter "this.tableRowPath" was undefined when calling getTableCellFormat.');
            }
            // verify required parameter 'this.tableRowPath' is not null
            if (this.tableRowPath === null) {
                throw new Error('Required parameter "this.tableRowPath" was null when calling getTableCellFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableCellFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableCellFormat.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellFormatResponse");
    }
}
exports.GetTableCellFormatRequest = GetTableCellFormatRequest;
/**
 * Request model for GetTableCellFormatOnline operation.
 * Reads the formatting properties of a table cell.
 */
class GetTableCellFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{tableRowPath}/cells/{index}/cellformat"
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getTableCellFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getTableCellFormatOnline.');
            }
            // verify required parameter 'this.tableRowPath' is not undefined
            if (this.tableRowPath === undefined) {
                throw new Error('Required parameter "this.tableRowPath" was undefined when calling getTableCellFormatOnline.');
            }
            // verify required parameter 'this.tableRowPath' is not null
            if (this.tableRowPath === null) {
                throw new Error('Required parameter "this.tableRowPath" was null when calling getTableCellFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableCellFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableCellFormatOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellFormatResponse");
    }
}
exports.GetTableCellFormatOnlineRequest = GetTableCellFormatOnlineRequest;
/**
 * Request model for GetTableCellOnline operation.
 * Reads a cell from the table row.
 */
class GetTableCellOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{tableRowPath}/cells/{index}"
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getTableCellOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getTableCellOnline.');
            }
            // verify required parameter 'this.tableRowPath' is not undefined
            if (this.tableRowPath === undefined) {
                throw new Error('Required parameter "this.tableRowPath" was undefined when calling getTableCellOnline.');
            }
            // verify required parameter 'this.tableRowPath' is not null
            if (this.tableRowPath === null) {
                throw new Error('Required parameter "this.tableRowPath" was null when calling getTableCellOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableCellOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableCellOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellResponse");
    }
}
exports.GetTableCellOnlineRequest = GetTableCellOnlineRequest;
/**
 * Request model for GetTableOnline operation.
 * Reads a table from the document node.
 */
class GetTableOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/tables/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getTableOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getTableOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableResponse");
    }
}
exports.GetTableOnlineRequest = GetTableOnlineRequest;
/**
 * Request model for GetTableProperties operation.
 * Reads properties of a table from the document node.
 */
class GetTablePropertiesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}/properties"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getTableProperties.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getTableProperties.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableProperties.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableProperties.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TablePropertiesResponse");
    }
}
exports.GetTablePropertiesRequest = GetTablePropertiesRequest;
/**
 * Request model for GetTablePropertiesOnline operation.
 * Reads properties of a table from the document node.
 */
class GetTablePropertiesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/tables/{index}/properties"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getTablePropertiesOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getTablePropertiesOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTablePropertiesOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTablePropertiesOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TablePropertiesResponse");
    }
}
exports.GetTablePropertiesOnlineRequest = GetTablePropertiesOnlineRequest;
/**
 * Request model for GetTableRow operation.
 * Reads a row from the table.
 */
class GetTableRowRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tablePath}/rows/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getTableRow.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getTableRow.');
            }
            // verify required parameter 'this.tablePath' is not undefined
            if (this.tablePath === undefined) {
                throw new Error('Required parameter "this.tablePath" was undefined when calling getTableRow.');
            }
            // verify required parameter 'this.tablePath' is not null
            if (this.tablePath === null) {
                throw new Error('Required parameter "this.tablePath" was null when calling getTableRow.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableRow.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableRow.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowResponse");
    }
}
exports.GetTableRowRequest = GetTableRowRequest;
/**
 * Request model for GetTableRowFormat operation.
 * Reads the formatting properties of a table row.
 */
class GetTableRowFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tablePath}/rows/{index}/rowformat"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getTableRowFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getTableRowFormat.');
            }
            // verify required parameter 'this.tablePath' is not undefined
            if (this.tablePath === undefined) {
                throw new Error('Required parameter "this.tablePath" was undefined when calling getTableRowFormat.');
            }
            // verify required parameter 'this.tablePath' is not null
            if (this.tablePath === null) {
                throw new Error('Required parameter "this.tablePath" was null when calling getTableRowFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableRowFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableRowFormat.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowFormatResponse");
    }
}
exports.GetTableRowFormatRequest = GetTableRowFormatRequest;
/**
 * Request model for GetTableRowFormatOnline operation.
 * Reads the formatting properties of a table row.
 */
class GetTableRowFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{tablePath}/rows/{index}/rowformat"
                .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getTableRowFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getTableRowFormatOnline.');
            }
            // verify required parameter 'this.tablePath' is not undefined
            if (this.tablePath === undefined) {
                throw new Error('Required parameter "this.tablePath" was undefined when calling getTableRowFormatOnline.');
            }
            // verify required parameter 'this.tablePath' is not null
            if (this.tablePath === null) {
                throw new Error('Required parameter "this.tablePath" was null when calling getTableRowFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableRowFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableRowFormatOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowFormatResponse");
    }
}
exports.GetTableRowFormatOnlineRequest = GetTableRowFormatOnlineRequest;
/**
 * Request model for GetTableRowOnline operation.
 * Reads a row from the table.
 */
class GetTableRowOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{tablePath}/rows/{index}"
                .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getTableRowOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getTableRowOnline.');
            }
            // verify required parameter 'this.tablePath' is not undefined
            if (this.tablePath === undefined) {
                throw new Error('Required parameter "this.tablePath" was undefined when calling getTableRowOnline.');
            }
            // verify required parameter 'this.tablePath' is not null
            if (this.tablePath === null) {
                throw new Error('Required parameter "this.tablePath" was null when calling getTableRowOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling getTableRowOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling getTableRowOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowResponse");
    }
}
exports.GetTableRowOnlineRequest = GetTableRowOnlineRequest;
/**
 * Request model for GetTables operation.
 * Reads tables from the document node.
 */
class GetTablesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling getTables.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling getTables.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableLinkCollectionResponse");
    }
}
exports.GetTablesRequest = GetTablesRequest;
/**
 * Request model for GetTablesOnline operation.
 * Reads tables from the document node.
 */
class GetTablesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/tables"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling getTablesOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling getTablesOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableLinkCollectionResponse");
    }
}
exports.GetTablesOnlineRequest = GetTablesOnlineRequest;
/**
 * Request model for InsertBookmark operation.
 * Inserts a new bookmark to the document.
 */
class InsertBookmarkRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertBookmark.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertBookmark.');
            }
            // verify required parameter 'this.bookmark' is not undefined
            if (this.bookmark === undefined) {
                throw new Error('Required parameter "this.bookmark" was undefined when calling insertBookmark.');
            }
            // verify required parameter 'this.bookmark' is not null
            if (this.bookmark === null) {
                throw new Error('Required parameter "this.bookmark" was null when calling insertBookmark.');
            }
            (_a = this.bookmark) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.bookmark !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.bookmark, this.bookmark.constructor.name === "Object" ? "importedBookmarkInsert.BookmarkInsert" : this.bookmark.constructor.name);
                formParams.push(['Bookmark', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarkResponse");
    }
}
exports.InsertBookmarkRequest = InsertBookmarkRequest;
/**
 * Request model for InsertBookmarkOnline operation.
 * Inserts a new bookmark to the document.
 */
class InsertBookmarkOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/bookmarks"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertBookmarkOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertBookmarkOnline.');
            }
            // verify required parameter 'this.bookmark' is not undefined
            if (this.bookmark === undefined) {
                throw new Error('Required parameter "this.bookmark" was undefined when calling insertBookmarkOnline.');
            }
            // verify required parameter 'this.bookmark' is not null
            if (this.bookmark === null) {
                throw new Error('Required parameter "this.bookmark" was null when calling insertBookmarkOnline.');
            }
            (_a = this.bookmark) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.bookmark !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.bookmark, this.bookmark.constructor.name === "Object" ? "importedBookmarkInsert.BookmarkInsert" : this.bookmark.constructor.name);
                formParams.push(['Bookmark', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertBookmarkOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "BookmarkResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertBookmarkOnlineRequest = InsertBookmarkOnlineRequest;
/**
 * Request model for InsertComment operation.
 * Inserts a new comment to the document.
 */
class InsertCommentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertComment.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertComment.');
            }
            // verify required parameter 'this.comment' is not undefined
            if (this.comment === undefined) {
                throw new Error('Required parameter "this.comment" was undefined when calling insertComment.');
            }
            // verify required parameter 'this.comment' is not null
            if (this.comment === null) {
                throw new Error('Required parameter "this.comment" was null when calling insertComment.');
            }
            (_a = this.comment) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.comment !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.comment, this.comment.constructor.name === "Object" ? "importedCommentInsert.CommentInsert" : this.comment.constructor.name);
                formParams.push(['Comment', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentResponse");
    }
}
exports.InsertCommentRequest = InsertCommentRequest;
/**
 * Request model for InsertCommentOnline operation.
 * Inserts a new comment to the document.
 */
class InsertCommentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/comments"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertCommentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertCommentOnline.');
            }
            // verify required parameter 'this.comment' is not undefined
            if (this.comment === undefined) {
                throw new Error('Required parameter "this.comment" was undefined when calling insertCommentOnline.');
            }
            // verify required parameter 'this.comment' is not null
            if (this.comment === null) {
                throw new Error('Required parameter "this.comment" was null when calling insertCommentOnline.');
            }
            (_a = this.comment) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.comment !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.comment, this.comment.constructor.name === "Object" ? "importedCommentInsert.CommentInsert" : this.comment.constructor.name);
                formParams.push(['Comment', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertCommentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "CommentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertCommentOnlineRequest = InsertCommentOnlineRequest;
/**
 * Request model for InsertCustomXmlPart operation.
 * Inserts a new custom xml part to the document.
 */
class InsertCustomXmlPartRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertCustomXmlPart.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPart' is not undefined
            if (this.customXmlPart === undefined) {
                throw new Error('Required parameter "this.customXmlPart" was undefined when calling insertCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPart' is not null
            if (this.customXmlPart === null) {
                throw new Error('Required parameter "this.customXmlPart" was null when calling insertCustomXmlPart.');
            }
            (_a = this.customXmlPart) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.customXmlPart !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.customXmlPart, this.customXmlPart.constructor.name === "Object" ? "importedCustomXmlPartInsert.CustomXmlPartInsert" : this.customXmlPart.constructor.name);
                formParams.push(['CustomXmlPart', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartResponse");
    }
}
exports.InsertCustomXmlPartRequest = InsertCustomXmlPartRequest;
/**
 * Request model for InsertCustomXmlPartOnline operation.
 * Inserts a new custom xml part to the document.
 */
class InsertCustomXmlPartOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/customXmlParts"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertCustomXmlPartOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPart' is not undefined
            if (this.customXmlPart === undefined) {
                throw new Error('Required parameter "this.customXmlPart" was undefined when calling insertCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPart' is not null
            if (this.customXmlPart === null) {
                throw new Error('Required parameter "this.customXmlPart" was null when calling insertCustomXmlPartOnline.');
            }
            (_a = this.customXmlPart) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.customXmlPart !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.customXmlPart, this.customXmlPart.constructor.name === "Object" ? "importedCustomXmlPartInsert.CustomXmlPartInsert" : this.customXmlPart.constructor.name);
                formParams.push(['CustomXmlPart', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertCustomXmlPartOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "CustomXmlPartResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertCustomXmlPartOnlineRequest = InsertCustomXmlPartOnlineRequest;
/**
 * Request model for InsertDrawingObject operation.
 * Inserts a new DrawingObject to the document node.
 */
class InsertDrawingObjectRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertDrawingObject.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertDrawingObject.');
            }
            // verify required parameter 'this.drawingObject' is not undefined
            if (this.drawingObject === undefined) {
                throw new Error('Required parameter "this.drawingObject" was undefined when calling insertDrawingObject.');
            }
            // verify required parameter 'this.drawingObject' is not null
            if (this.drawingObject === null) {
                throw new Error('Required parameter "this.drawingObject" was null when calling insertDrawingObject.');
            }
            // verify required parameter 'this.imageFile' is not undefined
            if (this.imageFile === undefined) {
                throw new Error('Required parameter "this.imageFile" was undefined when calling insertDrawingObject.');
            }
            // verify required parameter 'this.imageFile' is not null
            if (this.imageFile === null) {
                throw new Error('Required parameter "this.imageFile" was null when calling insertDrawingObject.');
            }
            (_a = this.drawingObject) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.drawingObject !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.drawingObject, this.drawingObject.constructor.name === "Object" ? "importedDrawingObjectInsert.DrawingObjectInsert" : this.drawingObject.constructor.name);
                formParams.push(['DrawingObject', JSON.stringify(_obj), 'application/json']);
            }
            if (this.imageFile !== undefined) {
                formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectResponse");
    }
}
exports.InsertDrawingObjectRequest = InsertDrawingObjectRequest;
/**
 * Request model for InsertDrawingObjectOnline operation.
 * Inserts a new DrawingObject to the document node.
 */
class InsertDrawingObjectOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/drawingObjects"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertDrawingObjectOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertDrawingObjectOnline.');
            }
            // verify required parameter 'this.drawingObject' is not undefined
            if (this.drawingObject === undefined) {
                throw new Error('Required parameter "this.drawingObject" was undefined when calling insertDrawingObjectOnline.');
            }
            // verify required parameter 'this.drawingObject' is not null
            if (this.drawingObject === null) {
                throw new Error('Required parameter "this.drawingObject" was null when calling insertDrawingObjectOnline.');
            }
            // verify required parameter 'this.imageFile' is not undefined
            if (this.imageFile === undefined) {
                throw new Error('Required parameter "this.imageFile" was undefined when calling insertDrawingObjectOnline.');
            }
            // verify required parameter 'this.imageFile' is not null
            if (this.imageFile === null) {
                throw new Error('Required parameter "this.imageFile" was null when calling insertDrawingObjectOnline.');
            }
            (_a = this.drawingObject) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.drawingObject !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.drawingObject, this.drawingObject.constructor.name === "Object" ? "importedDrawingObjectInsert.DrawingObjectInsert" : this.drawingObject.constructor.name);
                formParams.push(['DrawingObject', JSON.stringify(_obj), 'application/json']);
            }
            if (this.imageFile !== undefined) {
                formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertDrawingObjectOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DrawingObjectResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertDrawingObjectOnlineRequest = InsertDrawingObjectOnlineRequest;
/**
 * Request model for InsertField operation.
 * Inserts a new field to the document node.
 */
class InsertFieldRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertField.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertField.');
            }
            // verify required parameter 'this.field' is not undefined
            if (this.field === undefined) {
                throw new Error('Required parameter "this.field" was undefined when calling insertField.');
            }
            // verify required parameter 'this.field' is not null
            if (this.field === null) {
                throw new Error('Required parameter "this.field" was null when calling insertField.');
            }
            (_a = this.field) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.field !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.field, this.field.constructor.name === "Object" ? "importedFieldInsert.FieldInsert" : this.field.constructor.name);
                formParams.push(['Field', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldResponse");
    }
}
exports.InsertFieldRequest = InsertFieldRequest;
/**
 * Request model for InsertFieldOnline operation.
 * Inserts a new field to the document node.
 */
class InsertFieldOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/fields"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertFieldOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertFieldOnline.');
            }
            // verify required parameter 'this.field' is not undefined
            if (this.field === undefined) {
                throw new Error('Required parameter "this.field" was undefined when calling insertFieldOnline.');
            }
            // verify required parameter 'this.field' is not null
            if (this.field === null) {
                throw new Error('Required parameter "this.field" was null when calling insertFieldOnline.');
            }
            (_a = this.field) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.field !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.field, this.field.constructor.name === "Object" ? "importedFieldInsert.FieldInsert" : this.field.constructor.name);
                formParams.push(['Field', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertFieldOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "FieldResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertFieldOnlineRequest = InsertFieldOnlineRequest;
/**
 * Request model for InsertFootnote operation.
 * Inserts a new footnote to the document node.
 */
class InsertFootnoteRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertFootnote.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertFootnote.');
            }
            // verify required parameter 'this.footnoteDto' is not undefined
            if (this.footnoteDto === undefined) {
                throw new Error('Required parameter "this.footnoteDto" was undefined when calling insertFootnote.');
            }
            // verify required parameter 'this.footnoteDto' is not null
            if (this.footnoteDto === null) {
                throw new Error('Required parameter "this.footnoteDto" was null when calling insertFootnote.');
            }
            (_a = this.footnoteDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.footnoteDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.footnoteDto, this.footnoteDto.constructor.name === "Object" ? "importedFootnoteInsert.FootnoteInsert" : this.footnoteDto.constructor.name);
                formParams.push(['FootnoteDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnoteResponse");
    }
}
exports.InsertFootnoteRequest = InsertFootnoteRequest;
/**
 * Request model for InsertFootnoteOnline operation.
 * Inserts a new footnote to the document node.
 */
class InsertFootnoteOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/footnotes"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertFootnoteOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertFootnoteOnline.');
            }
            // verify required parameter 'this.footnoteDto' is not undefined
            if (this.footnoteDto === undefined) {
                throw new Error('Required parameter "this.footnoteDto" was undefined when calling insertFootnoteOnline.');
            }
            // verify required parameter 'this.footnoteDto' is not null
            if (this.footnoteDto === null) {
                throw new Error('Required parameter "this.footnoteDto" was null when calling insertFootnoteOnline.');
            }
            (_a = this.footnoteDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.footnoteDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.footnoteDto, this.footnoteDto.constructor.name === "Object" ? "importedFootnoteInsert.FootnoteInsert" : this.footnoteDto.constructor.name);
                formParams.push(['FootnoteDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertFootnoteOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "FootnoteResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertFootnoteOnlineRequest = InsertFootnoteOnlineRequest;
/**
 * Request model for InsertFormField operation.
 * Inserts a new form field to the document node.
 */
class InsertFormFieldRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertFormField.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertFormField.');
            }
            // verify required parameter 'this.formField' is not undefined
            if (this.formField === undefined) {
                throw new Error('Required parameter "this.formField" was undefined when calling insertFormField.');
            }
            // verify required parameter 'this.formField' is not null
            if (this.formField === null) {
                throw new Error('Required parameter "this.formField" was null when calling insertFormField.');
            }
            (_a = this.formField) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "insertBeforeNode", this.insertBeforeNode, _encryptor);
            if (this.formField !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.formField, this.formField.constructor.name === "Object" ? "importedFormField.FormField" : this.formField.constructor.name);
                formParams.push(['FormField', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldResponse");
    }
}
exports.InsertFormFieldRequest = InsertFormFieldRequest;
/**
 * Request model for InsertFormFieldOnline operation.
 * Inserts a new form field to the document node.
 */
class InsertFormFieldOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/formfields"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertFormFieldOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertFormFieldOnline.');
            }
            // verify required parameter 'this.formField' is not undefined
            if (this.formField === undefined) {
                throw new Error('Required parameter "this.formField" was undefined when calling insertFormFieldOnline.');
            }
            // verify required parameter 'this.formField' is not null
            if (this.formField === null) {
                throw new Error('Required parameter "this.formField" was null when calling insertFormFieldOnline.');
            }
            (_a = this.formField) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "insertBeforeNode", this.insertBeforeNode, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.formField !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.formField, this.formField.constructor.name === "Object" ? "importedFormField.FormField" : this.formField.constructor.name);
                formParams.push(['FormField', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertFormFieldOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "FormFieldResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertFormFieldOnlineRequest = InsertFormFieldOnlineRequest;
/**
 * Request model for InsertHeaderFooter operation.
 * Inserts a new HeaderFooter object to the document section.
 */
class InsertHeaderFooterRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{sectionPath}/headersfooters"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertHeaderFooter.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertHeaderFooter.');
            }
            // verify required parameter 'this.sectionPath' is not undefined
            if (this.sectionPath === undefined) {
                throw new Error('Required parameter "this.sectionPath" was undefined when calling insertHeaderFooter.');
            }
            // verify required parameter 'this.sectionPath' is not null
            if (this.sectionPath === null) {
                throw new Error('Required parameter "this.sectionPath" was null when calling insertHeaderFooter.');
            }
            // verify required parameter 'this.headerFooterType' is not undefined
            if (this.headerFooterType === undefined) {
                throw new Error('Required parameter "this.headerFooterType" was undefined when calling insertHeaderFooter.');
            }
            // verify required parameter 'this.headerFooterType' is not null
            if (this.headerFooterType === null) {
                throw new Error('Required parameter "this.headerFooterType" was null when calling insertHeaderFooter.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.headerFooterType !== undefined) {
                formParams.push(['HeaderFooterType', this.headerFooterType, 'text/plain']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
    }
}
exports.InsertHeaderFooterRequest = InsertHeaderFooterRequest;
/**
 * Request model for InsertHeaderFooterOnline operation.
 * Inserts a new HeaderFooter object to the document section.
 */
class InsertHeaderFooterOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{sectionPath}/headersfooters"
                .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertHeaderFooterOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertHeaderFooterOnline.');
            }
            // verify required parameter 'this.sectionPath' is not undefined
            if (this.sectionPath === undefined) {
                throw new Error('Required parameter "this.sectionPath" was undefined when calling insertHeaderFooterOnline.');
            }
            // verify required parameter 'this.sectionPath' is not null
            if (this.sectionPath === null) {
                throw new Error('Required parameter "this.sectionPath" was null when calling insertHeaderFooterOnline.');
            }
            // verify required parameter 'this.headerFooterType' is not undefined
            if (this.headerFooterType === undefined) {
                throw new Error('Required parameter "this.headerFooterType" was undefined when calling insertHeaderFooterOnline.');
            }
            // verify required parameter 'this.headerFooterType' is not null
            if (this.headerFooterType === null) {
                throw new Error('Required parameter "this.headerFooterType" was null when calling insertHeaderFooterOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.headerFooterType !== undefined) {
                formParams.push(['HeaderFooterType', this.headerFooterType, 'text/plain']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertHeaderFooterOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "HeaderFooterResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertHeaderFooterOnlineRequest = InsertHeaderFooterOnlineRequest;
/**
 * Request model for InsertList operation.
 * Inserts a new list to the document.
 */
class InsertListRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertList.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertList.');
            }
            // verify required parameter 'this.listInsert' is not undefined
            if (this.listInsert === undefined) {
                throw new Error('Required parameter "this.listInsert" was undefined when calling insertList.');
            }
            // verify required parameter 'this.listInsert' is not null
            if (this.listInsert === null) {
                throw new Error('Required parameter "this.listInsert" was null when calling insertList.');
            }
            (_a = this.listInsert) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.listInsert !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.listInsert, this.listInsert.constructor.name === "Object" ? "importedListInsert.ListInsert" : this.listInsert.constructor.name);
                formParams.push(['ListInsert', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
    }
}
exports.InsertListRequest = InsertListRequest;
/**
 * Request model for InsertListOnline operation.
 * Inserts a new list to the document.
 */
class InsertListOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/lists"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertListOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertListOnline.');
            }
            // verify required parameter 'this.listInsert' is not undefined
            if (this.listInsert === undefined) {
                throw new Error('Required parameter "this.listInsert" was undefined when calling insertListOnline.');
            }
            // verify required parameter 'this.listInsert' is not null
            if (this.listInsert === null) {
                throw new Error('Required parameter "this.listInsert" was null when calling insertListOnline.');
            }
            (_a = this.listInsert) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.listInsert !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.listInsert, this.listInsert.constructor.name === "Object" ? "importedListInsert.ListInsert" : this.listInsert.constructor.name);
                formParams.push(['ListInsert', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertListOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ListResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertListOnlineRequest = InsertListOnlineRequest;
/**
 * Request model for InsertOrUpdateParagraphTabStop operation.
 * Inserts a new or updates an existing paragraph tab stop in the document node.
 */
class InsertOrUpdateParagraphTabStopRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/tabstops"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertOrUpdateParagraphTabStop.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertOrUpdateParagraphTabStop.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling insertOrUpdateParagraphTabStop.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling insertOrUpdateParagraphTabStop.');
            }
            // verify required parameter 'this.tabStopInsertDto' is not undefined
            if (this.tabStopInsertDto === undefined) {
                throw new Error('Required parameter "this.tabStopInsertDto" was undefined when calling insertOrUpdateParagraphTabStop.');
            }
            // verify required parameter 'this.tabStopInsertDto' is not null
            if (this.tabStopInsertDto === null) {
                throw new Error('Required parameter "this.tabStopInsertDto" was null when calling insertOrUpdateParagraphTabStop.');
            }
            (_a = this.tabStopInsertDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.tabStopInsertDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.tabStopInsertDto, this.tabStopInsertDto.constructor.name === "Object" ? "importedTabStopInsert.TabStopInsert" : this.tabStopInsertDto.constructor.name);
                formParams.push(['TabStopInsertDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
    }
}
exports.InsertOrUpdateParagraphTabStopRequest = InsertOrUpdateParagraphTabStopRequest;
/**
 * Request model for InsertOrUpdateParagraphTabStopOnline operation.
 * Inserts a new or updates an existing paragraph tab stop in the document node.
 */
class InsertOrUpdateParagraphTabStopOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/paragraphs/{index}/tabstops"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertOrUpdateParagraphTabStopOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertOrUpdateParagraphTabStopOnline.');
            }
            // verify required parameter 'this.tabStopInsertDto' is not undefined
            if (this.tabStopInsertDto === undefined) {
                throw new Error('Required parameter "this.tabStopInsertDto" was undefined when calling insertOrUpdateParagraphTabStopOnline.');
            }
            // verify required parameter 'this.tabStopInsertDto' is not null
            if (this.tabStopInsertDto === null) {
                throw new Error('Required parameter "this.tabStopInsertDto" was null when calling insertOrUpdateParagraphTabStopOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling insertOrUpdateParagraphTabStopOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling insertOrUpdateParagraphTabStopOnline.');
            }
            (_a = this.tabStopInsertDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.tabStopInsertDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.tabStopInsertDto, this.tabStopInsertDto.constructor.name === "Object" ? "importedTabStopInsert.TabStopInsert" : this.tabStopInsertDto.constructor.name);
                formParams.push(['TabStopInsertDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertOrUpdateParagraphTabStopOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TabStopsResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertOrUpdateParagraphTabStopOnlineRequest = InsertOrUpdateParagraphTabStopOnlineRequest;
/**
 * Request model for InsertPageNumbers operation.
 * Inserts page numbers to the document.
 */
class InsertPageNumbersRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/PageNumbers"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertPageNumbers.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertPageNumbers.');
            }
            // verify required parameter 'this.pageNumber' is not undefined
            if (this.pageNumber === undefined) {
                throw new Error('Required parameter "this.pageNumber" was undefined when calling insertPageNumbers.');
            }
            // verify required parameter 'this.pageNumber' is not null
            if (this.pageNumber === null) {
                throw new Error('Required parameter "this.pageNumber" was null when calling insertPageNumbers.');
            }
            (_a = this.pageNumber) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.pageNumber !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.pageNumber, this.pageNumber.constructor.name === "Object" ? "importedPageNumber.PageNumber" : this.pageNumber.constructor.name);
                formParams.push(['PageNumber', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.InsertPageNumbersRequest = InsertPageNumbersRequest;
/**
 * Request model for InsertPageNumbersOnline operation.
 * Inserts page numbers to the document.
 */
class InsertPageNumbersOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/PageNumbers"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertPageNumbersOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertPageNumbersOnline.');
            }
            // verify required parameter 'this.pageNumber' is not undefined
            if (this.pageNumber === undefined) {
                throw new Error('Required parameter "this.pageNumber" was undefined when calling insertPageNumbersOnline.');
            }
            // verify required parameter 'this.pageNumber' is not null
            if (this.pageNumber === null) {
                throw new Error('Required parameter "this.pageNumber" was null when calling insertPageNumbersOnline.');
            }
            (_a = this.pageNumber) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.pageNumber !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.pageNumber, this.pageNumber.constructor.name === "Object" ? "importedPageNumber.PageNumber" : this.pageNumber.constructor.name);
                formParams.push(['PageNumber', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertPageNumbersOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertPageNumbersOnlineRequest = InsertPageNumbersOnlineRequest;
/**
 * Request model for InsertParagraph operation.
 * Inserts a new paragraph to the document node.
 */
class InsertParagraphRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertParagraph.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertParagraph.');
            }
            // verify required parameter 'this.paragraph' is not undefined
            if (this.paragraph === undefined) {
                throw new Error('Required parameter "this.paragraph" was undefined when calling insertParagraph.');
            }
            // verify required parameter 'this.paragraph' is not null
            if (this.paragraph === null) {
                throw new Error('Required parameter "this.paragraph" was null when calling insertParagraph.');
            }
            (_a = this.paragraph) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.paragraph !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.paragraph, this.paragraph.constructor.name === "Object" ? "importedParagraphInsert.ParagraphInsert" : this.paragraph.constructor.name);
                formParams.push(['Paragraph', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphResponse");
    }
}
exports.InsertParagraphRequest = InsertParagraphRequest;
/**
 * Request model for InsertParagraphOnline operation.
 * Inserts a new paragraph to the document node.
 */
class InsertParagraphOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/paragraphs"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertParagraphOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertParagraphOnline.');
            }
            // verify required parameter 'this.paragraph' is not undefined
            if (this.paragraph === undefined) {
                throw new Error('Required parameter "this.paragraph" was undefined when calling insertParagraphOnline.');
            }
            // verify required parameter 'this.paragraph' is not null
            if (this.paragraph === null) {
                throw new Error('Required parameter "this.paragraph" was null when calling insertParagraphOnline.');
            }
            (_a = this.paragraph) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.paragraph !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.paragraph, this.paragraph.constructor.name === "Object" ? "importedParagraphInsert.ParagraphInsert" : this.paragraph.constructor.name);
                formParams.push(['Paragraph', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertParagraphOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ParagraphResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertParagraphOnlineRequest = InsertParagraphOnlineRequest;
/**
 * Request model for InsertRun operation.
 * Inserts a new Run object to the paragraph.
 */
class InsertRunRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertRun.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertRun.');
            }
            // verify required parameter 'this.run' is not undefined
            if (this.run === undefined) {
                throw new Error('Required parameter "this.run" was undefined when calling insertRun.');
            }
            // verify required parameter 'this.run' is not null
            if (this.run === null) {
                throw new Error('Required parameter "this.run" was null when calling insertRun.');
            }
            (_a = this.run) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.run !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.run, this.run.constructor.name === "Object" ? "importedRunInsert.RunInsert" : this.run.constructor.name);
                formParams.push(['Run', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunResponse");
    }
}
exports.InsertRunRequest = InsertRunRequest;
/**
 * Request model for InsertRunOnline operation.
 * Inserts a new Run object to the paragraph.
 */
class InsertRunOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{paragraphPath}/runs"
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertRunOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertRunOnline.');
            }
            // verify required parameter 'this.run' is not undefined
            if (this.run === undefined) {
                throw new Error('Required parameter "this.run" was undefined when calling insertRunOnline.');
            }
            // verify required parameter 'this.run' is not null
            if (this.run === null) {
                throw new Error('Required parameter "this.run" was null when calling insertRunOnline.');
            }
            (_a = this.run) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.run !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.run, this.run.constructor.name === "Object" ? "importedRunInsert.RunInsert" : this.run.constructor.name);
                formParams.push(['Run', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertRunOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "RunResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertRunOnlineRequest = InsertRunOnlineRequest;
/**
 * Request model for InsertSection operation.
 * Inserts a section to the document.
 */
class InsertSectionRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertSection.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertSection.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling insertSection.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling insertSection.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.InsertSectionRequest = InsertSectionRequest;
/**
 * Request model for InsertSectionOnline operation.
 * Inserts a section to the document.
 */
class InsertSectionOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/sections/{sectionIndex}"
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertSectionOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertSectionOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling insertSectionOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling insertSectionOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.InsertSectionOnlineRequest = InsertSectionOnlineRequest;
/**
 * Request model for InsertStructuredDocumentTag operation.
 * Inserts a new StructuredDocumentTag (SDT) to the document node.
 */
class InsertStructuredDocumentTagRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertStructuredDocumentTag.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertStructuredDocumentTag.');
            }
            // verify required parameter 'this.structuredDocumentTag' is not undefined
            if (this.structuredDocumentTag === undefined) {
                throw new Error('Required parameter "this.structuredDocumentTag" was undefined when calling insertStructuredDocumentTag.');
            }
            // verify required parameter 'this.structuredDocumentTag' is not null
            if (this.structuredDocumentTag === null) {
                throw new Error('Required parameter "this.structuredDocumentTag" was null when calling insertStructuredDocumentTag.');
            }
            (_a = this.structuredDocumentTag) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.structuredDocumentTag !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.structuredDocumentTag, this.structuredDocumentTag.constructor.name === "Object" ? "importedStructuredDocumentTagInsert.StructuredDocumentTagInsert" : this.structuredDocumentTag.constructor.name);
                formParams.push(['StructuredDocumentTag', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagResponse");
    }
}
exports.InsertStructuredDocumentTagRequest = InsertStructuredDocumentTagRequest;
/**
 * Request model for InsertStructuredDocumentTagOnline operation.
 * Inserts a new StructuredDocumentTag (SDT) to the document node.
 */
class InsertStructuredDocumentTagOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/sdt"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.structuredDocumentTag' is not undefined
            if (this.structuredDocumentTag === undefined) {
                throw new Error('Required parameter "this.structuredDocumentTag" was undefined when calling insertStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.structuredDocumentTag' is not null
            if (this.structuredDocumentTag === null) {
                throw new Error('Required parameter "this.structuredDocumentTag" was null when calling insertStructuredDocumentTagOnline.');
            }
            (_a = this.structuredDocumentTag) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.structuredDocumentTag !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.structuredDocumentTag, this.structuredDocumentTag.constructor.name === "Object" ? "importedStructuredDocumentTagInsert.StructuredDocumentTagInsert" : this.structuredDocumentTag.constructor.name);
                formParams.push(['StructuredDocumentTag', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertStructuredDocumentTagOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "StructuredDocumentTagResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertStructuredDocumentTagOnlineRequest = InsertStructuredDocumentTagOnlineRequest;
/**
 * Request model for InsertStyle operation.
 * Inserts a new style to the document.
 */
class InsertStyleRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/insert"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertStyle.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertStyle.');
            }
            // verify required parameter 'this.styleInsert' is not undefined
            if (this.styleInsert === undefined) {
                throw new Error('Required parameter "this.styleInsert" was undefined when calling insertStyle.');
            }
            // verify required parameter 'this.styleInsert' is not null
            if (this.styleInsert === null) {
                throw new Error('Required parameter "this.styleInsert" was null when calling insertStyle.');
            }
            (_a = this.styleInsert) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.styleInsert !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.styleInsert, this.styleInsert.constructor.name === "Object" ? "importedStyleInsert.StyleInsert" : this.styleInsert.constructor.name);
                formParams.push(['StyleInsert', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
    }
}
exports.InsertStyleRequest = InsertStyleRequest;
/**
 * Request model for InsertStyleOnline operation.
 * Inserts a new style to the document.
 */
class InsertStyleOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/styles/insert"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertStyleOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertStyleOnline.');
            }
            // verify required parameter 'this.styleInsert' is not undefined
            if (this.styleInsert === undefined) {
                throw new Error('Required parameter "this.styleInsert" was undefined when calling insertStyleOnline.');
            }
            // verify required parameter 'this.styleInsert' is not null
            if (this.styleInsert === null) {
                throw new Error('Required parameter "this.styleInsert" was null when calling insertStyleOnline.');
            }
            (_a = this.styleInsert) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.styleInsert !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.styleInsert, this.styleInsert.constructor.name === "Object" ? "importedStyleInsert.StyleInsert" : this.styleInsert.constructor.name);
                formParams.push(['StyleInsert', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertStyleOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "StyleResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertStyleOnlineRequest = InsertStyleOnlineRequest;
/**
 * Request model for InsertTable operation.
 * Inserts a new table to the document node.
 */
class InsertTableRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertTable.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertTable.');
            }
            // verify required parameter 'this.table' is not undefined
            if (this.table === undefined) {
                throw new Error('Required parameter "this.table" was undefined when calling insertTable.');
            }
            // verify required parameter 'this.table' is not null
            if (this.table === null) {
                throw new Error('Required parameter "this.table" was null when calling insertTable.');
            }
            (_a = this.table) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.table !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.table, this.table.constructor.name === "Object" ? "importedTableInsert.TableInsert" : this.table.constructor.name);
                formParams.push(['Table', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableResponse");
    }
}
exports.InsertTableRequest = InsertTableRequest;
/**
 * Request model for InsertTableCell operation.
 * Inserts a new cell to the table row.
 */
class InsertTableCellRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertTableCell.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertTableCell.');
            }
            // verify required parameter 'this.cell' is not undefined
            if (this.cell === undefined) {
                throw new Error('Required parameter "this.cell" was undefined when calling insertTableCell.');
            }
            // verify required parameter 'this.cell' is not null
            if (this.cell === null) {
                throw new Error('Required parameter "this.cell" was null when calling insertTableCell.');
            }
            (_a = this.cell) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.cell !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.cell, this.cell.constructor.name === "Object" ? "importedTableCellInsert.TableCellInsert" : this.cell.constructor.name);
                formParams.push(['Cell', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellResponse");
    }
}
exports.InsertTableCellRequest = InsertTableCellRequest;
/**
 * Request model for InsertTableCellOnline operation.
 * Inserts a new cell to the table row.
 */
class InsertTableCellOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{tableRowPath}/cells"
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertTableCellOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertTableCellOnline.');
            }
            // verify required parameter 'this.cell' is not undefined
            if (this.cell === undefined) {
                throw new Error('Required parameter "this.cell" was undefined when calling insertTableCellOnline.');
            }
            // verify required parameter 'this.cell' is not null
            if (this.cell === null) {
                throw new Error('Required parameter "this.cell" was null when calling insertTableCellOnline.');
            }
            (_a = this.cell) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.cell !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.cell, this.cell.constructor.name === "Object" ? "importedTableCellInsert.TableCellInsert" : this.cell.constructor.name);
                formParams.push(['Cell', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertTableCellOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TableCellResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertTableCellOnlineRequest = InsertTableCellOnlineRequest;
/**
 * Request model for InsertTableOnline operation.
 * Inserts a new table to the document node.
 */
class InsertTableOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/tables"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertTableOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertTableOnline.');
            }
            // verify required parameter 'this.table' is not undefined
            if (this.table === undefined) {
                throw new Error('Required parameter "this.table" was undefined when calling insertTableOnline.');
            }
            // verify required parameter 'this.table' is not null
            if (this.table === null) {
                throw new Error('Required parameter "this.table" was null when calling insertTableOnline.');
            }
            (_a = this.table) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.table !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.table, this.table.constructor.name === "Object" ? "importedTableInsert.TableInsert" : this.table.constructor.name);
                formParams.push(['Table', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertTableOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TableResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertTableOnlineRequest = InsertTableOnlineRequest;
/**
 * Request model for InsertTableRow operation.
 * Inserts a new row to the table.
 */
class InsertTableRowRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/rows"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertTableRow.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertTableRow.');
            }
            // verify required parameter 'this.row' is not undefined
            if (this.row === undefined) {
                throw new Error('Required parameter "this.row" was undefined when calling insertTableRow.');
            }
            // verify required parameter 'this.row' is not null
            if (this.row === null) {
                throw new Error('Required parameter "this.row" was null when calling insertTableRow.');
            }
            (_a = this.row) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.row !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.row, this.row.constructor.name === "Object" ? "importedTableRowInsert.TableRowInsert" : this.row.constructor.name);
                formParams.push(['Row', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowResponse");
    }
}
exports.InsertTableRowRequest = InsertTableRowRequest;
/**
 * Request model for InsertTableRowOnline operation.
 * Inserts a new row to the table.
 */
class InsertTableRowOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/rows"
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertTableRowOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertTableRowOnline.');
            }
            // verify required parameter 'this.row' is not undefined
            if (this.row === undefined) {
                throw new Error('Required parameter "this.row" was undefined when calling insertTableRowOnline.');
            }
            // verify required parameter 'this.row' is not null
            if (this.row === null) {
                throw new Error('Required parameter "this.row" was null when calling insertTableRowOnline.');
            }
            (_a = this.row) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.row !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.row, this.row.constructor.name === "Object" ? "importedTableRowInsert.TableRowInsert" : this.row.constructor.name);
                formParams.push(['Row', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertTableRowOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TableRowResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertTableRowOnlineRequest = InsertTableRowOnlineRequest;
/**
 * Request model for InsertWatermark operation.
 * Insert a watermark to the document.
 */
class InsertWatermarkRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/watermarks/insert"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertWatermark.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertWatermark.');
            }
            // verify required parameter 'this.watermarkData' is not undefined
            if (this.watermarkData === undefined) {
                throw new Error('Required parameter "this.watermarkData" was undefined when calling insertWatermark.');
            }
            // verify required parameter 'this.watermarkData' is not null
            if (this.watermarkData === null) {
                throw new Error('Required parameter "this.watermarkData" was null when calling insertWatermark.');
            }
            (_a = this.watermarkData) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.watermarkData !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.watermarkData, this.watermarkData.constructor.name === "Object" ? "importedWatermarkDataBase.WatermarkDataBase" : this.watermarkData.constructor.name);
                formParams.push(['WatermarkData', JSON.stringify(_obj), 'application/json']);
                this.watermarkData.collectFilesContent(filesContent);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.InsertWatermarkRequest = InsertWatermarkRequest;
/**
 * Request model for InsertWatermarkImage operation.
 * Inserts a new watermark image to the document.
 */
class InsertWatermarkImageRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/watermarks/images"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertWatermarkImage.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertWatermarkImage.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "rotationAngle", this.rotationAngle, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "image", this.image, _encryptor);
            if (this.imageFile !== undefined) {
                formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.InsertWatermarkImageRequest = InsertWatermarkImageRequest;
/**
 * Request model for InsertWatermarkImageOnline operation.
 * Inserts a new watermark image to the document.
 */
class InsertWatermarkImageOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/watermarks/images"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertWatermarkImageOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertWatermarkImageOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "rotationAngle", this.rotationAngle, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "image", this.image, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.imageFile !== undefined) {
                formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertWatermarkImageOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertWatermarkImageOnlineRequest = InsertWatermarkImageOnlineRequest;
/**
 * Request model for InsertWatermarkOnline operation.
 * Insert a watermark to the document.
 */
class InsertWatermarkOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/watermarks/insert"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertWatermarkOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertWatermarkOnline.');
            }
            // verify required parameter 'this.watermarkData' is not undefined
            if (this.watermarkData === undefined) {
                throw new Error('Required parameter "this.watermarkData" was undefined when calling insertWatermarkOnline.');
            }
            // verify required parameter 'this.watermarkData' is not null
            if (this.watermarkData === null) {
                throw new Error('Required parameter "this.watermarkData" was null when calling insertWatermarkOnline.');
            }
            (_a = this.watermarkData) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.watermarkData !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.watermarkData, this.watermarkData.constructor.name === "Object" ? "importedWatermarkDataBase.WatermarkDataBase" : this.watermarkData.constructor.name);
                formParams.push(['WatermarkData', JSON.stringify(_obj), 'application/json']);
                this.watermarkData.collectFilesContent(filesContent);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertWatermarkOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertWatermarkOnlineRequest = InsertWatermarkOnlineRequest;
/**
 * Request model for InsertWatermarkText operation.
 * Inserts a new watermark text to the document.
 */
class InsertWatermarkTextRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/watermarks/texts"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling insertWatermarkText.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling insertWatermarkText.');
            }
            // verify required parameter 'this.watermarkText' is not undefined
            if (this.watermarkText === undefined) {
                throw new Error('Required parameter "this.watermarkText" was undefined when calling insertWatermarkText.');
            }
            // verify required parameter 'this.watermarkText' is not null
            if (this.watermarkText === null) {
                throw new Error('Required parameter "this.watermarkText" was null when calling insertWatermarkText.');
            }
            (_a = this.watermarkText) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.watermarkText !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.watermarkText, this.watermarkText.constructor.name === "Object" ? "importedWatermarkText.WatermarkText" : this.watermarkText.constructor.name);
                formParams.push(['WatermarkText', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.InsertWatermarkTextRequest = InsertWatermarkTextRequest;
/**
 * Request model for InsertWatermarkTextOnline operation.
 * Inserts a new watermark text to the document.
 */
class InsertWatermarkTextOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/watermarks/texts"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling insertWatermarkTextOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling insertWatermarkTextOnline.');
            }
            // verify required parameter 'this.watermarkText' is not undefined
            if (this.watermarkText === undefined) {
                throw new Error('Required parameter "this.watermarkText" was undefined when calling insertWatermarkTextOnline.');
            }
            // verify required parameter 'this.watermarkText' is not null
            if (this.watermarkText === null) {
                throw new Error('Required parameter "this.watermarkText" was null when calling insertWatermarkTextOnline.');
            }
            (_a = this.watermarkText) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.watermarkText !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.watermarkText, this.watermarkText.constructor.name === "Object" ? "importedWatermarkText.WatermarkText" : this.watermarkText.constructor.name);
                formParams.push(['WatermarkText', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new InsertWatermarkTextOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.InsertWatermarkTextOnlineRequest = InsertWatermarkTextOnlineRequest;
/**
 * Request model for LinkHeaderFootersToPrevious operation.
 * Links headers / footers of the section to the previous one.
 */
class LinkHeaderFootersToPreviousRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}/link"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling linkHeaderFootersToPrevious.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling linkHeaderFootersToPrevious.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling linkHeaderFootersToPrevious.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling linkHeaderFootersToPrevious.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "mode", this.mode, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.LinkHeaderFootersToPreviousRequest = LinkHeaderFootersToPreviousRequest;
/**
 * Request model for LoadWebDocument operation.
 * Downloads a document from the Web using URL and saves it to cloud storage in the specified format.
 */
class LoadWebDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/loadWebDocument"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.data' is not undefined
            if (this.data === undefined) {
                throw new Error('Required parameter "this.data" was undefined when calling loadWebDocument.');
            }
            // verify required parameter 'this.data' is not null
            if (this.data === null) {
                throw new Error('Required parameter "this.data" was null when calling loadWebDocument.');
            }
            (_a = this.data) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            if (this.data !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.data, this.data.constructor.name === "Object" ? "importedLoadWebDocumentData.LoadWebDocumentData" : this.data.constructor.name);
                formParams.push(['Data', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SaveResponse");
    }
}
exports.LoadWebDocumentRequest = LoadWebDocumentRequest;
/**
 * Request model for MergeWithNext operation.
 * Merge the section with the next one.
 */
class MergeWithNextRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/merge/sections/{sectionIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling mergeWithNext.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling mergeWithNext.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling mergeWithNext.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling mergeWithNext.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.MergeWithNextRequest = MergeWithNextRequest;
/**
 * Request model for MergeWithNextOnline operation.
 * Merge the section with the next one.
 */
class MergeWithNextOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/merge/sections/{sectionIndex}"
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling mergeWithNextOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling mergeWithNextOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling mergeWithNextOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling mergeWithNextOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.MergeWithNextOnlineRequest = MergeWithNextOnlineRequest;
/**
 * Request model for MoveFile operation.
 * Move file.
 */
class MoveFileRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/move/{srcPath}"
                .replace("/{" + "srcPath" + "}", (this.srcPath !== null && this.srcPath !== undefined) ? "/" + String(this.srcPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.destPath' is not undefined
            if (this.destPath === undefined) {
                throw new Error('Required parameter "this.destPath" was undefined when calling moveFile.');
            }
            // verify required parameter 'this.destPath' is not null
            if (this.destPath === null) {
                throw new Error('Required parameter "this.destPath" was null when calling moveFile.');
            }
            // verify required parameter 'this.srcPath' is not undefined
            if (this.srcPath === undefined) {
                throw new Error('Required parameter "this.srcPath" was undefined when calling moveFile.');
            }
            // verify required parameter 'this.srcPath' is not null
            if (this.srcPath === null) {
                throw new Error('Required parameter "this.srcPath" was null when calling moveFile.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destPath", this.destPath, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "srcStorageName", this.srcStorageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destStorageName", this.destStorageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "versionId", this.versionId, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.MoveFileRequest = MoveFileRequest;
/**
 * Request model for MoveFolder operation.
 * Move folder.
 */
class MoveFolderRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/move/{srcPath}"
                .replace("/{" + "srcPath" + "}", (this.srcPath !== null && this.srcPath !== undefined) ? "/" + String(this.srcPath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.destPath' is not undefined
            if (this.destPath === undefined) {
                throw new Error('Required parameter "this.destPath" was undefined when calling moveFolder.');
            }
            // verify required parameter 'this.destPath' is not null
            if (this.destPath === null) {
                throw new Error('Required parameter "this.destPath" was null when calling moveFolder.');
            }
            // verify required parameter 'this.srcPath' is not undefined
            if (this.srcPath === undefined) {
                throw new Error('Required parameter "this.srcPath" was undefined when calling moveFolder.');
            }
            // verify required parameter 'this.srcPath' is not null
            if (this.srcPath === null) {
                throw new Error('Required parameter "this.srcPath" was null when calling moveFolder.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destPath", this.destPath, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "srcStorageName", this.srcStorageName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destStorageName", this.destStorageName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.MoveFolderRequest = MoveFolderRequest;
/**
 * Request model for OptimizeDocument operation.
 * Applies document content optimization options, specific to a particular versions of Microsoft Word.
 */
class OptimizeDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/compatibility/optimize"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling optimizeDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling optimizeDocument.');
            }
            // verify required parameter 'this.options' is not undefined
            if (this.options === undefined) {
                throw new Error('Required parameter "this.options" was undefined when calling optimizeDocument.');
            }
            // verify required parameter 'this.options' is not null
            if (this.options === null) {
                throw new Error('Required parameter "this.options" was null when calling optimizeDocument.');
            }
            (_a = this.options) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.options !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.options, this.options.constructor.name === "Object" ? "importedOptimizationOptions.OptimizationOptions" : this.options.constructor.name);
                formParams.push(['Options', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.OptimizeDocumentRequest = OptimizeDocumentRequest;
/**
 * Request model for OptimizeDocumentOnline operation.
 * Applies document content optimization options, specific to a particular versions of Microsoft Word.
 */
class OptimizeDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/compatibility/optimize"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling optimizeDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling optimizeDocumentOnline.');
            }
            // verify required parameter 'this.options' is not undefined
            if (this.options === undefined) {
                throw new Error('Required parameter "this.options" was undefined when calling optimizeDocumentOnline.');
            }
            // verify required parameter 'this.options' is not null
            if (this.options === null) {
                throw new Error('Required parameter "this.options" was null when calling optimizeDocumentOnline.');
            }
            (_a = this.options) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.options !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.options, this.options.constructor.name === "Object" ? "importedOptimizationOptions.OptimizationOptions" : this.options.constructor.name);
                formParams.push(['Options', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return (0, requestHelper_1.parseFilesCollection)(_response, _headers);
    }
}
exports.OptimizeDocumentOnlineRequest = OptimizeDocumentOnlineRequest;
/**
 * Request model for ProtectDocument operation.
 * Changes the document protection. The previous protection will be overwritten if it exist.
 */
class ProtectDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/protection"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling protectDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling protectDocument.');
            }
            // verify required parameter 'this.protectionRequest' is not undefined
            if (this.protectionRequest === undefined) {
                throw new Error('Required parameter "this.protectionRequest" was undefined when calling protectDocument.');
            }
            // verify required parameter 'this.protectionRequest' is not null
            if (this.protectionRequest === null) {
                throw new Error('Required parameter "this.protectionRequest" was null when calling protectDocument.');
            }
            (_a = this.protectionRequest) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.protectionRequest !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.protectionRequest, this.protectionRequest.constructor.name === "Object" ? "importedProtectionRequestBase.ProtectionRequestBase" : this.protectionRequest.constructor.name);
                formParams.push(['ProtectionRequest', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ProtectionDataResponse");
    }
}
exports.ProtectDocumentRequest = ProtectDocumentRequest;
/**
 * Request model for ProtectDocumentOnline operation.
 * Changes the document protection. The previous protection will be overwritten if it exist.
 */
class ProtectDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/protection"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling protectDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling protectDocumentOnline.');
            }
            // verify required parameter 'this.protectionRequest' is not undefined
            if (this.protectionRequest === undefined) {
                throw new Error('Required parameter "this.protectionRequest" was undefined when calling protectDocumentOnline.');
            }
            // verify required parameter 'this.protectionRequest' is not null
            if (this.protectionRequest === null) {
                throw new Error('Required parameter "this.protectionRequest" was null when calling protectDocumentOnline.');
            }
            (_a = this.protectionRequest) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.protectionRequest !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.protectionRequest, this.protectionRequest.constructor.name === "Object" ? "importedProtectionRequestBase.ProtectionRequestBase" : this.protectionRequest.constructor.name);
                formParams.push(['ProtectionRequest', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new ProtectDocumentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ProtectionDataResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.ProtectDocumentOnlineRequest = ProtectDocumentOnlineRequest;
/**
 * Request model for RejectAllRevisions operation.
 * Rejects all revisions in the document.
 */
class RejectAllRevisionsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/revisions/rejectAll"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling rejectAllRevisions.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling rejectAllRevisions.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RevisionsModificationResponse");
    }
}
exports.RejectAllRevisionsRequest = RejectAllRevisionsRequest;
/**
 * Request model for RejectAllRevisionsOnline operation.
 * Rejects all revisions in the document.
 */
class RejectAllRevisionsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/revisions/rejectAll"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling rejectAllRevisionsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling rejectAllRevisionsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new RejectAllRevisionsOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "RevisionsModificationResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.RejectAllRevisionsOnlineRequest = RejectAllRevisionsOnlineRequest;
/**
 * Request model for RemoveAllSignatures operation.
 * Removes all signatures of the document.
 */
class RemoveAllSignaturesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/signatures"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling removeAllSignatures.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling removeAllSignatures.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SignatureCollectionResponse");
    }
}
exports.RemoveAllSignaturesRequest = RemoveAllSignaturesRequest;
/**
 * Request model for RemoveAllSignaturesOnline operation.
 * Removes all signatures of the document.
 */
class RemoveAllSignaturesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/signatures"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling removeAllSignaturesOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling removeAllSignaturesOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new RemoveAllSignaturesOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "SignatureCollectionResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.RemoveAllSignaturesOnlineRequest = RemoveAllSignaturesOnlineRequest;
/**
 * Request model for RemoveRange operation.
 * Removes a range from the document.
 */
class RemoveRangeRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
                .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling removeRange.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling removeRange.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not undefined
            if (this.rangeStartIdentifier === undefined) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling removeRange.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not null
            if (this.rangeStartIdentifier === null) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling removeRange.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.RemoveRangeRequest = RemoveRangeRequest;
/**
 * Request model for RemoveRangeOnline operation.
 * Removes a range from the document.
 */
class RemoveRangeOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
                .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
                .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling removeRangeOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling removeRangeOnline.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not undefined
            if (this.rangeStartIdentifier === undefined) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling removeRangeOnline.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not null
            if (this.rangeStartIdentifier === null) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling removeRangeOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new RemoveRangeOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.RemoveRangeOnlineRequest = RemoveRangeOnlineRequest;
/**
 * Request model for RenderDrawingObject operation.
 * Renders a DrawingObject to the specified format.
 */
class RenderDrawingObjectRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}/render"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling renderDrawingObject.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling renderDrawingObject.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderDrawingObject.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderDrawingObject.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling renderDrawingObject.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling renderDrawingObject.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderDrawingObjectRequest = RenderDrawingObjectRequest;
/**
 * Request model for RenderDrawingObjectOnline operation.
 * Renders a DrawingObject to the specified format.
 */
class RenderDrawingObjectOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects/{index}/render"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling renderDrawingObjectOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling renderDrawingObjectOnline.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderDrawingObjectOnline.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderDrawingObjectOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling renderDrawingObjectOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling renderDrawingObjectOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderDrawingObjectOnlineRequest = RenderDrawingObjectOnlineRequest;
/**
 * Request model for RenderMathObject operation.
 * Renders an OfficeMath object to the specified format.
 */
class RenderMathObjectRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/OfficeMathObjects/{index}/render"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling renderMathObject.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling renderMathObject.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderMathObject.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderMathObject.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling renderMathObject.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling renderMathObject.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderMathObjectRequest = RenderMathObjectRequest;
/**
 * Request model for RenderMathObjectOnline operation.
 * Renders an OfficeMath object to the specified format.
 */
class RenderMathObjectOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/OfficeMathObjects/{index}/render"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling renderMathObjectOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling renderMathObjectOnline.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderMathObjectOnline.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderMathObjectOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling renderMathObjectOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling renderMathObjectOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderMathObjectOnlineRequest = RenderMathObjectOnlineRequest;
/**
 * Request model for RenderPage operation.
 * Renders a page to the specified format.
 */
class RenderPageRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/pages/{pageIndex}/render"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "pageIndex" + "}", (this.pageIndex !== null && this.pageIndex !== undefined) ? "/" + String(this.pageIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling renderPage.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling renderPage.');
            }
            // verify required parameter 'this.pageIndex' is not undefined
            if (this.pageIndex === undefined) {
                throw new Error('Required parameter "this.pageIndex" was undefined when calling renderPage.');
            }
            // verify required parameter 'this.pageIndex' is not null
            if (this.pageIndex === null) {
                throw new Error('Required parameter "this.pageIndex" was null when calling renderPage.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderPage.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderPage.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderPageRequest = RenderPageRequest;
/**
 * Request model for RenderPageOnline operation.
 * Renders a page to the specified format.
 */
class RenderPageOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/pages/{pageIndex}/render"
                .replace("/{" + "pageIndex" + "}", (this.pageIndex !== null && this.pageIndex !== undefined) ? "/" + String(this.pageIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling renderPageOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling renderPageOnline.');
            }
            // verify required parameter 'this.pageIndex' is not undefined
            if (this.pageIndex === undefined) {
                throw new Error('Required parameter "this.pageIndex" was undefined when calling renderPageOnline.');
            }
            // verify required parameter 'this.pageIndex' is not null
            if (this.pageIndex === null) {
                throw new Error('Required parameter "this.pageIndex" was null when calling renderPageOnline.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderPageOnline.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderPageOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderPageOnlineRequest = RenderPageOnlineRequest;
/**
 * Request model for RenderParagraph operation.
 * Renders a paragraph to the specified format.
 */
class RenderParagraphRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/render"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling renderParagraph.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling renderParagraph.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderParagraph.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderParagraph.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling renderParagraph.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling renderParagraph.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderParagraphRequest = RenderParagraphRequest;
/**
 * Request model for RenderParagraphOnline operation.
 * Renders a paragraph to the specified format.
 */
class RenderParagraphOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}/render"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling renderParagraphOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling renderParagraphOnline.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderParagraphOnline.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderParagraphOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling renderParagraphOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling renderParagraphOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderParagraphOnlineRequest = RenderParagraphOnlineRequest;
/**
 * Request model for RenderTable operation.
 * Renders a table to the specified format.
 */
class RenderTableRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}/render"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling renderTable.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling renderTable.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderTable.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderTable.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling renderTable.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling renderTable.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderTableRequest = RenderTableRequest;
/**
 * Request model for RenderTableOnline operation.
 * Renders a table to the specified format.
 */
class RenderTableOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/tables/{index}/render"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling renderTableOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling renderTableOnline.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling renderTableOnline.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling renderTableOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling renderTableOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling renderTableOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return _response;
    }
}
exports.RenderTableOnlineRequest = RenderTableOnlineRequest;
/**
 * Request model for ReplaceText operation.
 * Replaces text in the document.
 */
class ReplaceTextRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/replaceText"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling replaceText.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling replaceText.');
            }
            // verify required parameter 'this.replaceText' is not undefined
            if (this.replaceText === undefined) {
                throw new Error('Required parameter "this.replaceText" was undefined when calling replaceText.');
            }
            // verify required parameter 'this.replaceText' is not null
            if (this.replaceText === null) {
                throw new Error('Required parameter "this.replaceText" was null when calling replaceText.');
            }
            (_a = this.replaceText) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.replaceText !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.replaceText, this.replaceText.constructor.name === "Object" ? "importedReplaceTextParameters.ReplaceTextParameters" : this.replaceText.constructor.name);
                formParams.push(['ReplaceText', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ReplaceTextResponse");
    }
}
exports.ReplaceTextRequest = ReplaceTextRequest;
/**
 * Request model for ReplaceTextOnline operation.
 * Replaces text in the document.
 */
class ReplaceTextOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/replaceText"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling replaceTextOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling replaceTextOnline.');
            }
            // verify required parameter 'this.replaceText' is not undefined
            if (this.replaceText === undefined) {
                throw new Error('Required parameter "this.replaceText" was undefined when calling replaceTextOnline.');
            }
            // verify required parameter 'this.replaceText' is not null
            if (this.replaceText === null) {
                throw new Error('Required parameter "this.replaceText" was null when calling replaceTextOnline.');
            }
            (_a = this.replaceText) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.replaceText !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.replaceText, this.replaceText.constructor.name === "Object" ? "importedReplaceTextParameters.ReplaceTextParameters" : this.replaceText.constructor.name);
                formParams.push(['ReplaceText', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new ReplaceTextOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ReplaceTextResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.ReplaceTextOnlineRequest = ReplaceTextOnlineRequest;
/**
 * Request model for ReplaceWithText operation.
 * Replaces a range with text in the document.
 */
class ReplaceWithTextRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
                .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling replaceWithText.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling replaceWithText.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not undefined
            if (this.rangeStartIdentifier === undefined) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling replaceWithText.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not null
            if (this.rangeStartIdentifier === null) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling replaceWithText.');
            }
            // verify required parameter 'this.rangeText' is not undefined
            if (this.rangeText === undefined) {
                throw new Error('Required parameter "this.rangeText" was undefined when calling replaceWithText.');
            }
            // verify required parameter 'this.rangeText' is not null
            if (this.rangeText === null) {
                throw new Error('Required parameter "this.rangeText" was null when calling replaceWithText.');
            }
            (_a = this.rangeText) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.rangeText !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.rangeText, this.rangeText.constructor.name === "Object" ? "importedReplaceRange.ReplaceRange" : this.rangeText.constructor.name);
                formParams.push(['RangeText', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.ReplaceWithTextRequest = ReplaceWithTextRequest;
/**
 * Request model for ReplaceWithTextOnline operation.
 * Replaces a range with text in the document.
 */
class ReplaceWithTextOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
                .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
                .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling replaceWithTextOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling replaceWithTextOnline.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not undefined
            if (this.rangeStartIdentifier === undefined) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling replaceWithTextOnline.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not null
            if (this.rangeStartIdentifier === null) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling replaceWithTextOnline.');
            }
            // verify required parameter 'this.rangeText' is not undefined
            if (this.rangeText === undefined) {
                throw new Error('Required parameter "this.rangeText" was undefined when calling replaceWithTextOnline.');
            }
            // verify required parameter 'this.rangeText' is not null
            if (this.rangeText === null) {
                throw new Error('Required parameter "this.rangeText" was null when calling replaceWithTextOnline.');
            }
            (_a = this.rangeText) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.rangeText !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.rangeText, this.rangeText.constructor.name === "Object" ? "importedReplaceRange.ReplaceRange" : this.rangeText.constructor.name);
                formParams.push(['RangeText', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new ReplaceWithTextOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.ReplaceWithTextOnlineRequest = ReplaceWithTextOnlineRequest;
/**
 * Request model for ResetCache operation.
 * Clears the font cache.
 */
class ResetCacheRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            const localVarPath = configuration.getApiBaseUrl() + "/words/fonts/cache"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return null;
    }
}
exports.ResetCacheRequest = ResetCacheRequest;
/**
 * Request model for SaveAs operation.
 * Converts a document in cloud storage to the specified format.
 */
class SaveAsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/saveAs"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling saveAs.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling saveAs.');
            }
            // verify required parameter 'this.saveOptionsData' is not undefined
            if (this.saveOptionsData === undefined) {
                throw new Error('Required parameter "this.saveOptionsData" was undefined when calling saveAs.');
            }
            // verify required parameter 'this.saveOptionsData' is not null
            if (this.saveOptionsData === null) {
                throw new Error('Required parameter "this.saveOptionsData" was null when calling saveAs.');
            }
            (_a = this.saveOptionsData) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.saveOptionsData !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.saveOptionsData, this.saveOptionsData.constructor.name === "Object" ? "importedSaveOptionsData.SaveOptionsData" : this.saveOptionsData.constructor.name);
                formParams.push(['SaveOptionsData', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SaveResponse");
    }
}
exports.SaveAsRequest = SaveAsRequest;
/**
 * Request model for SaveAsOnline operation.
 * Converts a document in cloud storage to the specified format.
 */
class SaveAsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/saveAs"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling saveAsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling saveAsOnline.');
            }
            // verify required parameter 'this.saveOptionsData' is not undefined
            if (this.saveOptionsData === undefined) {
                throw new Error('Required parameter "this.saveOptionsData" was undefined when calling saveAsOnline.');
            }
            // verify required parameter 'this.saveOptionsData' is not null
            if (this.saveOptionsData === null) {
                throw new Error('Required parameter "this.saveOptionsData" was null when calling saveAsOnline.');
            }
            (_a = this.saveOptionsData) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.saveOptionsData !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.saveOptionsData, this.saveOptionsData.constructor.name === "Object" ? "importedSaveOptionsData.SaveOptionsData" : this.saveOptionsData.constructor.name);
                formParams.push(['SaveOptionsData', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new SaveAsOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "SaveResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.SaveAsOnlineRequest = SaveAsOnlineRequest;
/**
 * Request model for SaveAsRange operation.
 * Saves a range as a new document.
 */
class SaveAsRangeRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/range/{rangeStartIdentifier}/{rangeEndIdentifier}/SaveAs"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
                .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling saveAsRange.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling saveAsRange.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not undefined
            if (this.rangeStartIdentifier === undefined) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling saveAsRange.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not null
            if (this.rangeStartIdentifier === null) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling saveAsRange.');
            }
            // verify required parameter 'this.documentParameters' is not undefined
            if (this.documentParameters === undefined) {
                throw new Error('Required parameter "this.documentParameters" was undefined when calling saveAsRange.');
            }
            // verify required parameter 'this.documentParameters' is not null
            if (this.documentParameters === null) {
                throw new Error('Required parameter "this.documentParameters" was null when calling saveAsRange.');
            }
            (_a = this.documentParameters) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.documentParameters !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.documentParameters, this.documentParameters.constructor.name === "Object" ? "importedRangeDocument.RangeDocument" : this.documentParameters.constructor.name);
                formParams.push(['DocumentParameters', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.SaveAsRangeRequest = SaveAsRangeRequest;
/**
 * Request model for SaveAsRangeOnline operation.
 * Saves a range as a new document.
 */
class SaveAsRangeOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/range/{rangeStartIdentifier}/{rangeEndIdentifier}/SaveAs"
                .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
                .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling saveAsRangeOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling saveAsRangeOnline.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not undefined
            if (this.rangeStartIdentifier === undefined) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling saveAsRangeOnline.');
            }
            // verify required parameter 'this.rangeStartIdentifier' is not null
            if (this.rangeStartIdentifier === null) {
                throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling saveAsRangeOnline.');
            }
            // verify required parameter 'this.documentParameters' is not undefined
            if (this.documentParameters === undefined) {
                throw new Error('Required parameter "this.documentParameters" was undefined when calling saveAsRangeOnline.');
            }
            // verify required parameter 'this.documentParameters' is not null
            if (this.documentParameters === null) {
                throw new Error('Required parameter "this.documentParameters" was null when calling saveAsRangeOnline.');
            }
            (_a = this.documentParameters) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.documentParameters !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.documentParameters, this.documentParameters.constructor.name === "Object" ? "importedRangeDocument.RangeDocument" : this.documentParameters.constructor.name);
                formParams.push(['DocumentParameters', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new SaveAsRangeOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.SaveAsRangeOnlineRequest = SaveAsRangeOnlineRequest;
/**
 * Request model for SaveAsTiff operation.
 * Converts a document in cloud storage to TIFF format using detailed conversion settings.
 */
class SaveAsTiffRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/saveAs/tiff"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling saveAsTiff.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling saveAsTiff.');
            }
            // verify required parameter 'this.saveOptions' is not undefined
            if (this.saveOptions === undefined) {
                throw new Error('Required parameter "this.saveOptions" was undefined when calling saveAsTiff.');
            }
            // verify required parameter 'this.saveOptions' is not null
            if (this.saveOptions === null) {
                throw new Error('Required parameter "this.saveOptions" was null when calling saveAsTiff.');
            }
            (_a = this.saveOptions) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "useAntiAliasing", this.useAntiAliasing, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "useHighQualityRendering", this.useHighQualityRendering, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "imageBrightness", this.imageBrightness, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "imageColorMode", this.imageColorMode, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "imageContrast", this.imageContrast, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "numeralFormat", this.numeralFormat, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pageCount", this.pageCount, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pageIndex", this.pageIndex, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "paperColor", this.paperColor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pixelFormat", this.pixelFormat, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "resolution", this.resolution, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scale", this.scale, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "tiffCompression", this.tiffCompression, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "dmlRenderingMode", this.dmlRenderingMode, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "dmlEffectsRenderingMode", this.dmlEffectsRenderingMode, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "tiffBinarizationMethod", this.tiffBinarizationMethod, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "zipOutput", this.zipOutput, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.saveOptions !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.saveOptions, this.saveOptions.constructor.name === "Object" ? "importedTiffSaveOptionsData.TiffSaveOptionsData" : this.saveOptions.constructor.name);
                formParams.push(['SaveOptions', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SaveResponse");
    }
}
exports.SaveAsTiffRequest = SaveAsTiffRequest;
/**
 * Request model for SaveAsTiffOnline operation.
 * Converts a document in cloud storage to TIFF format using detailed conversion settings.
 */
class SaveAsTiffOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/saveAs/tiff"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling saveAsTiffOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling saveAsTiffOnline.');
            }
            // verify required parameter 'this.saveOptions' is not undefined
            if (this.saveOptions === undefined) {
                throw new Error('Required parameter "this.saveOptions" was undefined when calling saveAsTiffOnline.');
            }
            // verify required parameter 'this.saveOptions' is not null
            if (this.saveOptions === null) {
                throw new Error('Required parameter "this.saveOptions" was null when calling saveAsTiffOnline.');
            }
            (_a = this.saveOptions) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "useAntiAliasing", this.useAntiAliasing, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "useHighQualityRendering", this.useHighQualityRendering, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "imageBrightness", this.imageBrightness, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "imageColorMode", this.imageColorMode, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "imageContrast", this.imageContrast, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "numeralFormat", this.numeralFormat, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pageCount", this.pageCount, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pageIndex", this.pageIndex, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "paperColor", this.paperColor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pixelFormat", this.pixelFormat, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "resolution", this.resolution, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "scale", this.scale, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "tiffCompression", this.tiffCompression, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "dmlRenderingMode", this.dmlRenderingMode, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "dmlEffectsRenderingMode", this.dmlEffectsRenderingMode, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "tiffBinarizationMethod", this.tiffBinarizationMethod, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "zipOutput", this.zipOutput, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.saveOptions !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.saveOptions, this.saveOptions.constructor.name === "Object" ? "importedTiffSaveOptionsData.TiffSaveOptionsData" : this.saveOptions.constructor.name);
                formParams.push(['SaveOptions', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new SaveAsTiffOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "SaveResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.SaveAsTiffOnlineRequest = SaveAsTiffOnlineRequest;
/**
 * Request model for Search operation.
 * Searches text, specified by the regular expression, in the document.
 */
class SearchRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/search"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling search.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling search.');
            }
            // verify required parameter 'this.pattern' is not undefined
            if (this.pattern === undefined) {
                throw new Error('Required parameter "this.pattern" was undefined when calling search.');
            }
            // verify required parameter 'this.pattern' is not null
            if (this.pattern === null) {
                throw new Error('Required parameter "this.pattern" was null when calling search.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pattern", this.pattern, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SearchResponse");
    }
}
exports.SearchRequest = SearchRequest;
/**
 * Request model for SearchOnline operation.
 * Searches text, specified by the regular expression, in the document.
 */
class SearchOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/search"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling searchOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling searchOnline.');
            }
            // verify required parameter 'this.pattern' is not undefined
            if (this.pattern === undefined) {
                throw new Error('Required parameter "this.pattern" was undefined when calling searchOnline.');
            }
            // verify required parameter 'this.pattern' is not null
            if (this.pattern === null) {
                throw new Error('Required parameter "this.pattern" was null when calling searchOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "pattern", this.pattern, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SearchResponse");
    }
}
exports.SearchOnlineRequest = SearchOnlineRequest;
/**
 * Request model for SignDocument operation.
 * Signs the document with given certificate.
 */
class SignDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/signatures"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling signDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling signDocument.');
            }
            // verify required parameter 'this.certificatePath' is not undefined
            if (this.certificatePath === undefined) {
                throw new Error('Required parameter "this.certificatePath" was undefined when calling signDocument.');
            }
            // verify required parameter 'this.certificatePath' is not null
            if (this.certificatePath === null) {
                throw new Error('Required parameter "this.certificatePath" was null when calling signDocument.');
            }
            // verify required parameter 'this.certificatePassword' is not undefined
            if (this.certificatePassword === undefined) {
                throw new Error('Required parameter "this.certificatePassword" was undefined when calling signDocument.');
            }
            // verify required parameter 'this.certificatePassword' is not null
            if (this.certificatePassword === null) {
                throw new Error('Required parameter "this.certificatePassword" was null when calling signDocument.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "certificatePath", this.certificatePath, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "certificatePassword", this.certificatePassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "POST",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SignatureCollectionResponse");
    }
}
exports.SignDocumentRequest = SignDocumentRequest;
/**
 * Request model for SignDocumentOnline operation.
 * Signs the document with given certificate.
 */
class SignDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/signatures"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling signDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling signDocumentOnline.');
            }
            // verify required parameter 'this.certificatePath' is not undefined
            if (this.certificatePath === undefined) {
                throw new Error('Required parameter "this.certificatePath" was undefined when calling signDocumentOnline.');
            }
            // verify required parameter 'this.certificatePath' is not null
            if (this.certificatePath === null) {
                throw new Error('Required parameter "this.certificatePath" was null when calling signDocumentOnline.');
            }
            // verify required parameter 'this.certificatePassword' is not undefined
            if (this.certificatePassword === undefined) {
                throw new Error('Required parameter "this.certificatePassword" was undefined when calling signDocumentOnline.');
            }
            // verify required parameter 'this.certificatePassword' is not null
            if (this.certificatePassword === null) {
                throw new Error('Required parameter "this.certificatePassword" was null when calling signDocumentOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "certificatePath", this.certificatePath, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "certificatePassword", this.certificatePassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new SignDocumentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "SignatureCollectionResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.SignDocumentOnlineRequest = SignDocumentOnlineRequest;
/**
 * Request model for SplitDocument operation.
 * Splits a document into parts and saves them in the specified format.
 */
class SplitDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/split"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling splitDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling splitDocument.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling splitDocument.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling splitDocument.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "from", this.from, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "to", this.to, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "zipOutput", this.zipOutput, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SplitDocumentResponse");
    }
}
exports.SplitDocumentRequest = SplitDocumentRequest;
/**
 * Request model for SplitDocumentOnline operation.
 * Splits a document into parts and saves them in the specified format.
 */
class SplitDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/split"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling splitDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling splitDocumentOnline.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling splitDocumentOnline.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling splitDocumentOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "format", this.format, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "from", this.from, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "to", this.to, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "zipOutput", this.zipOutput, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new SplitDocumentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "SplitDocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.SplitDocumentOnlineRequest = SplitDocumentOnlineRequest;
/**
 * Request model for TranslateNodeId operation.
 * Translate a node id to a node path.
 */
class TranslateNodeIdRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/translate/{nodeId}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "nodeId" + "}", (this.nodeId !== null && this.nodeId !== undefined) ? "/" + String(this.nodeId) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling translateNodeId.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling translateNodeId.');
            }
            // verify required parameter 'this.nodeId' is not undefined
            if (this.nodeId === undefined) {
                throw new Error('Required parameter "this.nodeId" was undefined when calling translateNodeId.');
            }
            // verify required parameter 'this.nodeId' is not null
            if (this.nodeId === null) {
                throw new Error('Required parameter "this.nodeId" was null when calling translateNodeId.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "GET",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TranslateNodeIdResponse");
    }
}
exports.TranslateNodeIdRequest = TranslateNodeIdRequest;
/**
 * Request model for TranslateNodeIdOnline operation.
 * Translate a node id to a node path.
 */
class TranslateNodeIdOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/translate/{nodeId}"
                .replace("/{" + "nodeId" + "}", (this.nodeId !== null && this.nodeId !== undefined) ? "/" + String(this.nodeId) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling translateNodeIdOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling translateNodeIdOnline.');
            }
            // verify required parameter 'this.nodeId' is not undefined
            if (this.nodeId === undefined) {
                throw new Error('Required parameter "this.nodeId" was undefined when calling translateNodeIdOnline.');
            }
            // verify required parameter 'this.nodeId' is not null
            if (this.nodeId === null) {
                throw new Error('Required parameter "this.nodeId" was null when calling translateNodeIdOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TranslateNodeIdResponse");
    }
}
exports.TranslateNodeIdOnlineRequest = TranslateNodeIdOnlineRequest;
/**
 * Request model for UnprotectDocument operation.
 * Removes protection from the document.
 */
class UnprotectDocumentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/protection"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling unprotectDocument.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling unprotectDocument.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "DELETE",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ProtectionDataResponse");
    }
}
exports.UnprotectDocumentRequest = UnprotectDocumentRequest;
/**
 * Request model for UnprotectDocumentOnline operation.
 * Removes protection from the document.
 */
class UnprotectDocumentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/protection"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling unprotectDocumentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling unprotectDocumentOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UnprotectDocumentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ProtectionDataResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UnprotectDocumentOnlineRequest = UnprotectDocumentOnlineRequest;
/**
 * Request model for UpdateBookmark operation.
 * Updates a bookmark in the document.
 */
class UpdateBookmarkRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks/{bookmarkName}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateBookmark.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateBookmark.');
            }
            // verify required parameter 'this.bookmarkName' is not undefined
            if (this.bookmarkName === undefined) {
                throw new Error('Required parameter "this.bookmarkName" was undefined when calling updateBookmark.');
            }
            // verify required parameter 'this.bookmarkName' is not null
            if (this.bookmarkName === null) {
                throw new Error('Required parameter "this.bookmarkName" was null when calling updateBookmark.');
            }
            // verify required parameter 'this.bookmarkData' is not undefined
            if (this.bookmarkData === undefined) {
                throw new Error('Required parameter "this.bookmarkData" was undefined when calling updateBookmark.');
            }
            // verify required parameter 'this.bookmarkData' is not null
            if (this.bookmarkData === null) {
                throw new Error('Required parameter "this.bookmarkData" was null when calling updateBookmark.');
            }
            (_a = this.bookmarkData) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.bookmarkData !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.bookmarkData, this.bookmarkData.constructor.name === "Object" ? "importedBookmarkData.BookmarkData" : this.bookmarkData.constructor.name);
                formParams.push(['BookmarkData', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarkResponse");
    }
}
exports.UpdateBookmarkRequest = UpdateBookmarkRequest;
/**
 * Request model for UpdateBookmarkOnline operation.
 * Updates a bookmark in the document.
 */
class UpdateBookmarkOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/bookmarks/{bookmarkName}"
                .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateBookmarkOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateBookmarkOnline.');
            }
            // verify required parameter 'this.bookmarkName' is not undefined
            if (this.bookmarkName === undefined) {
                throw new Error('Required parameter "this.bookmarkName" was undefined when calling updateBookmarkOnline.');
            }
            // verify required parameter 'this.bookmarkName' is not null
            if (this.bookmarkName === null) {
                throw new Error('Required parameter "this.bookmarkName" was null when calling updateBookmarkOnline.');
            }
            // verify required parameter 'this.bookmarkData' is not undefined
            if (this.bookmarkData === undefined) {
                throw new Error('Required parameter "this.bookmarkData" was undefined when calling updateBookmarkOnline.');
            }
            // verify required parameter 'this.bookmarkData' is not null
            if (this.bookmarkData === null) {
                throw new Error('Required parameter "this.bookmarkData" was null when calling updateBookmarkOnline.');
            }
            (_a = this.bookmarkData) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.bookmarkData !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.bookmarkData, this.bookmarkData.constructor.name === "Object" ? "importedBookmarkData.BookmarkData" : this.bookmarkData.constructor.name);
                formParams.push(['BookmarkData', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateBookmarkOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "BookmarkResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateBookmarkOnlineRequest = UpdateBookmarkOnlineRequest;
/**
 * Request model for UpdateBorder operation.
 * Updates a border in the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class UpdateBorderRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders/{borderType}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateBorder.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateBorder.');
            }
            // verify required parameter 'this.borderType' is not undefined
            if (this.borderType === undefined) {
                throw new Error('Required parameter "this.borderType" was undefined when calling updateBorder.');
            }
            // verify required parameter 'this.borderType' is not null
            if (this.borderType === null) {
                throw new Error('Required parameter "this.borderType" was null when calling updateBorder.');
            }
            // verify required parameter 'this.borderProperties' is not undefined
            if (this.borderProperties === undefined) {
                throw new Error('Required parameter "this.borderProperties" was undefined when calling updateBorder.');
            }
            // verify required parameter 'this.borderProperties' is not null
            if (this.borderProperties === null) {
                throw new Error('Required parameter "this.borderProperties" was null when calling updateBorder.');
            }
            (_a = this.borderProperties) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.borderProperties !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.borderProperties, this.borderProperties.constructor.name === "Object" ? "importedBorder.Border" : this.borderProperties.constructor.name);
                formParams.push(['BorderProperties', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BorderResponse");
    }
}
exports.UpdateBorderRequest = UpdateBorderRequest;
/**
 * Request model for UpdateBorderOnline operation.
 * Updates a border in the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class UpdateBorderOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/borders/{borderType}"
                .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateBorderOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateBorderOnline.');
            }
            // verify required parameter 'this.borderProperties' is not undefined
            if (this.borderProperties === undefined) {
                throw new Error('Required parameter "this.borderProperties" was undefined when calling updateBorderOnline.');
            }
            // verify required parameter 'this.borderProperties' is not null
            if (this.borderProperties === null) {
                throw new Error('Required parameter "this.borderProperties" was null when calling updateBorderOnline.');
            }
            // verify required parameter 'this.borderType' is not undefined
            if (this.borderType === undefined) {
                throw new Error('Required parameter "this.borderType" was undefined when calling updateBorderOnline.');
            }
            // verify required parameter 'this.borderType' is not null
            if (this.borderType === null) {
                throw new Error('Required parameter "this.borderType" was null when calling updateBorderOnline.');
            }
            (_a = this.borderProperties) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.borderProperties !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.borderProperties, this.borderProperties.constructor.name === "Object" ? "importedBorder.Border" : this.borderProperties.constructor.name);
                formParams.push(['BorderProperties', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateBorderOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "BorderResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateBorderOnlineRequest = UpdateBorderOnlineRequest;
/**
 * Request model for UpdateComment operation.
 * Updates a comment in the document.
 */
class UpdateCommentRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments/{commentIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateComment.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateComment.');
            }
            // verify required parameter 'this.commentIndex' is not undefined
            if (this.commentIndex === undefined) {
                throw new Error('Required parameter "this.commentIndex" was undefined when calling updateComment.');
            }
            // verify required parameter 'this.commentIndex' is not null
            if (this.commentIndex === null) {
                throw new Error('Required parameter "this.commentIndex" was null when calling updateComment.');
            }
            // verify required parameter 'this.comment' is not undefined
            if (this.comment === undefined) {
                throw new Error('Required parameter "this.comment" was undefined when calling updateComment.');
            }
            // verify required parameter 'this.comment' is not null
            if (this.comment === null) {
                throw new Error('Required parameter "this.comment" was null when calling updateComment.');
            }
            (_a = this.comment) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.comment !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.comment, this.comment.constructor.name === "Object" ? "importedCommentUpdate.CommentUpdate" : this.comment.constructor.name);
                formParams.push(['Comment', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentResponse");
    }
}
exports.UpdateCommentRequest = UpdateCommentRequest;
/**
 * Request model for UpdateCommentOnline operation.
 * Updates a comment in the document.
 */
class UpdateCommentOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/comments/{commentIndex}"
                .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateCommentOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateCommentOnline.');
            }
            // verify required parameter 'this.commentIndex' is not undefined
            if (this.commentIndex === undefined) {
                throw new Error('Required parameter "this.commentIndex" was undefined when calling updateCommentOnline.');
            }
            // verify required parameter 'this.commentIndex' is not null
            if (this.commentIndex === null) {
                throw new Error('Required parameter "this.commentIndex" was null when calling updateCommentOnline.');
            }
            // verify required parameter 'this.comment' is not undefined
            if (this.comment === undefined) {
                throw new Error('Required parameter "this.comment" was undefined when calling updateCommentOnline.');
            }
            // verify required parameter 'this.comment' is not null
            if (this.comment === null) {
                throw new Error('Required parameter "this.comment" was null when calling updateCommentOnline.');
            }
            (_a = this.comment) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.comment !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.comment, this.comment.constructor.name === "Object" ? "importedCommentUpdate.CommentUpdate" : this.comment.constructor.name);
                formParams.push(['Comment', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateCommentOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "CommentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateCommentOnlineRequest = UpdateCommentOnlineRequest;
/**
 * Request model for UpdateCustomXmlPart operation.
 * Updates the custom xml part in the document.
 */
class UpdateCustomXmlPartRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts/{customXmlPartIndex}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateCustomXmlPart.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not undefined
            if (this.customXmlPartIndex === undefined) {
                throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling updateCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not null
            if (this.customXmlPartIndex === null) {
                throw new Error('Required parameter "this.customXmlPartIndex" was null when calling updateCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPart' is not undefined
            if (this.customXmlPart === undefined) {
                throw new Error('Required parameter "this.customXmlPart" was undefined when calling updateCustomXmlPart.');
            }
            // verify required parameter 'this.customXmlPart' is not null
            if (this.customXmlPart === null) {
                throw new Error('Required parameter "this.customXmlPart" was null when calling updateCustomXmlPart.');
            }
            (_a = this.customXmlPart) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.customXmlPart !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.customXmlPart, this.customXmlPart.constructor.name === "Object" ? "importedCustomXmlPartUpdate.CustomXmlPartUpdate" : this.customXmlPart.constructor.name);
                formParams.push(['CustomXmlPart', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartResponse");
    }
}
exports.UpdateCustomXmlPartRequest = UpdateCustomXmlPartRequest;
/**
 * Request model for UpdateCustomXmlPartOnline operation.
 * Updates the custom xml part in the document.
 */
class UpdateCustomXmlPartOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/customXmlParts/{customXmlPartIndex}"
                .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateCustomXmlPartOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not undefined
            if (this.customXmlPartIndex === undefined) {
                throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling updateCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPartIndex' is not null
            if (this.customXmlPartIndex === null) {
                throw new Error('Required parameter "this.customXmlPartIndex" was null when calling updateCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPart' is not undefined
            if (this.customXmlPart === undefined) {
                throw new Error('Required parameter "this.customXmlPart" was undefined when calling updateCustomXmlPartOnline.');
            }
            // verify required parameter 'this.customXmlPart' is not null
            if (this.customXmlPart === null) {
                throw new Error('Required parameter "this.customXmlPart" was null when calling updateCustomXmlPartOnline.');
            }
            (_a = this.customXmlPart) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.customXmlPart !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.customXmlPart, this.customXmlPart.constructor.name === "Object" ? "importedCustomXmlPartUpdate.CustomXmlPartUpdate" : this.customXmlPart.constructor.name);
                formParams.push(['CustomXmlPart', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateCustomXmlPartOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "CustomXmlPartResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateCustomXmlPartOnlineRequest = UpdateCustomXmlPartOnlineRequest;
/**
 * Request model for UpdateDrawingObject operation.
 * Updates a DrawingObject in the document node.
 */
class UpdateDrawingObjectRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateDrawingObject.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateDrawingObject.');
            }
            // verify required parameter 'this.drawingObject' is not undefined
            if (this.drawingObject === undefined) {
                throw new Error('Required parameter "this.drawingObject" was undefined when calling updateDrawingObject.');
            }
            // verify required parameter 'this.drawingObject' is not null
            if (this.drawingObject === null) {
                throw new Error('Required parameter "this.drawingObject" was null when calling updateDrawingObject.');
            }
            // verify required parameter 'this.imageFile' is not undefined
            if (this.imageFile === undefined) {
                throw new Error('Required parameter "this.imageFile" was undefined when calling updateDrawingObject.');
            }
            // verify required parameter 'this.imageFile' is not null
            if (this.imageFile === null) {
                throw new Error('Required parameter "this.imageFile" was null when calling updateDrawingObject.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateDrawingObject.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateDrawingObject.');
            }
            (_a = this.drawingObject) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.drawingObject !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.drawingObject, this.drawingObject.constructor.name === "Object" ? "importedDrawingObjectUpdate.DrawingObjectUpdate" : this.drawingObject.constructor.name);
                formParams.push(['DrawingObject', JSON.stringify(_obj), 'application/json']);
            }
            if (this.imageFile !== undefined) {
                formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectResponse");
    }
}
exports.UpdateDrawingObjectRequest = UpdateDrawingObjectRequest;
/**
 * Request model for UpdateDrawingObjectOnline operation.
 * Updates a DrawingObject in the document node.
 */
class UpdateDrawingObjectOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/drawingObjects/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateDrawingObjectOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateDrawingObjectOnline.');
            }
            // verify required parameter 'this.drawingObject' is not undefined
            if (this.drawingObject === undefined) {
                throw new Error('Required parameter "this.drawingObject" was undefined when calling updateDrawingObjectOnline.');
            }
            // verify required parameter 'this.drawingObject' is not null
            if (this.drawingObject === null) {
                throw new Error('Required parameter "this.drawingObject" was null when calling updateDrawingObjectOnline.');
            }
            // verify required parameter 'this.imageFile' is not undefined
            if (this.imageFile === undefined) {
                throw new Error('Required parameter "this.imageFile" was undefined when calling updateDrawingObjectOnline.');
            }
            // verify required parameter 'this.imageFile' is not null
            if (this.imageFile === null) {
                throw new Error('Required parameter "this.imageFile" was null when calling updateDrawingObjectOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateDrawingObjectOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateDrawingObjectOnline.');
            }
            (_a = this.drawingObject) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.drawingObject !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.drawingObject, this.drawingObject.constructor.name === "Object" ? "importedDrawingObjectUpdate.DrawingObjectUpdate" : this.drawingObject.constructor.name);
                formParams.push(['DrawingObject', JSON.stringify(_obj), 'application/json']);
            }
            if (this.imageFile !== undefined) {
                formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateDrawingObjectOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DrawingObjectResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateDrawingObjectOnlineRequest = UpdateDrawingObjectOnlineRequest;
/**
 * Request model for UpdateField operation.
 * Updates a field in the document node.
 */
class UpdateFieldRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateField.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateField.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateField.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateField.');
            }
            // verify required parameter 'this.field' is not undefined
            if (this.field === undefined) {
                throw new Error('Required parameter "this.field" was undefined when calling updateField.');
            }
            // verify required parameter 'this.field' is not null
            if (this.field === null) {
                throw new Error('Required parameter "this.field" was null when calling updateField.');
            }
            (_a = this.field) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.field !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.field, this.field.constructor.name === "Object" ? "importedFieldUpdate.FieldUpdate" : this.field.constructor.name);
                formParams.push(['Field', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldResponse");
    }
}
exports.UpdateFieldRequest = UpdateFieldRequest;
/**
 * Request model for UpdateFieldOnline operation.
 * Updates a field in the document node.
 */
class UpdateFieldOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/fields/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateFieldOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateFieldOnline.');
            }
            // verify required parameter 'this.field' is not undefined
            if (this.field === undefined) {
                throw new Error('Required parameter "this.field" was undefined when calling updateFieldOnline.');
            }
            // verify required parameter 'this.field' is not null
            if (this.field === null) {
                throw new Error('Required parameter "this.field" was null when calling updateFieldOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateFieldOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateFieldOnline.');
            }
            (_a = this.field) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.field !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.field, this.field.constructor.name === "Object" ? "importedFieldUpdate.FieldUpdate" : this.field.constructor.name);
                formParams.push(['Field', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateFieldOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "FieldResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateFieldOnlineRequest = UpdateFieldOnlineRequest;
/**
 * Request model for UpdateFields operation.
 * Reevaluates field values in the document.
 */
class UpdateFieldsRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/updateFields"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateFields.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateFields.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
    }
}
exports.UpdateFieldsRequest = UpdateFieldsRequest;
/**
 * Request model for UpdateFieldsOnline operation.
 * Reevaluates field values in the document.
 */
class UpdateFieldsOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/updateFields"
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateFieldsOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateFieldsOnline.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateFieldsOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "DocumentResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateFieldsOnlineRequest = UpdateFieldsOnlineRequest;
/**
 * Request model for UpdateFootnote operation.
 * Updates a footnote in the document node.
 */
class UpdateFootnoteRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateFootnote.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateFootnote.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateFootnote.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateFootnote.');
            }
            // verify required parameter 'this.footnoteDto' is not undefined
            if (this.footnoteDto === undefined) {
                throw new Error('Required parameter "this.footnoteDto" was undefined when calling updateFootnote.');
            }
            // verify required parameter 'this.footnoteDto' is not null
            if (this.footnoteDto === null) {
                throw new Error('Required parameter "this.footnoteDto" was null when calling updateFootnote.');
            }
            (_a = this.footnoteDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.footnoteDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.footnoteDto, this.footnoteDto.constructor.name === "Object" ? "importedFootnoteUpdate.FootnoteUpdate" : this.footnoteDto.constructor.name);
                formParams.push(['FootnoteDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnoteResponse");
    }
}
exports.UpdateFootnoteRequest = UpdateFootnoteRequest;
/**
 * Request model for UpdateFootnoteOnline operation.
 * Updates a footnote in the document node.
 */
class UpdateFootnoteOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/footnotes/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateFootnoteOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateFootnoteOnline.');
            }
            // verify required parameter 'this.footnoteDto' is not undefined
            if (this.footnoteDto === undefined) {
                throw new Error('Required parameter "this.footnoteDto" was undefined when calling updateFootnoteOnline.');
            }
            // verify required parameter 'this.footnoteDto' is not null
            if (this.footnoteDto === null) {
                throw new Error('Required parameter "this.footnoteDto" was null when calling updateFootnoteOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateFootnoteOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateFootnoteOnline.');
            }
            (_a = this.footnoteDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.footnoteDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.footnoteDto, this.footnoteDto.constructor.name === "Object" ? "importedFootnoteUpdate.FootnoteUpdate" : this.footnoteDto.constructor.name);
                formParams.push(['FootnoteDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateFootnoteOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "FootnoteResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateFootnoteOnlineRequest = UpdateFootnoteOnlineRequest;
/**
 * Request model for UpdateFormField operation.
 * Updates a form field in the document node.
 */
class UpdateFormFieldRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateFormField.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateFormField.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateFormField.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateFormField.');
            }
            // verify required parameter 'this.formField' is not undefined
            if (this.formField === undefined) {
                throw new Error('Required parameter "this.formField" was undefined when calling updateFormField.');
            }
            // verify required parameter 'this.formField' is not null
            if (this.formField === null) {
                throw new Error('Required parameter "this.formField" was null when calling updateFormField.');
            }
            (_a = this.formField) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.formField !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.formField, this.formField.constructor.name === "Object" ? "importedFormField.FormField" : this.formField.constructor.name);
                formParams.push(['FormField', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldResponse");
    }
}
exports.UpdateFormFieldRequest = UpdateFormFieldRequest;
/**
 * Request model for UpdateFormFieldOnline operation.
 * Updates a form field in the document node.
 */
class UpdateFormFieldOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/formfields/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateFormFieldOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateFormFieldOnline.');
            }
            // verify required parameter 'this.formField' is not undefined
            if (this.formField === undefined) {
                throw new Error('Required parameter "this.formField" was undefined when calling updateFormFieldOnline.');
            }
            // verify required parameter 'this.formField' is not null
            if (this.formField === null) {
                throw new Error('Required parameter "this.formField" was null when calling updateFormFieldOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateFormFieldOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateFormFieldOnline.');
            }
            (_a = this.formField) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.formField !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.formField, this.formField.constructor.name === "Object" ? "importedFormField.FormField" : this.formField.constructor.name);
                formParams.push(['FormField', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateFormFieldOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "FormFieldResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateFormFieldOnlineRequest = UpdateFormFieldOnlineRequest;
/**
 * Request model for UpdateList operation.
 * Updates a list in the document.
 */
class UpdateListRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists/{listId}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateList.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateList.');
            }
            // verify required parameter 'this.listId' is not undefined
            if (this.listId === undefined) {
                throw new Error('Required parameter "this.listId" was undefined when calling updateList.');
            }
            // verify required parameter 'this.listId' is not null
            if (this.listId === null) {
                throw new Error('Required parameter "this.listId" was null when calling updateList.');
            }
            // verify required parameter 'this.listUpdate' is not undefined
            if (this.listUpdate === undefined) {
                throw new Error('Required parameter "this.listUpdate" was undefined when calling updateList.');
            }
            // verify required parameter 'this.listUpdate' is not null
            if (this.listUpdate === null) {
                throw new Error('Required parameter "this.listUpdate" was null when calling updateList.');
            }
            (_a = this.listUpdate) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.listUpdate !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.listUpdate, this.listUpdate.constructor.name === "Object" ? "importedListUpdate.ListUpdate" : this.listUpdate.constructor.name);
                formParams.push(['ListUpdate', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
    }
}
exports.UpdateListRequest = UpdateListRequest;
/**
 * Request model for UpdateListLevel operation.
 * Updates the level of a List element in the document.
 */
class UpdateListLevelRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists/{listId}/listLevels/{listLevel}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
                .replace("/{" + "listLevel" + "}", (this.listLevel !== null && this.listLevel !== undefined) ? "/" + String(this.listLevel) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateListLevel.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateListLevel.');
            }
            // verify required parameter 'this.listId' is not undefined
            if (this.listId === undefined) {
                throw new Error('Required parameter "this.listId" was undefined when calling updateListLevel.');
            }
            // verify required parameter 'this.listId' is not null
            if (this.listId === null) {
                throw new Error('Required parameter "this.listId" was null when calling updateListLevel.');
            }
            // verify required parameter 'this.listLevel' is not undefined
            if (this.listLevel === undefined) {
                throw new Error('Required parameter "this.listLevel" was undefined when calling updateListLevel.');
            }
            // verify required parameter 'this.listLevel' is not null
            if (this.listLevel === null) {
                throw new Error('Required parameter "this.listLevel" was null when calling updateListLevel.');
            }
            // verify required parameter 'this.listUpdate' is not undefined
            if (this.listUpdate === undefined) {
                throw new Error('Required parameter "this.listUpdate" was undefined when calling updateListLevel.');
            }
            // verify required parameter 'this.listUpdate' is not null
            if (this.listUpdate === null) {
                throw new Error('Required parameter "this.listUpdate" was null when calling updateListLevel.');
            }
            (_a = this.listUpdate) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.listUpdate !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.listUpdate, this.listUpdate.constructor.name === "Object" ? "importedListLevelUpdate.ListLevelUpdate" : this.listUpdate.constructor.name);
                formParams.push(['ListUpdate', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
    }
}
exports.UpdateListLevelRequest = UpdateListLevelRequest;
/**
 * Request model for UpdateListLevelOnline operation.
 * Updates the level of a List element in the document.
 */
class UpdateListLevelOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/lists/{listId}/listLevels/{listLevel}"
                .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
                .replace("/{" + "listLevel" + "}", (this.listLevel !== null && this.listLevel !== undefined) ? "/" + String(this.listLevel) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateListLevelOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateListLevelOnline.');
            }
            // verify required parameter 'this.listId' is not undefined
            if (this.listId === undefined) {
                throw new Error('Required parameter "this.listId" was undefined when calling updateListLevelOnline.');
            }
            // verify required parameter 'this.listId' is not null
            if (this.listId === null) {
                throw new Error('Required parameter "this.listId" was null when calling updateListLevelOnline.');
            }
            // verify required parameter 'this.listUpdate' is not undefined
            if (this.listUpdate === undefined) {
                throw new Error('Required parameter "this.listUpdate" was undefined when calling updateListLevelOnline.');
            }
            // verify required parameter 'this.listUpdate' is not null
            if (this.listUpdate === null) {
                throw new Error('Required parameter "this.listUpdate" was null when calling updateListLevelOnline.');
            }
            // verify required parameter 'this.listLevel' is not undefined
            if (this.listLevel === undefined) {
                throw new Error('Required parameter "this.listLevel" was undefined when calling updateListLevelOnline.');
            }
            // verify required parameter 'this.listLevel' is not null
            if (this.listLevel === null) {
                throw new Error('Required parameter "this.listLevel" was null when calling updateListLevelOnline.');
            }
            (_a = this.listUpdate) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.listUpdate !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.listUpdate, this.listUpdate.constructor.name === "Object" ? "importedListLevelUpdate.ListLevelUpdate" : this.listUpdate.constructor.name);
                formParams.push(['ListUpdate', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateListLevelOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ListResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateListLevelOnlineRequest = UpdateListLevelOnlineRequest;
/**
 * Request model for UpdateListOnline operation.
 * Updates a list in the document.
 */
class UpdateListOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/lists/{listId}"
                .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateListOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateListOnline.');
            }
            // verify required parameter 'this.listId' is not undefined
            if (this.listId === undefined) {
                throw new Error('Required parameter "this.listId" was undefined when calling updateListOnline.');
            }
            // verify required parameter 'this.listId' is not null
            if (this.listId === null) {
                throw new Error('Required parameter "this.listId" was null when calling updateListOnline.');
            }
            // verify required parameter 'this.listUpdate' is not undefined
            if (this.listUpdate === undefined) {
                throw new Error('Required parameter "this.listUpdate" was undefined when calling updateListOnline.');
            }
            // verify required parameter 'this.listUpdate' is not null
            if (this.listUpdate === null) {
                throw new Error('Required parameter "this.listUpdate" was null when calling updateListOnline.');
            }
            (_a = this.listUpdate) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.listUpdate !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.listUpdate, this.listUpdate.constructor.name === "Object" ? "importedListUpdate.ListUpdate" : this.listUpdate.constructor.name);
                formParams.push(['ListUpdate', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateListOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ListResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateListOnlineRequest = UpdateListOnlineRequest;
/**
 * Request model for UpdateParagraphFormat operation.
 * Updates the formatting properties of a paragraph in the document node.
 */
class UpdateParagraphFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/format"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateParagraphFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateParagraphFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateParagraphFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateParagraphFormat.');
            }
            // verify required parameter 'this.paragraphFormatDto' is not undefined
            if (this.paragraphFormatDto === undefined) {
                throw new Error('Required parameter "this.paragraphFormatDto" was undefined when calling updateParagraphFormat.');
            }
            // verify required parameter 'this.paragraphFormatDto' is not null
            if (this.paragraphFormatDto === null) {
                throw new Error('Required parameter "this.paragraphFormatDto" was null when calling updateParagraphFormat.');
            }
            (_a = this.paragraphFormatDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.paragraphFormatDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.paragraphFormatDto, this.paragraphFormatDto.constructor.name === "Object" ? "importedParagraphFormatUpdate.ParagraphFormatUpdate" : this.paragraphFormatDto.constructor.name);
                formParams.push(['ParagraphFormatDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphFormatResponse");
    }
}
exports.UpdateParagraphFormatRequest = UpdateParagraphFormatRequest;
/**
 * Request model for UpdateParagraphFormatOnline operation.
 * Updates the formatting properties of a paragraph in the document node.
 */
class UpdateParagraphFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/paragraphs/{index}/format"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateParagraphFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateParagraphFormatOnline.');
            }
            // verify required parameter 'this.paragraphFormatDto' is not undefined
            if (this.paragraphFormatDto === undefined) {
                throw new Error('Required parameter "this.paragraphFormatDto" was undefined when calling updateParagraphFormatOnline.');
            }
            // verify required parameter 'this.paragraphFormatDto' is not null
            if (this.paragraphFormatDto === null) {
                throw new Error('Required parameter "this.paragraphFormatDto" was null when calling updateParagraphFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateParagraphFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateParagraphFormatOnline.');
            }
            (_a = this.paragraphFormatDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.paragraphFormatDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.paragraphFormatDto, this.paragraphFormatDto.constructor.name === "Object" ? "importedParagraphFormatUpdate.ParagraphFormatUpdate" : this.paragraphFormatDto.constructor.name);
                formParams.push(['ParagraphFormatDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateParagraphFormatOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ParagraphFormatResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateParagraphFormatOnlineRequest = UpdateParagraphFormatOnlineRequest;
/**
 * Request model for UpdateParagraphListFormat operation.
 * Updates the formatting properties of a paragraph list in the document node.
 */
class UpdateParagraphListFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/listFormat"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateParagraphListFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateParagraphListFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateParagraphListFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateParagraphListFormat.');
            }
            // verify required parameter 'this.listFormatDto' is not undefined
            if (this.listFormatDto === undefined) {
                throw new Error('Required parameter "this.listFormatDto" was undefined when calling updateParagraphListFormat.');
            }
            // verify required parameter 'this.listFormatDto' is not null
            if (this.listFormatDto === null) {
                throw new Error('Required parameter "this.listFormatDto" was null when calling updateParagraphListFormat.');
            }
            (_a = this.listFormatDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.listFormatDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.listFormatDto, this.listFormatDto.constructor.name === "Object" ? "importedListFormatUpdate.ListFormatUpdate" : this.listFormatDto.constructor.name);
                formParams.push(['ListFormatDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphListFormatResponse");
    }
}
exports.UpdateParagraphListFormatRequest = UpdateParagraphListFormatRequest;
/**
 * Request model for UpdateParagraphListFormatOnline operation.
 * Updates the formatting properties of a paragraph list in the document node.
 */
class UpdateParagraphListFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/paragraphs/{index}/listFormat"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateParagraphListFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateParagraphListFormatOnline.');
            }
            // verify required parameter 'this.listFormatDto' is not undefined
            if (this.listFormatDto === undefined) {
                throw new Error('Required parameter "this.listFormatDto" was undefined when calling updateParagraphListFormatOnline.');
            }
            // verify required parameter 'this.listFormatDto' is not null
            if (this.listFormatDto === null) {
                throw new Error('Required parameter "this.listFormatDto" was null when calling updateParagraphListFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateParagraphListFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateParagraphListFormatOnline.');
            }
            (_a = this.listFormatDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.listFormatDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.listFormatDto, this.listFormatDto.constructor.name === "Object" ? "importedListFormatUpdate.ListFormatUpdate" : this.listFormatDto.constructor.name);
                formParams.push(['ListFormatDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateParagraphListFormatOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "ParagraphListFormatResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateParagraphListFormatOnlineRequest = UpdateParagraphListFormatOnlineRequest;
/**
 * Request model for UpdateRun operation.
 * Updates a Run object in the paragraph.
 */
class UpdateRunRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateRun.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateRun.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling updateRun.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling updateRun.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateRun.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateRun.');
            }
            // verify required parameter 'this.run' is not undefined
            if (this.run === undefined) {
                throw new Error('Required parameter "this.run" was undefined when calling updateRun.');
            }
            // verify required parameter 'this.run' is not null
            if (this.run === null) {
                throw new Error('Required parameter "this.run" was null when calling updateRun.');
            }
            (_a = this.run) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.run !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.run, this.run.constructor.name === "Object" ? "importedRunUpdate.RunUpdate" : this.run.constructor.name);
                formParams.push(['Run', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunResponse");
    }
}
exports.UpdateRunRequest = UpdateRunRequest;
/**
 * Request model for UpdateRunFont operation.
 * Updates the font properties of a Run object in the paragraph.
 */
class UpdateRunFontRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}/font"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateRunFont.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateRunFont.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling updateRunFont.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling updateRunFont.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateRunFont.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateRunFont.');
            }
            // verify required parameter 'this.fontDto' is not undefined
            if (this.fontDto === undefined) {
                throw new Error('Required parameter "this.fontDto" was undefined when calling updateRunFont.');
            }
            // verify required parameter 'this.fontDto' is not null
            if (this.fontDto === null) {
                throw new Error('Required parameter "this.fontDto" was null when calling updateRunFont.');
            }
            (_a = this.fontDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.fontDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.fontDto, this.fontDto.constructor.name === "Object" ? "importedFont.Font" : this.fontDto.constructor.name);
                formParams.push(['FontDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FontResponse");
    }
}
exports.UpdateRunFontRequest = UpdateRunFontRequest;
/**
 * Request model for UpdateRunFontOnline operation.
 * Updates the font properties of a Run object in the paragraph.
 */
class UpdateRunFontOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{paragraphPath}/runs/{index}/font"
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateRunFontOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateRunFontOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling updateRunFontOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling updateRunFontOnline.');
            }
            // verify required parameter 'this.fontDto' is not undefined
            if (this.fontDto === undefined) {
                throw new Error('Required parameter "this.fontDto" was undefined when calling updateRunFontOnline.');
            }
            // verify required parameter 'this.fontDto' is not null
            if (this.fontDto === null) {
                throw new Error('Required parameter "this.fontDto" was null when calling updateRunFontOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateRunFontOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateRunFontOnline.');
            }
            (_a = this.fontDto) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.fontDto !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.fontDto, this.fontDto.constructor.name === "Object" ? "importedFont.Font" : this.fontDto.constructor.name);
                formParams.push(['FontDto', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateRunFontOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "FontResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateRunFontOnlineRequest = UpdateRunFontOnlineRequest;
/**
 * Request model for UpdateRunOnline operation.
 * Updates a Run object in the paragraph.
 */
class UpdateRunOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{paragraphPath}/runs/{index}"
                .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateRunOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateRunOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not undefined
            if (this.paragraphPath === undefined) {
                throw new Error('Required parameter "this.paragraphPath" was undefined when calling updateRunOnline.');
            }
            // verify required parameter 'this.paragraphPath' is not null
            if (this.paragraphPath === null) {
                throw new Error('Required parameter "this.paragraphPath" was null when calling updateRunOnline.');
            }
            // verify required parameter 'this.run' is not undefined
            if (this.run === undefined) {
                throw new Error('Required parameter "this.run" was undefined when calling updateRunOnline.');
            }
            // verify required parameter 'this.run' is not null
            if (this.run === null) {
                throw new Error('Required parameter "this.run" was null when calling updateRunOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateRunOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateRunOnline.');
            }
            (_a = this.run) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.run !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.run, this.run.constructor.name === "Object" ? "importedRunUpdate.RunUpdate" : this.run.constructor.name);
                formParams.push(['Run', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateRunOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "RunResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateRunOnlineRequest = UpdateRunOnlineRequest;
/**
 * Request model for UpdateSectionPageSetup operation.
 * Updates the page setup of a section in the document.
 */
class UpdateSectionPageSetupRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}/pageSetup"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateSectionPageSetup.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateSectionPageSetup.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling updateSectionPageSetup.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling updateSectionPageSetup.');
            }
            // verify required parameter 'this.pageSetup' is not undefined
            if (this.pageSetup === undefined) {
                throw new Error('Required parameter "this.pageSetup" was undefined when calling updateSectionPageSetup.');
            }
            // verify required parameter 'this.pageSetup' is not null
            if (this.pageSetup === null) {
                throw new Error('Required parameter "this.pageSetup" was null when calling updateSectionPageSetup.');
            }
            (_a = this.pageSetup) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.pageSetup !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.pageSetup, this.pageSetup.constructor.name === "Object" ? "importedPageSetup.PageSetup" : this.pageSetup.constructor.name);
                formParams.push(['PageSetup', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionPageSetupResponse");
    }
}
exports.UpdateSectionPageSetupRequest = UpdateSectionPageSetupRequest;
/**
 * Request model for UpdateSectionPageSetupOnline operation.
 * Updates the page setup of a section in the document.
 */
class UpdateSectionPageSetupOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/sections/{sectionIndex}/pageSetup"
                .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateSectionPageSetupOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateSectionPageSetupOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not undefined
            if (this.sectionIndex === undefined) {
                throw new Error('Required parameter "this.sectionIndex" was undefined when calling updateSectionPageSetupOnline.');
            }
            // verify required parameter 'this.sectionIndex' is not null
            if (this.sectionIndex === null) {
                throw new Error('Required parameter "this.sectionIndex" was null when calling updateSectionPageSetupOnline.');
            }
            // verify required parameter 'this.pageSetup' is not undefined
            if (this.pageSetup === undefined) {
                throw new Error('Required parameter "this.pageSetup" was undefined when calling updateSectionPageSetupOnline.');
            }
            // verify required parameter 'this.pageSetup' is not null
            if (this.pageSetup === null) {
                throw new Error('Required parameter "this.pageSetup" was null when calling updateSectionPageSetupOnline.');
            }
            (_a = this.pageSetup) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.pageSetup !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.pageSetup, this.pageSetup.constructor.name === "Object" ? "importedPageSetup.PageSetup" : this.pageSetup.constructor.name);
                formParams.push(['PageSetup', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateSectionPageSetupOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "SectionPageSetupResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateSectionPageSetupOnlineRequest = UpdateSectionPageSetupOnlineRequest;
/**
 * Request model for UpdateStructuredDocumentTag operation.
 * Updates a StructuredDocumentTag (SDT) in the document node.
 */
class UpdateStructuredDocumentTagRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt/{index}"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateStructuredDocumentTag.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateStructuredDocumentTag.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateStructuredDocumentTag.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateStructuredDocumentTag.');
            }
            // verify required parameter 'this.structuredDocumentTag' is not undefined
            if (this.structuredDocumentTag === undefined) {
                throw new Error('Required parameter "this.structuredDocumentTag" was undefined when calling updateStructuredDocumentTag.');
            }
            // verify required parameter 'this.structuredDocumentTag' is not null
            if (this.structuredDocumentTag === null) {
                throw new Error('Required parameter "this.structuredDocumentTag" was null when calling updateStructuredDocumentTag.');
            }
            (_a = this.structuredDocumentTag) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.structuredDocumentTag !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.structuredDocumentTag, this.structuredDocumentTag.constructor.name === "Object" ? "importedStructuredDocumentTagUpdate.StructuredDocumentTagUpdate" : this.structuredDocumentTag.constructor.name);
                formParams.push(['StructuredDocumentTag', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagResponse");
    }
}
exports.UpdateStructuredDocumentTagRequest = UpdateStructuredDocumentTagRequest;
/**
 * Request model for UpdateStructuredDocumentTagOnline operation.
 * Updates a StructuredDocumentTag (SDT) in the document node.
 */
class UpdateStructuredDocumentTagOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/sdt/{index}"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.structuredDocumentTag' is not undefined
            if (this.structuredDocumentTag === undefined) {
                throw new Error('Required parameter "this.structuredDocumentTag" was undefined when calling updateStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.structuredDocumentTag' is not null
            if (this.structuredDocumentTag === null) {
                throw new Error('Required parameter "this.structuredDocumentTag" was null when calling updateStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateStructuredDocumentTagOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateStructuredDocumentTagOnline.');
            }
            (_a = this.structuredDocumentTag) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.structuredDocumentTag !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.structuredDocumentTag, this.structuredDocumentTag.constructor.name === "Object" ? "importedStructuredDocumentTagUpdate.StructuredDocumentTagUpdate" : this.structuredDocumentTag.constructor.name);
                formParams.push(['StructuredDocumentTag', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateStructuredDocumentTagOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "StructuredDocumentTagResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateStructuredDocumentTagOnlineRequest = UpdateStructuredDocumentTagOnlineRequest;
/**
 * Request model for UpdateStyle operation.
 * Updates a style in the document.
 */
class UpdateStyleRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/{styleName}/update"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "styleName" + "}", (this.styleName !== null && this.styleName !== undefined) ? "/" + String(this.styleName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateStyle.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateStyle.');
            }
            // verify required parameter 'this.styleName' is not undefined
            if (this.styleName === undefined) {
                throw new Error('Required parameter "this.styleName" was undefined when calling updateStyle.');
            }
            // verify required parameter 'this.styleName' is not null
            if (this.styleName === null) {
                throw new Error('Required parameter "this.styleName" was null when calling updateStyle.');
            }
            // verify required parameter 'this.styleUpdate' is not undefined
            if (this.styleUpdate === undefined) {
                throw new Error('Required parameter "this.styleUpdate" was undefined when calling updateStyle.');
            }
            // verify required parameter 'this.styleUpdate' is not null
            if (this.styleUpdate === null) {
                throw new Error('Required parameter "this.styleUpdate" was null when calling updateStyle.');
            }
            (_a = this.styleUpdate) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.styleUpdate !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.styleUpdate, this.styleUpdate.constructor.name === "Object" ? "importedStyleUpdate.StyleUpdate" : this.styleUpdate.constructor.name);
                formParams.push(['StyleUpdate', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
    }
}
exports.UpdateStyleRequest = UpdateStyleRequest;
/**
 * Request model for UpdateStyleOnline operation.
 * Updates a style in the document.
 */
class UpdateStyleOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/styles/{styleName}/update"
                .replace("/{" + "styleName" + "}", (this.styleName !== null && this.styleName !== undefined) ? "/" + String(this.styleName) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateStyleOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateStyleOnline.');
            }
            // verify required parameter 'this.styleName' is not undefined
            if (this.styleName === undefined) {
                throw new Error('Required parameter "this.styleName" was undefined when calling updateStyleOnline.');
            }
            // verify required parameter 'this.styleName' is not null
            if (this.styleName === null) {
                throw new Error('Required parameter "this.styleName" was null when calling updateStyleOnline.');
            }
            // verify required parameter 'this.styleUpdate' is not undefined
            if (this.styleUpdate === undefined) {
                throw new Error('Required parameter "this.styleUpdate" was undefined when calling updateStyleOnline.');
            }
            // verify required parameter 'this.styleUpdate' is not null
            if (this.styleUpdate === null) {
                throw new Error('Required parameter "this.styleUpdate" was null when calling updateStyleOnline.');
            }
            (_a = this.styleUpdate) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.styleUpdate !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.styleUpdate, this.styleUpdate.constructor.name === "Object" ? "importedStyleUpdate.StyleUpdate" : this.styleUpdate.constructor.name);
                formParams.push(['StyleUpdate', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateStyleOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "StyleResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateStyleOnlineRequest = UpdateStyleOnlineRequest;
/**
 * Request model for UpdateTableCellFormat operation.
 * Updates the formatting properties of a cell in the table row.
 */
class UpdateTableCellFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells/{index}/cellformat"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateTableCellFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateTableCellFormat.');
            }
            // verify required parameter 'this.tableRowPath' is not undefined
            if (this.tableRowPath === undefined) {
                throw new Error('Required parameter "this.tableRowPath" was undefined when calling updateTableCellFormat.');
            }
            // verify required parameter 'this.tableRowPath' is not null
            if (this.tableRowPath === null) {
                throw new Error('Required parameter "this.tableRowPath" was null when calling updateTableCellFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateTableCellFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateTableCellFormat.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling updateTableCellFormat.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling updateTableCellFormat.');
            }
            (_a = this.format) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.format !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.format, this.format.constructor.name === "Object" ? "importedTableCellFormat.TableCellFormat" : this.format.constructor.name);
                formParams.push(['Format', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellFormatResponse");
    }
}
exports.UpdateTableCellFormatRequest = UpdateTableCellFormatRequest;
/**
 * Request model for UpdateTableCellFormatOnline operation.
 * Updates the formatting properties of a cell in the table row.
 */
class UpdateTableCellFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{tableRowPath}/cells/{index}/cellformat"
                .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateTableCellFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateTableCellFormatOnline.');
            }
            // verify required parameter 'this.tableRowPath' is not undefined
            if (this.tableRowPath === undefined) {
                throw new Error('Required parameter "this.tableRowPath" was undefined when calling updateTableCellFormatOnline.');
            }
            // verify required parameter 'this.tableRowPath' is not null
            if (this.tableRowPath === null) {
                throw new Error('Required parameter "this.tableRowPath" was null when calling updateTableCellFormatOnline.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling updateTableCellFormatOnline.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling updateTableCellFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateTableCellFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateTableCellFormatOnline.');
            }
            (_a = this.format) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.format !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.format, this.format.constructor.name === "Object" ? "importedTableCellFormat.TableCellFormat" : this.format.constructor.name);
                formParams.push(['Format', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateTableCellFormatOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TableCellFormatResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateTableCellFormatOnlineRequest = UpdateTableCellFormatOnlineRequest;
/**
 * Request model for UpdateTableProperties operation.
 * Updates properties of a table in the document node.
 */
class UpdateTablePropertiesRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}/properties"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateTableProperties.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateTableProperties.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateTableProperties.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateTableProperties.');
            }
            // verify required parameter 'this.properties' is not undefined
            if (this.properties === undefined) {
                throw new Error('Required parameter "this.properties" was undefined when calling updateTableProperties.');
            }
            // verify required parameter 'this.properties' is not null
            if (this.properties === null) {
                throw new Error('Required parameter "this.properties" was null when calling updateTableProperties.');
            }
            (_a = this.properties) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.properties !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.properties, this.properties.constructor.name === "Object" ? "importedTableProperties.TableProperties" : this.properties.constructor.name);
                formParams.push(['Properties', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TablePropertiesResponse");
    }
}
exports.UpdateTablePropertiesRequest = UpdateTablePropertiesRequest;
/**
 * Request model for UpdateTablePropertiesOnline operation.
 * Updates properties of a table in the document node.
 */
class UpdateTablePropertiesOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/tables/{index}/properties"
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateTablePropertiesOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateTablePropertiesOnline.');
            }
            // verify required parameter 'this.properties' is not undefined
            if (this.properties === undefined) {
                throw new Error('Required parameter "this.properties" was undefined when calling updateTablePropertiesOnline.');
            }
            // verify required parameter 'this.properties' is not null
            if (this.properties === null) {
                throw new Error('Required parameter "this.properties" was null when calling updateTablePropertiesOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateTablePropertiesOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateTablePropertiesOnline.');
            }
            (_a = this.properties) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.properties !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.properties, this.properties.constructor.name === "Object" ? "importedTableProperties.TableProperties" : this.properties.constructor.name);
                formParams.push(['Properties', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateTablePropertiesOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TablePropertiesResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateTablePropertiesOnlineRequest = UpdateTablePropertiesOnlineRequest;
/**
 * Request model for UpdateTableRowFormat operation.
 * Updates the formatting properties of a table row.
 */
class UpdateTableRowFormatRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tablePath}/rows/{index}/rowformat"
                .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
                .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.name' is not undefined
            if (this.name === undefined) {
                throw new Error('Required parameter "this.name" was undefined when calling updateTableRowFormat.');
            }
            // verify required parameter 'this.name' is not null
            if (this.name === null) {
                throw new Error('Required parameter "this.name" was null when calling updateTableRowFormat.');
            }
            // verify required parameter 'this.tablePath' is not undefined
            if (this.tablePath === undefined) {
                throw new Error('Required parameter "this.tablePath" was undefined when calling updateTableRowFormat.');
            }
            // verify required parameter 'this.tablePath' is not null
            if (this.tablePath === null) {
                throw new Error('Required parameter "this.tablePath" was null when calling updateTableRowFormat.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateTableRowFormat.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateTableRowFormat.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling updateTableRowFormat.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling updateTableRowFormat.');
            }
            (_a = this.format) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "folder", this.folder, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storage", this.storage, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.format !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.format, this.format.constructor.name === "Object" ? "importedTableRowFormat.TableRowFormat" : this.format.constructor.name);
                formParams.push(['Format', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowFormatResponse");
    }
}
exports.UpdateTableRowFormatRequest = UpdateTableRowFormatRequest;
/**
 * Request model for UpdateTableRowFormatOnline operation.
 * Updates the formatting properties of a table row.
 */
class UpdateTableRowFormatOnlineRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{tablePath}/rows/{index}/rowformat"
                .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
                .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.document' is not undefined
            if (this.document === undefined) {
                throw new Error('Required parameter "this.document" was undefined when calling updateTableRowFormatOnline.');
            }
            // verify required parameter 'this.document' is not null
            if (this.document === null) {
                throw new Error('Required parameter "this.document" was null when calling updateTableRowFormatOnline.');
            }
            // verify required parameter 'this.tablePath' is not undefined
            if (this.tablePath === undefined) {
                throw new Error('Required parameter "this.tablePath" was undefined when calling updateTableRowFormatOnline.');
            }
            // verify required parameter 'this.tablePath' is not null
            if (this.tablePath === null) {
                throw new Error('Required parameter "this.tablePath" was null when calling updateTableRowFormatOnline.');
            }
            // verify required parameter 'this.format' is not undefined
            if (this.format === undefined) {
                throw new Error('Required parameter "this.format" was undefined when calling updateTableRowFormatOnline.');
            }
            // verify required parameter 'this.format' is not null
            if (this.format === null) {
                throw new Error('Required parameter "this.format" was null when calling updateTableRowFormatOnline.');
            }
            // verify required parameter 'this.index' is not undefined
            if (this.index === undefined) {
                throw new Error('Required parameter "this.index" was undefined when calling updateTableRowFormatOnline.');
            }
            // verify required parameter 'this.index' is not null
            if (this.index === null) {
                throw new Error('Required parameter "this.index" was null when calling updateTableRowFormatOnline.');
            }
            (_a = this.format) === null || _a === void 0 ? void 0 : _a.validate();
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "password", this.password, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
            if (this.document !== undefined) {
                formParams.push(['Document', this.document, 'application/octet-stream']);
            }
            if (this.format !== undefined) {
                let _obj = objectSerializer_1.ObjectSerializer.serialize(this.format, this.format.constructor.name === "Object" ? "importedTableRowFormat.TableRowFormat" : this.format.constructor.name);
                formParams.push(['Format', JSON.stringify(_obj), 'application/json']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        const result = new UpdateTableRowFormatOnlineResponse();
        const boundary = (0, requestHelper_1.getBoundary)(_headers);
        const parts = (0, requestHelper_1.parseMultipart)(_response, boundary);
        result.model = objectSerializer_1.ObjectSerializer.deserialize(JSON.parse((0, requestHelper_1.findMultipartElement)(parts, "Model").body.toString()), "TableRowFormatResponse");
        const partDocument = (0, requestHelper_1.findMultipartElement)(parts, "Document");
        result.document = (0, requestHelper_1.parseFilesCollection)(partDocument.body, partDocument.headers);
        return result;
    }
}
exports.UpdateTableRowFormatOnlineRequest = UpdateTableRowFormatOnlineRequest;
/**
 * Request model for UploadFile operation.
 * Upload file.
 */
class UploadFileRequest {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * create the requst options for this request
     * @param configuration a configuration for the request
     * @param data encryptor
     */
    createRequestOptions(configuration, _encryptor) {
        return __awaiter(this, void 0, void 0, function* () {
            let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/{path}"
                .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
                .replace("//", "/");
            var queryParameters = {};
            var headerParams = {};
            var formParams = [];
            var filesContent = [];
            // verify required parameter 'this.fileContent' is not undefined
            if (this.fileContent === undefined) {
                throw new Error('Required parameter "this.fileContent" was undefined when calling uploadFile.');
            }
            // verify required parameter 'this.fileContent' is not null
            if (this.fileContent === null) {
                throw new Error('Required parameter "this.fileContent" was null when calling uploadFile.');
            }
            // verify required parameter 'this.path' is not undefined
            if (this.path === undefined) {
                throw new Error('Required parameter "this.path" was undefined when calling uploadFile.');
            }
            // verify required parameter 'this.path' is not null
            if (this.path === null) {
                throw new Error('Required parameter "this.path" was null when calling uploadFile.');
            }
            localVarPath = yield (0, requestHelper_1.addQueryParameterToUrl)(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
            if (this.fileContent !== undefined) {
                formParams.push(['FileContent', this.fileContent, 'application/octet-stream']);
            }
            for (let fileContent of filesContent) {
                yield fileContent.encryptPassword(_encryptor);
                if (fileContent.getSource() == api_1.FileReference.SourceEnum.Request) {
                    formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
                }
            }
            const requestOptions = {
                method: "PUT",
                qs: queryParameters,
                headers: headerParams,
                uri: localVarPath,
            };
            if (formParams.length == 1) {
                let formFirstParam = formParams[0];
                requestOptions.body = formFirstParam[1];
                requestOptions.headers["Content-Type"] = formFirstParam[2];
            }
            else if (formParams.length > 1) {
                const requestParts = [];
                for (let formParam of formParams) {
                    requestParts.push({
                        'Content-Type': formParam[2],
                        'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                        body: formParam[1],
                    });
                }
                requestOptions.headers["Content-Type"] = 'multipart/form-data';
                requestOptions.multipart = requestParts;
            }
            return Promise.resolve(requestOptions);
        });
    }
    /**
     * create response from string
     */
    createResponse(_response, _headers) {
        return objectSerializer_1.ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FilesUploadResult");
    }
}
exports.UploadFileRequest = UploadFileRequest;
/**
 * Response model for AcceptAllRevisionsOnline operation.
 * Accepts all revisions in the document.
 */
class AcceptAllRevisionsOnlineResponse {
}
exports.AcceptAllRevisionsOnlineResponse = AcceptAllRevisionsOnlineResponse;
/**
 * Response model for AppendDocumentOnline operation.
 * Appends documents to the original document.
 */
class AppendDocumentOnlineResponse {
}
exports.AppendDocumentOnlineResponse = AppendDocumentOnlineResponse;
/**
 * Response model for ApplyStyleToDocumentElementOnline operation.
 * Applies a style to the document node.
 */
class ApplyStyleToDocumentElementOnlineResponse {
}
exports.ApplyStyleToDocumentElementOnlineResponse = ApplyStyleToDocumentElementOnlineResponse;
/**
 * Response model for CompareDocumentOnline operation.
 * Compares two documents.
 */
class CompareDocumentOnlineResponse {
}
exports.CompareDocumentOnlineResponse = CompareDocumentOnlineResponse;
/**
 * Response model for CompressDocumentOnline operation.
 * Compress and resize images inside the document.
 * The default settings allows to reduce the size of the document without any visible degradation of images quality.
 */
class CompressDocumentOnlineResponse {
}
exports.CompressDocumentOnlineResponse = CompressDocumentOnlineResponse;
/**
 * Response model for CopyStyleOnline operation.
 * Makes a copy of the style in the document.
 */
class CopyStyleOnlineResponse {
}
exports.CopyStyleOnlineResponse = CopyStyleOnlineResponse;
/**
 * Response model for CreateOrUpdateDocumentPropertyOnline operation.
 * Adds a new or updates an existing document property.
 */
class CreateOrUpdateDocumentPropertyOnlineResponse {
}
exports.CreateOrUpdateDocumentPropertyOnlineResponse = CreateOrUpdateDocumentPropertyOnlineResponse;
/**
 * Response model for DeleteAllParagraphTabStopsOnline operation.
 * Removes paragraph tab stops from the document node.
 */
class DeleteAllParagraphTabStopsOnlineResponse {
}
exports.DeleteAllParagraphTabStopsOnlineResponse = DeleteAllParagraphTabStopsOnlineResponse;
/**
 * Response model for DeleteBorderOnline operation.
 * Removes a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class DeleteBorderOnlineResponse {
}
exports.DeleteBorderOnlineResponse = DeleteBorderOnlineResponse;
/**
 * Response model for DeleteBordersOnline operation.
 * Removes borders from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class DeleteBordersOnlineResponse {
}
exports.DeleteBordersOnlineResponse = DeleteBordersOnlineResponse;
/**
 * Response model for DeleteParagraphListFormatOnline operation.
 * Removes the formatting properties of a paragraph list from the document node.
 */
class DeleteParagraphListFormatOnlineResponse {
}
exports.DeleteParagraphListFormatOnlineResponse = DeleteParagraphListFormatOnlineResponse;
/**
 * Response model for DeleteParagraphTabStopOnline operation.
 * Removes a paragraph tab stop from the document node.
 */
class DeleteParagraphTabStopOnlineResponse {
}
exports.DeleteParagraphTabStopOnlineResponse = DeleteParagraphTabStopOnlineResponse;
/**
 * Response model for DeleteWatermarkOnline operation.
 * Removes a watermark from the document.
 */
class DeleteWatermarkOnlineResponse {
}
exports.DeleteWatermarkOnlineResponse = DeleteWatermarkOnlineResponse;
/**
 * Response model for InsertBookmarkOnline operation.
 * Inserts a new bookmark to the document.
 */
class InsertBookmarkOnlineResponse {
}
exports.InsertBookmarkOnlineResponse = InsertBookmarkOnlineResponse;
/**
 * Response model for InsertCommentOnline operation.
 * Inserts a new comment to the document.
 */
class InsertCommentOnlineResponse {
}
exports.InsertCommentOnlineResponse = InsertCommentOnlineResponse;
/**
 * Response model for InsertCustomXmlPartOnline operation.
 * Inserts a new custom xml part to the document.
 */
class InsertCustomXmlPartOnlineResponse {
}
exports.InsertCustomXmlPartOnlineResponse = InsertCustomXmlPartOnlineResponse;
/**
 * Response model for InsertDrawingObjectOnline operation.
 * Inserts a new DrawingObject to the document node.
 */
class InsertDrawingObjectOnlineResponse {
}
exports.InsertDrawingObjectOnlineResponse = InsertDrawingObjectOnlineResponse;
/**
 * Response model for InsertFieldOnline operation.
 * Inserts a new field to the document node.
 */
class InsertFieldOnlineResponse {
}
exports.InsertFieldOnlineResponse = InsertFieldOnlineResponse;
/**
 * Response model for InsertFootnoteOnline operation.
 * Inserts a new footnote to the document node.
 */
class InsertFootnoteOnlineResponse {
}
exports.InsertFootnoteOnlineResponse = InsertFootnoteOnlineResponse;
/**
 * Response model for InsertFormFieldOnline operation.
 * Inserts a new form field to the document node.
 */
class InsertFormFieldOnlineResponse {
}
exports.InsertFormFieldOnlineResponse = InsertFormFieldOnlineResponse;
/**
 * Response model for InsertHeaderFooterOnline operation.
 * Inserts a new HeaderFooter object to the document section.
 */
class InsertHeaderFooterOnlineResponse {
}
exports.InsertHeaderFooterOnlineResponse = InsertHeaderFooterOnlineResponse;
/**
 * Response model for InsertListOnline operation.
 * Inserts a new list to the document.
 */
class InsertListOnlineResponse {
}
exports.InsertListOnlineResponse = InsertListOnlineResponse;
/**
 * Response model for InsertOrUpdateParagraphTabStopOnline operation.
 * Inserts a new or updates an existing paragraph tab stop in the document node.
 */
class InsertOrUpdateParagraphTabStopOnlineResponse {
}
exports.InsertOrUpdateParagraphTabStopOnlineResponse = InsertOrUpdateParagraphTabStopOnlineResponse;
/**
 * Response model for InsertPageNumbersOnline operation.
 * Inserts page numbers to the document.
 */
class InsertPageNumbersOnlineResponse {
}
exports.InsertPageNumbersOnlineResponse = InsertPageNumbersOnlineResponse;
/**
 * Response model for InsertParagraphOnline operation.
 * Inserts a new paragraph to the document node.
 */
class InsertParagraphOnlineResponse {
}
exports.InsertParagraphOnlineResponse = InsertParagraphOnlineResponse;
/**
 * Response model for InsertRunOnline operation.
 * Inserts a new Run object to the paragraph.
 */
class InsertRunOnlineResponse {
}
exports.InsertRunOnlineResponse = InsertRunOnlineResponse;
/**
 * Response model for InsertStructuredDocumentTagOnline operation.
 * Inserts a new StructuredDocumentTag (SDT) to the document node.
 */
class InsertStructuredDocumentTagOnlineResponse {
}
exports.InsertStructuredDocumentTagOnlineResponse = InsertStructuredDocumentTagOnlineResponse;
/**
 * Response model for InsertStyleOnline operation.
 * Inserts a new style to the document.
 */
class InsertStyleOnlineResponse {
}
exports.InsertStyleOnlineResponse = InsertStyleOnlineResponse;
/**
 * Response model for InsertTableCellOnline operation.
 * Inserts a new cell to the table row.
 */
class InsertTableCellOnlineResponse {
}
exports.InsertTableCellOnlineResponse = InsertTableCellOnlineResponse;
/**
 * Response model for InsertTableOnline operation.
 * Inserts a new table to the document node.
 */
class InsertTableOnlineResponse {
}
exports.InsertTableOnlineResponse = InsertTableOnlineResponse;
/**
 * Response model for InsertTableRowOnline operation.
 * Inserts a new row to the table.
 */
class InsertTableRowOnlineResponse {
}
exports.InsertTableRowOnlineResponse = InsertTableRowOnlineResponse;
/**
 * Response model for InsertWatermarkImageOnline operation.
 * Inserts a new watermark image to the document.
 */
class InsertWatermarkImageOnlineResponse {
}
exports.InsertWatermarkImageOnlineResponse = InsertWatermarkImageOnlineResponse;
/**
 * Response model for InsertWatermarkOnline operation.
 * Insert a watermark to the document.
 */
class InsertWatermarkOnlineResponse {
}
exports.InsertWatermarkOnlineResponse = InsertWatermarkOnlineResponse;
/**
 * Response model for InsertWatermarkTextOnline operation.
 * Inserts a new watermark text to the document.
 */
class InsertWatermarkTextOnlineResponse {
}
exports.InsertWatermarkTextOnlineResponse = InsertWatermarkTextOnlineResponse;
/**
 * Response model for ProtectDocumentOnline operation.
 * Changes the document protection. The previous protection will be overwritten if it exist.
 */
class ProtectDocumentOnlineResponse {
}
exports.ProtectDocumentOnlineResponse = ProtectDocumentOnlineResponse;
/**
 * Response model for RejectAllRevisionsOnline operation.
 * Rejects all revisions in the document.
 */
class RejectAllRevisionsOnlineResponse {
}
exports.RejectAllRevisionsOnlineResponse = RejectAllRevisionsOnlineResponse;
/**
 * Response model for RemoveAllSignaturesOnline operation.
 * Removes all signatures of the document.
 */
class RemoveAllSignaturesOnlineResponse {
}
exports.RemoveAllSignaturesOnlineResponse = RemoveAllSignaturesOnlineResponse;
/**
 * Response model for RemoveRangeOnline operation.
 * Removes a range from the document.
 */
class RemoveRangeOnlineResponse {
}
exports.RemoveRangeOnlineResponse = RemoveRangeOnlineResponse;
/**
 * Response model for ReplaceTextOnline operation.
 * Replaces text in the document.
 */
class ReplaceTextOnlineResponse {
}
exports.ReplaceTextOnlineResponse = ReplaceTextOnlineResponse;
/**
 * Response model for ReplaceWithTextOnline operation.
 * Replaces a range with text in the document.
 */
class ReplaceWithTextOnlineResponse {
}
exports.ReplaceWithTextOnlineResponse = ReplaceWithTextOnlineResponse;
/**
 * Response model for SaveAsOnline operation.
 * Converts a document in cloud storage to the specified format.
 */
class SaveAsOnlineResponse {
}
exports.SaveAsOnlineResponse = SaveAsOnlineResponse;
/**
 * Response model for SaveAsRangeOnline operation.
 * Saves a range as a new document.
 */
class SaveAsRangeOnlineResponse {
}
exports.SaveAsRangeOnlineResponse = SaveAsRangeOnlineResponse;
/**
 * Response model for SaveAsTiffOnline operation.
 * Converts a document in cloud storage to TIFF format using detailed conversion settings.
 */
class SaveAsTiffOnlineResponse {
}
exports.SaveAsTiffOnlineResponse = SaveAsTiffOnlineResponse;
/**
 * Response model for SignDocumentOnline operation.
 * Signs the document with given certificate.
 */
class SignDocumentOnlineResponse {
}
exports.SignDocumentOnlineResponse = SignDocumentOnlineResponse;
/**
 * Response model for SplitDocumentOnline operation.
 * Splits a document into parts and saves them in the specified format.
 */
class SplitDocumentOnlineResponse {
}
exports.SplitDocumentOnlineResponse = SplitDocumentOnlineResponse;
/**
 * Response model for UnprotectDocumentOnline operation.
 * Removes protection from the document.
 */
class UnprotectDocumentOnlineResponse {
}
exports.UnprotectDocumentOnlineResponse = UnprotectDocumentOnlineResponse;
/**
 * Response model for UpdateBookmarkOnline operation.
 * Updates a bookmark in the document.
 */
class UpdateBookmarkOnlineResponse {
}
exports.UpdateBookmarkOnlineResponse = UpdateBookmarkOnlineResponse;
/**
 * Response model for UpdateBorderOnline operation.
 * Updates a border in the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
class UpdateBorderOnlineResponse {
}
exports.UpdateBorderOnlineResponse = UpdateBorderOnlineResponse;
/**
 * Response model for UpdateCommentOnline operation.
 * Updates a comment in the document.
 */
class UpdateCommentOnlineResponse {
}
exports.UpdateCommentOnlineResponse = UpdateCommentOnlineResponse;
/**
 * Response model for UpdateCustomXmlPartOnline operation.
 * Updates the custom xml part in the document.
 */
class UpdateCustomXmlPartOnlineResponse {
}
exports.UpdateCustomXmlPartOnlineResponse = UpdateCustomXmlPartOnlineResponse;
/**
 * Response model for UpdateDrawingObjectOnline operation.
 * Updates a DrawingObject in the document node.
 */
class UpdateDrawingObjectOnlineResponse {
}
exports.UpdateDrawingObjectOnlineResponse = UpdateDrawingObjectOnlineResponse;
/**
 * Response model for UpdateFieldOnline operation.
 * Updates a field in the document node.
 */
class UpdateFieldOnlineResponse {
}
exports.UpdateFieldOnlineResponse = UpdateFieldOnlineResponse;
/**
 * Response model for UpdateFieldsOnline operation.
 * Reevaluates field values in the document.
 */
class UpdateFieldsOnlineResponse {
}
exports.UpdateFieldsOnlineResponse = UpdateFieldsOnlineResponse;
/**
 * Response model for UpdateFootnoteOnline operation.
 * Updates a footnote in the document node.
 */
class UpdateFootnoteOnlineResponse {
}
exports.UpdateFootnoteOnlineResponse = UpdateFootnoteOnlineResponse;
/**
 * Response model for UpdateFormFieldOnline operation.
 * Updates a form field in the document node.
 */
class UpdateFormFieldOnlineResponse {
}
exports.UpdateFormFieldOnlineResponse = UpdateFormFieldOnlineResponse;
/**
 * Response model for UpdateListLevelOnline operation.
 * Updates the level of a List element in the document.
 */
class UpdateListLevelOnlineResponse {
}
exports.UpdateListLevelOnlineResponse = UpdateListLevelOnlineResponse;
/**
 * Response model for UpdateListOnline operation.
 * Updates a list in the document.
 */
class UpdateListOnlineResponse {
}
exports.UpdateListOnlineResponse = UpdateListOnlineResponse;
/**
 * Response model for UpdateParagraphFormatOnline operation.
 * Updates the formatting properties of a paragraph in the document node.
 */
class UpdateParagraphFormatOnlineResponse {
}
exports.UpdateParagraphFormatOnlineResponse = UpdateParagraphFormatOnlineResponse;
/**
 * Response model for UpdateParagraphListFormatOnline operation.
 * Updates the formatting properties of a paragraph list in the document node.
 */
class UpdateParagraphListFormatOnlineResponse {
}
exports.UpdateParagraphListFormatOnlineResponse = UpdateParagraphListFormatOnlineResponse;
/**
 * Response model for UpdateRunFontOnline operation.
 * Updates the font properties of a Run object in the paragraph.
 */
class UpdateRunFontOnlineResponse {
}
exports.UpdateRunFontOnlineResponse = UpdateRunFontOnlineResponse;
/**
 * Response model for UpdateRunOnline operation.
 * Updates a Run object in the paragraph.
 */
class UpdateRunOnlineResponse {
}
exports.UpdateRunOnlineResponse = UpdateRunOnlineResponse;
/**
 * Response model for UpdateSectionPageSetupOnline operation.
 * Updates the page setup of a section in the document.
 */
class UpdateSectionPageSetupOnlineResponse {
}
exports.UpdateSectionPageSetupOnlineResponse = UpdateSectionPageSetupOnlineResponse;
/**
 * Response model for UpdateStructuredDocumentTagOnline operation.
 * Updates a StructuredDocumentTag (SDT) in the document node.
 */
class UpdateStructuredDocumentTagOnlineResponse {
}
exports.UpdateStructuredDocumentTagOnlineResponse = UpdateStructuredDocumentTagOnlineResponse;
/**
 * Response model for UpdateStyleOnline operation.
 * Updates a style in the document.
 */
class UpdateStyleOnlineResponse {
}
exports.UpdateStyleOnlineResponse = UpdateStyleOnlineResponse;
/**
 * Response model for UpdateTableCellFormatOnline operation.
 * Updates the formatting properties of a cell in the table row.
 */
class UpdateTableCellFormatOnlineResponse {
}
exports.UpdateTableCellFormatOnlineResponse = UpdateTableCellFormatOnlineResponse;
/**
 * Response model for UpdateTablePropertiesOnline operation.
 * Updates properties of a table in the document node.
 */
class UpdateTablePropertiesOnlineResponse {
}
exports.UpdateTablePropertiesOnlineResponse = UpdateTablePropertiesOnlineResponse;
/**
 * Response model for UpdateTableRowFormatOnline operation.
 * Updates the formatting properties of a table row.
 */
class UpdateTableRowFormatOnlineResponse {
}
exports.UpdateTableRowFormatOnlineResponse = UpdateTableRowFormatOnlineResponse;
